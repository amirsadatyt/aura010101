<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <title>Sadat Digital Banknote [Fixed & Upgraded]</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    
    <script src="./qrcode.min.js"></script>
    <script src="./jsQR.min.js"></script>
    <script src="./argon2.min.js"></script>
    
    <style>
        :root {
            --primary-font: 'Poppins', 'Segoe UI', sans-serif;
            --mono-font: 'Roboto Mono', monospace;
            --dark-bg: #10101a;
            --medium-bg: #1a1a2e;
            --light-bg: #2a2a3e;
            --accent-color-1: #e040fb;
            --accent-color-2: #7c4dff;
            --text-color: #e0e0e0;
            --text-muted: #a0a0c0;
            --success-color: #00e676;
            --error-color: #ff5252;
            --info-color: #40c4ff;
            --warning-color: #ffab40;
            --border-color: rgba(124, 77, 255, 0.2);
        }
        body { margin: 0; font-family: var(--primary-font); background-color: var(--dark-bg); background-image: radial-gradient(at 0% 0%, hsla(253, 100%, 15%, 0.3) 0px, transparent 50%), radial-gradient(at 100% 100%, hsla(263, 100%, 20%, 0.3) 0px, transparent 50%); color: var(--text-color); text-align: center; padding: 24px; }
        .container { max-width: 1000px; margin: 0 auto; background: rgba(26, 26, 46, 0.7); backdrop-filter: blur(12px); padding: 24px; border-radius: 24px; border: 1px solid var(--border-color); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2); }
        .header { border-bottom: 1px solid var(--border-color); padding-bottom: 16px; margin-bottom: 24px; }
        h1 { font-size: 2.5rem; font-weight: 600; color: #fff; margin: 0 0 8px 0; letter-spacing: 1px; background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .header p { font-size: 1rem; color: var(--text-muted); margin: 0; }
        canvas#noteCanvas { border-radius: 16px; margin-top: 24px; background: #050508; cursor: default; box-shadow: 0 0 50px rgba(124, 77, 255, 0.15); width: 100%; max-width: 1000px; height: auto; border: 1px solid var(--border-color); }
        input, button, label { padding: 14px 22px; font-size: 16px; font-family: var(--primary-font); border-radius: 12px; margin: 8px 5px; border: 1px solid var(--border-color); background: var(--medium-bg); color: #fff; transition: all 0.3s ease; cursor: pointer; outline: none; display: inline-flex; align-items: center; justify-content: center; gap: 8px; }
        input[type="number"], input[type="password"] { font-family: var(--mono-font); font-weight: 700; text-align: center; width: 150px; }
        input:focus { border-color: var(--accent-color-2); box-shadow: 0 0 15px rgba(124, 77, 255, 0.5); }
        button:not([disabled]), label.button:not([disabled]) { font-weight: 600; background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); border: none; box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        button.sub-button, label.button.sub-button { background: var(--light-bg); border: 1px solid var(--border-color); }
        button[disabled], label.button[disabled] { cursor: not-allowed; opacity: 0.5; background: var(--light-bg); border: 1px solid var(--border-color); }
        button:hover:not([disabled]), label.button:hover:not([disabled]) { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(124, 77, 255, 0.4); }
        .section { background: rgba(16, 16, 26, 0.5); padding: 20px; margin-top: 30px; border-radius: 16px; border: 1px solid var(--border-color); }
        h2 { font-size: 1.5rem; color: var(--text-color); margin-top: 0; margin-bottom: 20px; font-weight: 600; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        .controls-grid { display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 16px; }
        .status-box { margin-top: 20px; font-size: 13px; font-weight: normal; min-height: 50px; line-height: 1.6; text-align: left; background: var(--dark-bg); padding: 15px 20px; border-radius: 12px; white-space: pre-wrap; font-family: var(--mono-font); border: 1px solid var(--border-color); transition: all 0.3s ease; }
        .valid { color: var(--success-color); } .invalid { color: var(--error-color); } .info { color: var(--info-color); } .warning { color: var(--warning-color); }
        code { background: var(--medium-bg); padding: 2px 6px; border-radius: 4px; font-size: 1em; }
        .input-label { font-size: 0.9rem; color: var(--text-muted); margin-right: -10px; }
        .modal { position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; }
        .modal-content { background-color: var(--medium-bg); padding: 30px; border: 1px solid var(--border-color); width: 80%; max-width: 500px; border-radius: 16px; text-align: center; }
        #qr-display { margin: 20px auto; background: white; padding: 15px; border-radius: 8px; width: fit-content; }
        .pill { background-color: var(--border-color); color: var(--accent-color-1); padding: 5px 15px; border-radius: 20px; font-size: 14px; font-weight: 600; margin: 5px; display: inline-block; }
    </style>
</head>
<body>
    <div class="container">
    Â  Â  <div class="header">
    Â  Â  Â  Â  <h1>Sadat Digital Banknote</h1>
    Â  Â  Â  Â  <p>A Quantum-Resistant, Offline, Dual-Signature Digital Currency System.</p>
    Â  Â  </div>

    Â  Â  <div class="section">
    Â  Â  Â  Â  <h2><span class="pill">Step 1</span> Guardian Setup: Create Master Keys</h2>
    Â  Â  Â  Â  <div class="controls-grid">
    Â  Â  Â  Â  Â  Â  <button id="generate-keys-button">ğŸ”‘ Generate Master Key Pair</button>
    Â  Â  Â  Â  Â  Â  <label for="import-public-key" class="button sub-button">
    Â  Â  Â  Â  Â  Â  Â  Â  <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
    Â  Â  Â  Â  Â  Â  Â  Â  Load Public Key
    Â  Â  Â  Â  Â  Â  </label>
    Â  Â  Â  Â  Â  Â  <input type="file" id="import-public-key" accept=".json" style="display: none;">
    Â  Â  Â  Â  </div>
    Â  Â  Â  Â  Â <div id="key-gen-status" class="status-box"><span class="info">â„¹ï¸ Welcome, Guardian. Generate a new Master Key Pair to begin your financial ecosystem. This process is fully offline and secure.</span></div>
    Â  Â  </div>

    Â  Â  <div class="section">
    Â  Â  Â  Â  <h2><span class="pill">Step 2</span> Activate System: Reconstruct Private Key</h2>
    Â  Â  Â  Â  <p style="color: var(--text-muted); font-size: 0.9em; max-width: 700px; margin: -10px auto 20px auto;">To create banknotes, you must prove your identity by solving the "Three-Piece Puzzle". This ensures maximum security.</p>
    Â  Â  Â  Â  <div class="controls-grid">
    Â  Â  Â  Â  Â  Â  Â <label for="file-key-input" class="button sub-button">1. Upload File Key</label>
    Â  Â  Â  Â  Â  Â  Â <input type="file" id="file-key-input" accept=".json" style="display:none;" />
    Â  Â  Â  Â  Â  Â  Â <input type="password" id="password-key-input" placeholder="2. Enter Password Key">
    Â  Â  Â  Â  Â  Â  Â <button id="visual-key-button">3. Scan Visual Key (QR)</button>
    Â  Â  Â  Â  </div>
    Â  Â  Â  Â  <button id="reconstruct-key-button" disabled style="margin-top: 20px;">ğŸ”“ Activate Master Private Key</button>
    Â  Â  Â  Â  <div id="key-reconstruction-status" class="status-box"><span class="warning">âš ï¸ Master Private Key is INACTIVE. Solve the puzzle to activate.</span></div>
    Â  Â  </div>

    Â  Â  <div class="section">
    Â  Â  Â  Â  <h2><span class="pill">Step 3</span> Create Wealth: Generate Banknotes</h2>
    Â  Â  Â  Â  <div class="controls-grid">
    Â  Â  Â  Â  Â  Â  <span class="input-label">Amount:</span>
    Â  Â  Â  Â  Â  Â  <input type="number" id="amount-input" value="50000">
    Â  Â  Â  Â  Â  Â  <span class="input-label">Quantity:</span>
    Â  Â  Â  Â  Â  Â  <input type="number" id="quantity-input" value="1" min="1" max="100">
    Â  Â  Â  Â  Â  Â  <button id="create-note-button" disabled>ğŸ¨ Create & Sign Banknote(s)</button>
    Â  Â  Â  Â  </div>
    Â  Â  Â  Â  <canvas id="noteCanvas" width="1350" height="750"></canvas>
    Â  Â  </div>

    Â  Â  <div class="section" id="validator-section">
    Â  Â  Â  Â  <h2><span class="pill">Step 4</span> Verify Authenticity</h2>
    Â  Â  Â  Â  <label for="validator-input" class="button">
    Â  Â  Â  Â  Â  Â  <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
    Â  Â  Â  Â  Â  Â  Select Banknote Image for Validation
    Â  Â  Â  Â  </label>
    Â  Â  Â  Â  <input type="file" id="validator-input" accept="image/png" style="display: none;">
    Â  Â  Â  Â  <div id="validation-result" class="status-box">Awaiting banknote for validation...</div>
    Â  Â  </div>
    </div>

    <div id="qr-modal" class="modal">
    Â  <div class="modal-content">
    Â  Â  <h2 id="qr-modal-title">Your Visual Key</h2>
    Â  Â  <p>Print this QR Code and store it in a secure physical location. It is the third piece of your Master Key puzzle.</p>
    Â  Â  <div id="qr-display"></div>
    Â  Â  <button onclick="document.getElementById('qr-modal').style.display='none'">Close</button>
    Â  </div>
    </div>

    <div id="camera-modal" class="modal">
    Â  <div class="modal-content">
    Â  Â  <h2>Scan Visual Key</h2>
    Â  Â  <video id="camera-video" playsinline style="width: 100%; border-radius: 8px;"></video>
    Â  Â  <p>Align the QR code within the frame.</p>
    Â  Â  <button id="cancel-scan-button">Cancel</button>
    Â  </div>
    </div>

    <script type="module">
        // Import cryptographic libraries as modules
        // CHANGED: Local import for shake256
        import pqcSignFalcon1024 from './pqc-sign-falcon-1024.min.js';
        import { shake256 } from './js-sha3.min.js'; 
        // The argon2.min.js script is loaded in the <head> and provides the global 'argon2' object

        // --- The rest of your JavaScript code remains exactly the same ---
        // --- Global State ---
        const state = {
        Â  Â  falconApi: null,
        Â  Â  masterPublicKey: null,
        Â  Â  masterPrivateKey: null, // This will be held temporarily only during signing
        Â  Â  puzzlePieces: {
        Â  Â  Â  Â  fileKey: null,
        Â  Â  Â  Â  passwordKey: null,
        Â  Â  Â  Â  visualKey: null
        Â  Â  }
        };

        // --- DOM Elements ---
        const DOMElements = {
        Â  Â  generateKeysButton: document.getElementById('generate-keys-button'),
        Â  Â  importPublicKey: document.getElementById('import-public-key'),
        Â  Â  keyGenStatus: document.getElementById('key-gen-status'),
        Â  Â  fileKeyInput: document.getElementById('file-key-input'),
        Â  Â  passwordKeyInput: document.getElementById('password-key-input'),
        Â  Â  visualKeyButton: document.getElementById('visual-key-button'),
        Â  Â  reconstructKeyButton: document.getElementById('reconstruct-key-button'),
        Â  Â  keyReconstructionStatus: document.getElementById('key-reconstruction-status'),
        Â  Â  amountInput: document.getElementById('amount-input'),
        Â  Â  quantityInput: document.getElementById('quantity-input'),
        Â  Â  createNoteButton: document.getElementById('create-note-button'),
        Â  Â  noteCanvas: document.getElementById('noteCanvas'),
        Â  Â  validatorInput: document.getElementById('validator-input'),
        Â  Â  validationResult: document.getElementById('validation-result'),
        Â  Â  qrModal: document.getElementById('qr-modal'),
        Â  Â  qrDisplay: document.getElementById('qr-display'),
        Â  Â  qrModalTitle: document.getElementById('qr-modal-title'),
        Â  Â  cameraModal: document.getElementById('camera-modal'),
        Â  Â  cameraVideo: document.getElementById('camera-video'),
        Â  Â  cancelScanButton: document.getElementById('cancel-scan-button')
        };

        // --- Utility Functions ---
        const Utils = {
        Â  Â  arrayBufferToBase64: (buffer) => btoa(String.fromCharCode(...new Uint8Array(buffer))),
        Â  Â  base64ToUint8Array: (base64) => {
        Â  Â  Â  Â  const binaryString = atob(base64);
        Â  Â  Â  Â  const len = binaryString.length;
        Â  Â  Â  Â  const bytes = new Uint8Array(len);
        Â  Â  Â  Â  for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i);
        Â  Â  Â  Â  return bytes;
        Â  Â  },
        Â  Â  hexToUint8Array: (hex) => new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16))),
        Â  Â  downloadFile: (data, filename, type) => {
        Â  Â  Â  Â  const blob = new Blob([data], { type });
        Â  Â  Â  Â  const url = URL.createObjectURL(blob);
        Â  Â  Â  Â  const a = document.createElement('a');
        Â  Â  Â  Â  a.href = url; a.download = filename;
        Â  Â  Â  Â  document.body.appendChild(a); a.click();
        Â  Â  Â  Â  document.body.removeChild(a); URL.revokeObjectURL(url);
        Â  Â  },
        Â  Â  updateStatus: (element, message, type = 'info') => {
        Â  Â  Â  Â  element.innerHTML = `<span class="${type}">${message}</span>`;
        Â  Â  },
        Â  Â  log: (message, type = 'info') => {
        Â  Â  Â  Â  const icon = { info: 'â„¹ï¸', success: 'âœ…', warning: 'âš ï¸', error: 'âŒ' }[type];
        Â  Â  Â  Â  console.log(`[Sadat System] ${icon} ${message}`);
        Â  Â  }
        };

        // ===================================================================================
        // CORE CRYPTO ENGINE
        // ===================================================================================
        const BankCrypto = (() => {
        Â  Â  const AES_ALGO = "AES-GCM";
        Â  Â  const ARGON2_SALT_LENGTH = 16;
        Â  Â  const ARGON2_KEY_LENGTH = 32;

        Â  Â  async function argon2DeriveKey(password, salt) {
        Â  Â  Â  Â  return argon2.hash({
        Â  Â  Â  Â  Â  Â  pass: new TextEncoder().encode(password),
        Â  Â  Â  Â  Â  Â  salt: salt,
        Â  Â  Â  Â  Â  Â  time: 2,
        Â  Â  Â  Â  Â  Â  mem: 16384,
        Â  Â  Â  Â  Â  Â  hashLen: ARGON2_KEY_LENGTH,
        Â  Â  Â  Â  Â  Â  parallelism: 1,
        Â  Â  Â  Â  Â  Â  type: argon2.ArgonType.Argon2id
        Â  Â  Â  Â  }).then(result => result.hash);
        Â  Â  }
        Â  Â Â 
        Â  Â  function hashMessageForSigning(message) {
        Â  Â  Â  Â  return Utils.hexToUint8Array(shake256(message, 1536));
        Â  Â  }
        Â  Â Â 
        Â  Â  return {
        Â  Â  Â  Â  async generateNewKeyPair() {
        Â  Â  Â  Â  Â  Â  if (!state.falconApi) throw new Error("Falcon API not initialized.");
        Â  Â  Â  Â  Â  Â  return state.falconApi.keypair();
        Â  Â  Â  Â  },
        Â  Â  Â  Â  async signData(data, privateKey) {
        Â  Â  Â  Â  Â  Â  if (!privateKey || !state.falconApi) throw new Error("Signing prerequisites not met.");
        Â  Â  Â  Â  Â  Â  const dataHash = hashMessageForSigning(data);
        Â  Â  Â  Â  Â  Â  const { signature } = await state.falconApi.sign(dataHash, privateKey);
        Â  Â  Â  Â  Â  Â  return signature;
        Â  Â  Â  Â  },
        Â  Â  Â  Â  async verifySignature(signature, data, publicKey) {
        Â  Â  Â  Â  Â  Â  if (!publicKey || !state.falconApi) throw new Error("Verification prerequisites not met.");
        Â  Â  Â  Â  Â  Â  const dataHash = hashMessageForSigning(data);
        Â  Â  Â  Â  Â  Â  return state.falconApi.verify(signature, dataHash, publicKey);
        Â  Â  Â  Â  },
        Â  Â  Â  Â  async encryptMasterKey(masterPrivateKeyBytes, passwordKey, visualKeySecret) {
        Â  Â  Â  Â  Â  Â  const visualKeySalt = crypto.getRandomValues(new Uint8Array(ARGON2_SALT_LENGTH));
        Â  Â  Â  Â  Â  Â  const visualKeyIV = crypto.getRandomValues(new Uint8Array(12));
        Â  Â  Â  Â  Â  Â  const derivedVisualKeyMaterial = await argon2DeriveKey(visualKeySecret, visualKeySalt);
        Â  Â  Â  Â  Â  Â  const cryptoVisualKey = await crypto.subtle.importKey("raw", derivedVisualKeyMaterial, { name: AES_ALGO }, false, ["encrypt"]);
        Â  Â  Â  Â  Â  Â  const encryptedWithVisual = await crypto.subtle.encrypt({ name: AES_ALGO, iv: visualKeyIV }, cryptoVisualKey, masterPrivateKeyBytes);

        Â  Â  Â  Â  Â  Â  const intermediatePayload = JSON.stringify({
        Â  Â  Â  Â  Â  Â  Â  Â  encryptedKey: Utils.arrayBufferToBase64(encryptedWithVisual),
        Â  Â  Â  Â  Â  Â  Â  Â  salt: Utils.arrayBufferToBase64(visualKeySalt),
        Â  Â  Â  Â  Â  Â  Â  Â  iv: Utils.arrayBufferToBase64(visualKeyIV)
        Â  Â  Â  Â  Â  Â  });

        Â  Â  Â  Â  Â  Â  const passwordSalt = crypto.getRandomValues(new Uint8Array(ARGON2_SALT_LENGTH));
        Â  Â  Â  Â  Â  Â  const passwordIV = crypto.getRandomValues(new Uint8Array(12));
        Â  Â  Â  Â  Â  Â  const derivedPasswordKeyMaterial = await argon2DeriveKey(passwordKey, passwordSalt);
        Â  Â  Â  Â  Â  Â  const cryptoPasswordKey = await crypto.subtle.importKey("raw", derivedPasswordKeyMaterial, { name: AES_ALGO }, false, ["encrypt"]);
        Â  Â  Â  Â  Â  Â  const finalEncryptedKey = await crypto.subtle.encrypt({ name: AES_ALGO, iv: passwordIV }, cryptoPasswordKey, new TextEncoder().encode(intermediatePayload));
        Â  Â  Â  Â  Â  Â Â 
        Â  Â  Â  Â  Â  Â  return {
        Â  Â  Â  Â  Â  Â  Â  Â  fileKey: {
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cipherText: Utils.arrayBufferToBase64(finalEncryptedKey),
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  salt: Utils.arrayBufferToBase64(passwordSalt),
        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  iv: Utils.arrayBufferToBase64(passwordIV)
        Â  Â  Â  Â  Â  Â  Â  Â  }
        Â  Â  Â  Â  Â  Â  };
        Â  Â  Â  Â  },
        Â  Â  Â  Â  async reconstructMasterKey(fileKey, passwordKey, visualKeySecret) {
        Â  Â  Â  Â  Â  Â  const passwordSalt = Utils.base64ToUint8Array(fileKey.salt);
        Â  Â  Â  Â  Â  Â  const passwordIV = Utils.base64ToUint8Array(fileKey.iv);
        Â  Â  Â  Â  Â  Â  const passwordCipherText = Utils.base64ToUint8Array(fileKey.cipherText);
        Â  Â  Â  Â  Â  Â Â 
        Â  Â  Â  Â  Â  Â  const derivedPasswordKeyMaterial = await argon2DeriveKey(passwordKey, passwordSalt);
        Â  Â  Â  Â  Â  Â  const cryptoPasswordKey = await crypto.subtle.importKey("raw", derivedPasswordKeyMaterial, { name: AES_ALGO }, false, ["decrypt"]);
        Â  Â  Â  Â  Â  Â  const decryptedIntermediateBuffer = await crypto.subtle.decrypt({ name: AES_ALGO, iv: passwordIV }, cryptoPasswordKey, passwordCipherText);
        Â  Â  Â  Â  Â  Â Â 
        Â  Â  Â  Â  Â  Â  const intermediatePayload = JSON.parse(new TextDecoder().decode(decryptedIntermediateBuffer));

        Â  Â  Â  Â  Â  Â  const visualKeySalt = Utils.base64ToUint8Array(intermediatePayload.salt);
        Â  Â  Â  Â  Â  Â  const visualKeyIV = Utils.base64ToUint8Array(intermediatePayload.iv);
        Â  Â  Â  Â  Â  Â  const visualCipherText = Utils.base64ToUint8Array(intermediatePayload.encryptedKey);
        Â  Â  Â  Â  Â  Â Â 
        Â  Â  Â  Â  Â  Â  const derivedVisualKeyMaterial = await argon2DeriveKey(visualKeySecret, visualKeySalt);
        Â  Â  Â  Â  Â  Â  const cryptoVisualKey = await crypto.subtle.importKey("raw", derivedVisualKeyMaterial, { name: AES_ALGO }, false, ["decrypt"]);
        Â  Â  Â  Â  Â  Â  const masterPrivateKeyBytes = await crypto.subtle.decrypt({ name: AES_ALGO, iv: visualKeyIV }, cryptoVisualKey, visualCipherText);

        Â  Â  Â  Â  Â  Â  return new Uint8Array(masterPrivateKeyBytes);
        Â  Â  Â  Â  }
        Â  Â  };
        })();

        // ===================================================================================
        // UI EVENT HANDLERS
        // ===================================================================================
        const UIHandlers = (() => {
        Â  Â  function updatePuzzleStatus() {
        Â  Â  Â  Â  const { fileKey, passwordKey, visualKey } = state.puzzlePieces;
        Â  Â  Â  Â  let statusHtml = '';
        Â  Â  Â  Â  statusHtml += fileKey ? '<span class="valid">âœ… File Key loaded.</span>\n' : '<span class="invalid">âŒ File Key NOT loaded.</span>\n';
        Â  Â  Â  Â  statusHtml += passwordKey ? '<span class="valid">âœ… Password Key entered.</span>\n' : '<span class="invalid">âŒ Password Key NOT entered.</span>\n';
        Â  Â  Â  Â  statusHtml += visualKey ? '<span class="valid">âœ… Visual Key scanned.</span>\n' : '<span class="invalid">âŒ Visual Key NOT scanned.</span>\n';
        Â  Â  Â  Â Â 
        Â  Â  Â  Â  DOMElements.keyReconstructionStatus.innerHTML = statusHtml;
        Â  Â  Â  Â  DOMElements.reconstructKeyButton.disabled = !(fileKey && passwordKey && visualKey);
        Â  Â  }
        Â  Â Â 
        Â  Â  return {
        Â  Â  Â  Â  async handleGenerateAndExportKeys() {
        Â  Â  Â  Â  Â  Â  const password = prompt("Enter a strong password. This will be your 'Password Key' (Piece 2/3).");
        Â  Â  Â  Â  Â  Â  if (!password) {
        Â  Â  Â  Â  Â  Â  Â  Â  Utils.updateStatus(DOMElements.keyGenStatus, 'âŒ Key generation cancelled. Password is required.', 'error');
        Â  Â  Â  Â  Â  Â  Â  Â  return;
        Â  Â  Â  Â  Â  Â  }
        Â  Â  Â  Â  Â  Â Â 
        Â  Â  Â  Â  Â  Â  Utils.updateStatus(DOMElements.keyGenStatus, 'â³ Generating new Falcon-1024 key pair...', 'info');
        Â  Â  Â  Â  Â  Â  try {
        Â  Â  Â  Â  Â  Â  Â  Â  const keyPair = await BankCrypto.generateNewKeyPair();
        Â  Â  Â  Â  Â  Â  Â  Â  state.masterPublicKey = keyPair.publicKey;
        Â  Â  Â  Â  Â  Â  Â  Â  Utils.log("New Master Key Pair generated.", 'success');
        Â  Â  Â  Â  Â  Â  Â  Â Â 
        Â  Â  Â  Â  Â  Â  Â  Â  Utils.updateStatus(DOMElements.keyGenStatus, 'â³ Creating puzzle pieces and encrypting private key (this may take a moment)...', 'info');

        Â  Â  Â  Â  Â  Â  Â  Â  const visualKeySecret = crypto.randomUUID();
        Â  Â  Â  Â  Â  Â  Â  Â  const { fileKey } = await BankCrypto.encryptMasterKey(keyPair.privateKey, password, visualKeySecret);
        Â  Â  Â  Â  Â  Â  Â  Â Â 
        Â  Â  Â  Â  Â  Â  Â  Â  const publicKeyB64 = Utils.arrayBufferToBase64(keyPair.publicKey);
        Â  Â  Â  Â  Â  Â  Â  Â  Utils.downloadFile(JSON.stringify({ masterPublicKey: publicKeyB64 }, null, 2), 'Sadat-MASTER-PUBLIC-KEY.json', 'application/json');
        Â  Â  Â  Â  Â  Â  Â  Â  Utils.downloadFile(JSON.stringify(fileKey, null, 2), 'Sadat-FILE-KEY.json', 'application/json');
        Â  Â  Â  Â  Â  Â  Â  Â Â 
        Â  Â  Â  Â  Â  Â  Â  Â  DOMElements.qrModalTitle.innerText = "Your Visual Key (Piece 3/3)";
        Â  Â  Â  Â  Â  Â  Â  Â  DOMElements.qrDisplay.innerHTML = '';
        Â  Â  Â  Â  Â  Â  Â  Â  QRCode.toCanvas(DOMElements.qrDisplay.appendChild(document.createElement('canvas')), visualKeySecret, { width: 256, errorCorrectionLevel: 'H' });
        Â  Â  Â  Â  Â  Â  Â  Â  DOMElements.qrModal.style.display = 'flex';
        Â  Â  Â  Â  Â  Â  Â  Â Â 
        Â  Â  Â  Â  Â  Â  Â  Â  Utils.updateStatus(DOMElements.keyGenStatus, `âœ… New key pair generated!
        Â  Â  Â  Â  Â  Â  Â  Â  - MASTER-PUBLIC-KEY.json (share this)
        Â  Â  Â  Â  Â  Â  Â  Â  - FILE-KEY.json (keep this on a USB)
        Â  Â  Â  Â  Â  Â  Â  Â  - Password (memorize this)
        Â  Â  Â  Â  Â  Â  Â  Â  - Visual Key QR (print and secure this)
        Â  Â  Â  Â  Â  Â  Â  Â  The new Public Key is now active for validation.`, 'success');

        Â  Â  Â  Â  Â  Â  } catch (e) {
        Â  Â  Â  Â  Â  Â  Â  Â  Utils.log(`Key generation failed: ${e.message}`, 'error');
        Â  Â  Â  Â  Â  Â  Â  Â  Utils.updateStatus(DOMElements.keyGenStatus, `âŒ Failed to generate keys: ${e.message}`, 'error');
        Â  Â  Â  Â  Â  Â  }
        Â  Â  Â  Â  },
        Â  Â  Â  Â  handleImportPublicKey: async (event) => { const file = event.target.files[0]; if (!file) return; try { const data = JSON.parse(await file.text()); if (!data.masterPublicKey) throw new Error("Invalid public key file format."); state.masterPublicKey = Utils.base64ToUint8Array(data.masterPublicKey); Utils.updateStatus(DOMElements.keyGenStatus, 'âœ… Public key imported. Ready to validate banknotes.', 'success'); DOMElements.validatorInput.disabled = false; } catch (error) { Utils.updateStatus(DOMElements.keyGenStatus, `âŒ Error importing public key: ${error.message}`, 'error'); } event.target.value = ''; },
        Â  Â  Â  Â  handleFileKeyInput: async (event) => {
        Â  Â  Â  Â  Â  Â  const file = event.target.files[0];
        Â  Â  Â  Â  Â  Â  if (!file) return;
        Â  Â  Â  Â  Â  Â  try {
        Â  Â  Â  Â  Â  Â  Â  Â  state.puzzlePieces.fileKey = JSON.parse(await file.text());
        Â  Â  Â  Â  Â  Â  Â  Â  Utils.log("File Key loaded.", 'success');
        Â  Â  Â  Â  Â  Â  } catch(e) {
        Â  Â  Â  Â  Â  Â  Â  Â  state.puzzlePieces.fileKey = null;
        Â  Â  Â  Â  Â  Â  Â  Â  Utils.log(`Failed to load File Key: ${e.message}`, 'error');
        Â  Â  Â  Â  Â  Â  }
        Â  Â  Â  Â  Â  Â  updatePuzzleStatus();
        Â  Â  Â  Â  Â  Â  event.target.value = '';
        Â  Â  Â  Â  },
        Â  Â  Â  Â  handlePasswordKeyInput: (event) => {
        Â  Â  Â  Â  Â  Â  state.puzzlePieces.passwordKey = event.target.value || null;
        Â  Â  Â  Â  Â  Â  updatePuzzleStatus();
        Â  Â  Â  Â  },
        Â  Â  Â  Â  handleVisualKeyScan: () => { let stream; let animationFrameId; function tick() { if (stream && DOMElements.cameraVideo.readyState === DOMElements.cameraVideo.HAVE_ENOUGH_DATA) { const canvas = document.createElement('canvas'); canvas.width = DOMElements.cameraVideo.videoWidth; canvas.height = DOMElements.cameraVideo.videoHeight; const ctx = canvas.getContext('2d'); ctx.drawImage(DOMElements.cameraVideo, 0, 0, canvas.width, canvas.height); const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height); const code = jsQR(imageData.data, imageData.width, imageData.height); if (code) { state.puzzlePieces.visualKey = code.data; Utils.log("Visual Key scanned successfully.", 'success'); stopScan(); updatePuzzleStatus(); } } animationFrameId = requestAnimationFrame(tick); } function stopScan() { cancelAnimationFrame(animationFrameId); DOMElements.cameraModal.style.display = 'none'; if (stream) { stream.getTracks().forEach(track => track.stop()); } } DOMElements.cancelScanButton.onclick = stopScan; navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } }).then(s => { stream = s; DOMElements.cameraVideo.srcObject = stream; DOMElements.cameraModal.style.display = 'flex'; DOMElements.cameraVideo.play(); requestAnimationFrame(tick); }).catch(err => { alert("Could not access camera."); console.error("Camera error:", err); }); },
        Â  Â  Â  Â  handleReconstructKey: async () => { const { fileKey, passwordKey, visualKey } = state.puzzlePieces; if (!fileKey || !passwordKey || !visualKey) { Utils.updateStatus(DOMElements.keyReconstructionStatus, "âŒ All three puzzle pieces are required.", 'error'); return; } Utils.updateStatus(DOMElements.keyReconstructionStatus, "â³ Reconstructing Master Private Key...", 'info'); try { state.masterPrivateKey = await BankCrypto.reconstructMasterKey(fileKey, passwordKey, visualKey); Utils.updateStatus(DOMElements.keyReconstructionStatus, "âœ… Master Private Key ACTIVE. You can now create banknotes.", 'success'); DOMElements.createNoteButton.disabled = false; } catch (error) { console.error(error); Utils.updateStatus(DOMElements.keyReconstructionStatus, "âŒ Failed to reconstruct key. Check that all pieces are correct.", 'error'); state.masterPrivateKey = null; DOMElements.createNoteButton.disabled = true; } }
        Â  Â  };
        })();

        // ===================================================================================
        // BANKNOTE LOGIC
        // ===================================================================================
        const BanknoteLogic = (() => {
            const getStandardizedDataForSigning = (noteData, forMasterSignature = false) => {
                let dataToSign;
                if (forMasterSignature) {
                    dataToSign = { ephemeralPublicKey: noteData.ephemeralPublicKey, signatureOne: noteData.signatureOne };
                } else {
                    dataToSign = { amount: noteData.amount, serial: noteData.serial, timestamp: noteData.timestamp };
                }
                return JSON.stringify(dataToSign, Object.keys(dataToSign).sort());
            };

            const createQrPayload = (noteData) => {
                const parts = [
                    noteData.amount,
                    noteData.serial,
                    noteData.timestamp,
                    noteData.ephemeralPublicKey,
                    noteData.signatureOne,
                    noteData.signatureTwo
                ];
                return parts.join('|');
            };

            const parseQrPayload = (payload) => {
                const parts = payload.split('|');
                if (parts.length !== 6) throw new Error("Invalid QR payload format.");
                return {
                    amount: parseInt(parts[0], 10),
                    serial: parts[1],
                    timestamp: parseInt(parts[2], 10),
                    ephemeralPublicKey: parts[3],
                    signatureOne: parts[4],
                    signatureTwo: parts[5]
                };
            };

            const createNoteData = async (amount) => {
                if (!state.masterPrivateKey) {
                    throw new Error("Master Private Key is not active.");
                }

                const ephemeralKeyPair = await BankCrypto.generateNewKeyPair();
                const ephemeralPublicKeyB64 = Utils.arrayBufferToBase64(ephemeralKeyPair.publicKey);
                
                const noteData = {
                    amount: parseInt(amount) || 0,
                    serial: Date.now().toString().slice(-8) + Math.random().toString(16).substring(2, 6),
                    timestamp: Date.now(),
                    ephemeralPublicKey: ephemeralPublicKeyB64
                };

                const dataForSigOne = getStandardizedDataForSigning(noteData, false);
                const sigOneBytes = await BankCrypto.signData(dataForSigOne, ephemeralKeyPair.privateKey);
                noteData.signatureOne = Utils.arrayBufferToBase64(sigOneBytes);

                const dataForSigTwo = getStandardizedDataForSigning(noteData, true);
                const sigTwoBytes = await BankCrypto.signData(dataForSigTwo, state.masterPrivateKey);
                noteData.signatureTwo = Utils.arrayBufferToBase64(sigTwoBytes);

                return noteData;
            };

            return {
                handleCreateAndSignNotes: async () => {
                    if (!state.masterPrivateKey) {
                        alert("Master Private Key is not active. Please reconstruct it first.");
                        return;
                    }
                    const amount = DOMElements.amountInput.value;
                    const quantity = parseInt(DOMElements.quantityInput.value) || 1;
                    
                    const statusTarget = DOMElements.keyReconstructionStatus; // Use the reconstruction status box for updates
                    Utils.updateStatus(statusTarget, `â³ Creating and signing ${quantity} banknote(s)...`, 'info');

                    try {
                        const isBatch = quantity > 1;
                        const dirHandle = isBatch && window.showDirectoryPicker ? await window.showDirectoryPicker().catch(() => null) : null;

                        if (isBatch && !dirHandle) {
                            alert("Directory picker was cancelled or is not supported by your browser. Only one note will be downloaded.");
                        }

                        const offscreenCanvas = document.createElement('canvas');
                        offscreenCanvas.width = 1350;
                        offscreenCanvas.height = 750;
                        
                        for (let i = 0; i < quantity; i++) {
                            Utils.updateStatus(statusTarget, `â³ Creating note ${i + 1} of ${quantity}...`, 'info');
                            const noteData = await createNoteData(amount);
                            
                            // Draw to offscreen canvas for saving
                            await BanknoteDrawer.drawNoteOnCanvas(offscreenCanvas, noteData);
                            const blob = await new Promise(resolve => offscreenCanvas.toBlob(resolve, 'image/png'));
                            const filename = `SADAT-NOTE-${noteData.serial}.png`;

                            if (isBatch && dirHandle) {
                                const fileHandle = await dirHandle.getFileHandle(filename, { create: true });
                                const writable = await fileHandle.createWritable();
                                await writable.write(blob);
                                await writable.close();
                            } else {
                                // Fallback for single download or no directory picker support
                                Utils.downloadFile(blob, filename, 'image/png');
                            }
                            
                            // Draw the last note to the visible canvas
                            if (i === quantity - 1) {
                                await BanknoteDrawer.drawNoteOnCanvas(DOMElements.noteCanvas, noteData);
                            }
                        }

                        Utils.updateStatus(statusTarget, `âœ… Successfully saved ${quantity} banknote(s).`, 'success');

                    } catch (error) {
                        Utils.updateStatus(statusTarget, `âŒ Error: ${error.message}`, 'error');
                        console.error(error);
                    } finally {
                        // Clear the sensitive key from memory after use
                        state.masterPrivateKey = null;
                        DOMElements.createNoteButton.disabled = true;
                        setTimeout(() => {
                           if(DOMElements.keyReconstructionStatus.querySelector('.success')) {
                               Utils.updateStatus(DOMElements.keyReconstructionStatus, "âš ï¸ For your security, the private key has been cleared from memory. Re-activate to create more notes.", 'warning');
                           }
                        }, 2000);
                        Utils.log("Master private key cleared from memory for security.", 'warning');
                    }
                },
                handleFileSelectForValidation: async (event) => {
                    const file = event.target.files[0];
                    if (!file) return;
                    if (!state.masterPublicKey) {
                        alert("No Master Public Key loaded. Please load the public key first.");
                        return;
                    }

                    const resultDiv = DOMElements.validationResult;
                    Utils.updateStatus(resultDiv, 'â³ Reading banknote image...', 'info');

                    const img = new Image();
                    img.onload = async () => {
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = 1350;
                        tempCanvas.height = 750;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
                        
                        let resultHTML = '';
                        
                        Utils.updateStatus(resultDiv, '1. Scanning for QR Code...', 'info');
                        const qrRegion = { x: 800, y: 210, width: 420, height: 420 };
                        const imageData = tempCtx.getImageData(qrRegion.x, qrRegion.y, qrRegion.width, qrRegion.height);
                        const code = jsQR(imageData.data, imageData.width, imageData.height);

                        if (!code || !code.data) {
                            Utils.updateStatus(resultDiv, 'âŒ FATAL ERROR: QR Code not found or unreadable.', 'error');
                            return;
                        }
                        resultHTML += '<span class="valid">âœ… 1. QR Code Found.</span>\n';
                        resultDiv.innerHTML = resultHTML;

                        try {
                            const parsedData = parseQrPayload(code.data);

                            resultHTML += '2. Verifying Ephemeral Signature (Sig 1)...';
                            resultDiv.innerHTML = resultHTML;
                            
                            const dataForSigOne = getStandardizedDataForSigning(parsedData, false);
                            const isSigOneValid = await BankCrypto.verifySignature(
                                Utils.base64ToUint8Array(parsedData.signatureOne),
                                dataForSigOne,
                                Utils.base64ToUint8Array(parsedData.ephemeralPublicKey)
                            );

                            if (!isSigOneValid) {
                                resultHTML += '\n<span class="invalid">âŒ FATAL ERROR: Signature 1 is invalid. Note is a forgery.</span>\n<hr><span>âŒ VERDICT: FORGERY</span>';
                                resultDiv.innerHTML = resultHTML;
                                return;
                            }
                            resultHTML += '<span class="valid">âœ… OK</span>\n';
                            
                            resultHTML += '3. Verifying Guardian Signature (Sig 2)...';
                            resultDiv.innerHTML = resultHTML;

                            const dataForSigTwo = getStandardizedDataForSigning(parsedData, true);
                            const isSigTwoValid = await BankCrypto.verifySignature(
                                Utils.base64ToUint8Array(parsedData.signatureTwo),
                                dataForSigTwo,
                                state.masterPublicKey
                            );

                            if (!isSigTwoValid) {
                                resultHTML += '\n<span class="invalid">âŒ FATAL ERROR: Signature 2 is invalid. Note was not signed by the loaded Master Key.</span>\n<hr><span>âŒ VERDICT: FORGERY / MISMATCHED KEY</span>';
                                resultDiv.innerHTML = resultHTML;
                                return;
                            }
                            resultHTML += '<span class="valid">âœ… OK</span>\n<hr><span style="font-size:14px;font-weight:600;" class="valid">âœ… VERDICT: BANKNOTE IS AUTHENTIC.</span>';
                            resultDiv.innerHTML = resultHTML;

                        } catch (e) {
                             Utils.updateStatus(resultDiv, `âŒ Validation Error: ${e.message}`, 'error');
                        }
                    };
                    img.src = URL.createObjectURL(file);
                    event.target.value = '';
                }
            }
        })();
        
        const BanknoteDrawer = (() => {
            const H = (text, index, min, max) => min + (parseInt(text.substring(index, index + 2), 16) % (max - min + 1));

            function drawKochGuilloche(ctx, hash, w, h) { ctx.save();ctx.translate(w/2,h/2);const s=w/1350,it=H(hash,2,2,4),sz=w*(H(hash,4,10,20)/100),aO=(H(hash,6,0,360)/360)*Math.PI*2,nL=H(hash,8,3,6),hO=H(hash,10,0,360);function d(x1,y1,x2,y2,l){if(l===0){ctx.lineTo(x2,y2);return}const dx=x2-x1,dy=y2-y1,di=Math.sqrt(dx*dx+dy*dy),ux=dx/di,uy=dy/di,p1x=x1+ux*di/3,p1y=y1+uy*di/3,p2x=x1+ux*di*2/3,p2y=y1+uy*di*2/3,p3x=p1x+ux*di/6-uy*di*Math.sqrt(3)/6,p3y=p1y+uy*di/6+ux*di*Math.sqrt(3)/6;d(x1,y1,p1x,p1y,l-1);d(p1x,p1y,p3x,p3y,l-1);d(p3x,p3y,p2x,p2y,l-1);d(p2x,p2y,x2,y2,l-1)}ctx.lineWidth=1*s;ctx.lineJoin='bevel';ctx.lineCap='round';for(let i=0;i<nL;i++){const hu=(hO+i*(360/nL))%360;ctx.strokeStyle=`hsla(${hu},70%,60%,0.15)`;const lA=(i/nL)*Math.PI*2+aO,x1=Math.cos(lA)*sz,y1=Math.sin(lA)*sz,x2=Math.cos(lA+Math.PI)*sz,y2=Math.sin(lA+Math.PI)*sz;ctx.beginPath();ctx.moveTo(x1,y1);d(x1,y1,x2,y2,it);ctx.stroke()}ctx.restore() }
            function drawWatermark(ctx, hash, w, h) { ctx.save();ctx.translate(w/2,h/2);const s=w/1350,nS=H(hash,16,3,6),sR=w*(H(hash,18,10,25)/100)*s,hu=H(hash,20,0,360);ctx.strokeStyle=`hsla(${hu},50%,80%,0.05)`;ctx.lineWidth=4*s;for(let i=0;i<nS;i++){ctx.beginPath();const sA=(i/nS)*Math.PI*2+H(hash,22,0,100)/100,eA=sA+H(hash,24,6,12)*Math.PI;for(let t=sA;t<eA;t+=0.05){const r=sR*(t-sA)/(eA-sA),x=r*Math.cos(t),y=r*Math.sin(t);if(t===sA)ctx.moveTo(x,y);else ctx.lineTo(x,y)}ctx.stroke()}ctx.restore() }
            function drawNoisePattern(ctx, hash, w, h) { ctx.save(); for (let i=0; i<20000; i++) { const x=Math.random()*w, y=Math.random()*h, o=Math.random()*0.15, hue=H(hash,(i%30)+4,0,360); ctx.fillStyle=`hsla(${hue},50%,80%,${o})`; ctx.fillRect(x,y,1,1) } ctx.restore() }
            
            return {
                drawNoteOnCanvas: (canvas, noteData, width = 1350, height = 750) => {
                    return new Promise(async (resolve, reject) => {
                        if (!noteData) return reject("No note data provided.");
                        
                        const ctx = canvas.getContext("2d");
                        const { amount, serial, signatureTwo } = noteData;
                        const w = width, h = height, scale = w / 1350;
                        const visualHash = shake256(signatureTwo, 256);

                        const bgGradient = ctx.createLinearGradient(0, 0, 0, h);
                        const baseHue = H(visualHash, 0, 0, 360);
                        bgGradient.addColorStop(0, `hsl(${baseHue}, 50%, 6%)`);
                        bgGradient.addColorStop(1, `hsl(${baseHue}, 40%, 4%)`);
                        ctx.fillStyle = bgGradient;
                        ctx.fillRect(0, 0, w, h);
                        
                        drawWatermark(ctx, visualHash, w, h);
                        drawKochGuilloche(ctx, visualHash, w, h);
                        drawNoisePattern(ctx, visualHash, w, h);

                        ctx.shadowColor="rgba(0,0,0,0.7)"; ctx.shadowBlur=8*scale; ctx.shadowOffsetX=2*scale; ctx.shadowOffsetY=2*scale;
                        ctx.fillStyle="#EAEAEA"; ctx.font=`bold ${70*scale}px 'Roboto Mono'`; ctx.textAlign='left';
                        ctx.fillText(`SN: ${serial}`,150*scale,160*scale); 
                        ctx.font=`bold ${150*scale}px 'Roboto Mono'`; ctx.textAlign="right";
                        ctx.shadowBlur=12*scale; ctx.shadowOffsetX=4*scale; ctx.shadowOffsetY=4*scale;
                        ctx.fillText(amount.toString(),w-(120*scale),190*scale); ctx.shadowColor="transparent";

                        const qrCanvas = document.createElement("canvas");
                        const qrSize = 380 * scale;
                        const qrPayload = BanknoteLogic.createQrPayload(noteData);

                        QRCode.toCanvas(qrCanvas, qrPayload, { 
                            width: qrSize, 
                            errorCorrectionLevel: 'M', 
                            color: { dark: '#000000', light: '#FFFFFF' } 
                        }, (err) => {
                            if (err) { reject(err); return; }
                            const qrX = w - (150 * scale) - qrSize;
                            const qrY = h - (520 * scale);
                            ctx.fillStyle = 'white';
                            ctx.fillRect(qrX - (20 * scale), qrY - (20 * scale), qrSize + (40 * scale), qrSize + (40 * scale));
                            ctx.drawImage(qrCanvas, qrX, qrY, qrSize, qrSize);

                            ctx.font=`${30*scale}px 'Roboto Mono'`; ctx.fillStyle="rgba(255,255,255,0.4)"; ctx.textAlign="center";
                            ctx.fillText("Dual-Signed by Sadat Guardian Authority (Falcon-1024)", w/2, h-60*scale);
                            resolve();
                        });
                    });
                }
            };
        })();

        // ===================================================================================
        // APPLICATION INITIALIZATION
        // ===================================================================================
        async function main() {
        Â  Â  Utils.updateStatus(DOMElements.keyGenStatus, 'â³ Loading Falcon-1024 Crypto Module...', 'info');
        Â  Â  try {
        Â  Â  Â  Â  state.falconApi = await pqcSignFalcon1024();
        Â  Â  Â  Â  Utils.updateStatus(DOMElements.keyGenStatus, 'âœ… Modules loaded. Please generate or import keys to begin.', 'success');
        Â  Â  Â  Â  Utils.log("All cryptographic modules initialized successfully.", 'success');
        Â  Â  } catch (e) {
        Â  Â  Â  Â  Utils.log(`Critical Error: Could not load required modules: ${e.message}`, 'error');
        Â  Â  Â  Â  Utils.updateStatus(DOMElements.keyGenStatus, `âŒ Critical Error: Could not load modules. See console for details.`, 'error');
        Â  Â  Â  Â  alert("Error: Failed to load a required cryptographic module. The application cannot run.");
        Â  Â  Â  Â  return;
        Â  Â  }
        Â  Â Â 
        Â  Â  // Attach Event Listeners
        Â  Â  DOMElements.generateKeysButton.addEventListener('click', UIHandlers.handleGenerateAndExportKeys);
            DOMElements.importPublicKey.addEventListener('change', UIHandlers.handleImportPublicKey);
            DOMElements.fileKeyInput.addEventListener('change', UIHandlers.handleFileKeyInput);
            DOMElements.passwordKeyInput.addEventListener('input', UIHandlers.handlePasswordKeyInput);
            DOMElements.visualKeyButton.addEventListener('click', UIHandlers.handleVisualKeyScan);
            DOMElements.reconstructKeyButton.addEventListener('click', UIHandlers.handleReconstructKey);
            DOMElements.createNoteButton.addEventListener('click', BanknoteLogic.handleCreateAndSignNotes);
            DOMElements.validatorInput.addEventListener('change', BanknoteLogic.handleFileSelectForValidation);
        }

        main();
    </script>
</body>
</html>
