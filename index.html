

<!doctype html>
<html lang="fa" dir="rtl">
<head>
<meta charset="utf-8" />
<title>Sadat â€” Split JAB & QR Banknote (Prototype)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:Tahoma, Arial; background:#0f0f18;color:#eaeaf2;padding:18px}
  .note{width:1000px;margin:10px auto;background:#11121a;border-radius:12px;padding:18px;box-shadow:0 8px 40px rgba(0,0,0,.6)}
  canvas{width:100%;border-radius:8px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-top:12px}
  button,input{padding:10px 12px;border-radius:8px;border:1px solid rgba(124,77,255,.15);background:#151624;color:#fff}
  .status{font-family:monospace;background:#0b0b11;padding:10px;border-radius:8px;margin-top:10px}
</style>
</head>
<body>
<h2 style="text-align:center">Sadat â€” Split JAB (Ø±Ø§Ø³Øª) & QR (Ú†Ù¾) â€” Self-contained</h2>
<div class="note">
  <canvas id="canvas" width="1350" height="750"></canvas>
  <div class="controls">
    <input id="amount" placeholder="Ù…Ø¨Ù„Øº" value="50000">
    <input id="serial" placeholder="Ø³Ø±ÛŒØ§Ù„" value="SN123456">
    <button id="gen">ğŸ” Ø³Ø§Ø®Øª Ø§Ø³Ú©Ù†Ø§Ø³</button>
    <button id="validate">ğŸ” Ø¨Ø±Ø±Ø³ÛŒ Ø§Ø² ØªØµÙˆÛŒØ±</button>
    <button id="download">ğŸ’¾ Ø¯Ø§Ù†Ù„ÙˆØ¯ PNG</button>
  </div>
  <div id="status" class="status">ÙˆØ¶Ø¹ÛŒØª: Ø¢Ù…Ø§Ø¯Ù‡</div>
</div>

<!-- Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡â€ŒÙ‡Ø§ÛŒ Ú©ÙˆÚ†Ú©: pako Ø¨Ø±Ø§ÛŒ ÙØ´Ø±Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ùˆ jabcode (ÙØ±Ø¶ Ù…ÙˆØ¬ÙˆØ¯) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
<!-- ÙØ±Ø¶: jabcodeJSLib.min.js Ùˆ pqcSignFalcon1024.min.js Ù…Ø´Ø§Ø¨Ù‡ ÙØ§ÛŒÙ„ Ù‚Ø¨Ù„ÛŒ Ø¯Ø± ÙÙˆÙ„Ø¯Ø± Ù‡Ø³ØªÙ†Ø¯ -->
<script type="module">
import JabcodeJSInterface from './jabcodeJSLib.min.js';
import pqcSignFalcon1024 from './pqc-sign-falcon-1024.min.js';

const jab = new JabcodeJSInterface();
let falconApi = null;

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const status = document.getElementById('status');

function updateStatus(t){ status.textContent = 'ÙˆØ¶Ø¹ÛŒØª: ' + t; }

// --- Utility helpers ---
const U = {
  toUtf8: s => new TextEncoder().encode(s),
  fromUtf8: b => new TextDecoder().decode(b),
  hex: b=>Array.from(b).map(x=>('0'+x.toString(16)).slice(-2)).join(''),
  rndBytes: n => { const a=new Uint8Array(n); crypto.getRandomValues(a); return a; },
  xor: (a,b)=>{ const r=new Uint8Array(a.length); for(let i=0;i<a.length;i++) r[i]=a[i]^b[i]; return r }
}

// SHA-256 helper
async function sha256(buf){ const h = await crypto.subtle.digest('SHA-256', buf); return new Uint8Array(h); }

// AES-GCM encrypt/decrypt (key is raw bytes)
async function aesGcmEncrypt(keyRaw, plaintext, aad=new Uint8Array()){ const key = await crypto.subtle.importKey('raw', keyRaw,{name:'AES-GCM'},false,['encrypt']); const iv = U.rndBytes(12); const ct = await crypto.subtle.encrypt({name:'AES-GCM',iv,additionalData:aad}, key, plaintext); return {iv:new Uint8Array(iv), ct:new Uint8Array(ct)} }
async function aesGcmDecrypt(keyRaw, iv, ct, aad=new Uint8Array()){ const key = await crypto.subtle.importKey('raw', keyRaw,{name:'AES-GCM'},false,['decrypt']); const pt = await crypto.subtle.decrypt({name:'AES-GCM',iv,additionalData:aad}, key, ct); return new Uint8Array(pt) }

// compress with pako
function compress(dataUint8){ return pako.deflate(dataUint8); }
function decompress(dataUint8){ return pako.inflate(dataUint8); }

// canonicalize printed fields (amount, serial, verificationKey (printed))
function canonicalPrinted(amount, serial, printedKey){ // deterministic small binary
  const enc = new TextEncoder();
  const a = new Uint32Array([Number(amount) || 0]);
  const s = enc.encode(serial.padEnd(12, ' ')).slice(0,12);
  const k = enc.encode(printedKey.padEnd(16,' ')).slice(0,16);
  const buf = new Uint8Array(4 + 12 + 16);
  buf.set(new Uint8Array(a.buffer), 0); buf.set(s,4); buf.set(k,16);
  return buf;
}

// build full sensitive payload (fields that cannot be printed) â€” in this prototype we simulate
function buildSensitivePayload(extra){ // extra: object
  // Example: includes metadata, two large public keys, issuer notes, expiry, nonce
  const json = JSON.stringify(extra);
  return U.toUtf8(json);
}

// --- High-level scheme ---
// 1) payload_full = canonical_printed || sensitive_payload
// 2) compress payload_full
// 3) generate random symmetric key K (32B), encrypt compressed with AES-GCM
// 4) split K into two parts K1,K2 with XOR (K = K1 XOR K2). Put K1 inside QR (left), K2 inside JAB (right)
// 5) compute H = SHA256(compressed_plaintext) and sign H with Falcon (sigF)
// 6) Put in QR: {serial, amount, H, K1, sigF, small meta}
//    Put in JAB: {serial, amount, H, K2, optional sphincs_sig or cert_id, small meta}
// 7) To validate need both QR and JAB: combine K1^K2 -> K, decrypt AES-> get compressed payload, verify H, verify signature(s)

// This keeps printed visible data minimal (amount,serial,printedKey). All other sensitive info lives in encrypted payload inside both codes (but both halves required).

// --- create and render note ---
async function drawNote(amount, serial){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // background
  ctx.fillStyle='#0b0b10'; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle='#ddd'; ctx.font='bold 80px monospace'; ctx.textAlign='left'; ctx.fillText(serial,120,150);
  ctx.font='bold 160px monospace'; ctx.textAlign='right'; ctx.fillText(amount.toString(), canvas.width-120,180);
}

async function generateBanknote(){
  updateStatus('Ø¯Ø± Ø­Ø§Ù„ Ø§ÛŒØ¬Ø§Ø¯ Ú©Ù„ÛŒØ¯Ù‡Ø§ ...');
  // prepare printed values
  const amount = document.getElementById('amount').value;
  const serial = document.getElementById('serial').value;
  const printedKey = 'VERIFKEY01'; // small printed verification key

  // sensitive payload: two large keys + metadata (simulated)
  const sensitive = buildSensitivePayload({issuer:'SadatBank', expiry:'2030-12-31', largeKeyA: 'A'.repeat(1700), largeKeyB: 'B'.repeat(1200), note:'Internal data example'});

  // canonical printed part
  const printedCanon = canonicalPrinted(amount, serial, printedKey);

  // full plaintext that must be protected
  const fullPlain = new Uint8Array(printedCanon.length + sensitive.length);
  fullPlain.set(printedCanon,0); fullPlain.set(sensitive, printedCanon.length);

  // compress
  const compressed = compress(fullPlain);

  // symmetric key
  const K = U.rndBytes(32);
  // encrypt compressed with AES-GCM, AAD = SHA256(printedCanon) to bind to printed fields
  const aad = await sha256(printedCanon.buffer);
  const enc = await aesGcmEncrypt(K, compressed, aad);

  // split key K into K1 and K2 via XOR
  const K1 = U.rndBytes(32);
  const K2 = U.xor(K, K1);

  // compute H on compressed plaintext (to sign)
  const H = await sha256(compressed.buffer);

  // sign H with Falcon (if available)
  updateStatus('Ø¯Ø± Ø­Ø§Ù„ ØªÙˆÙ„ÛŒØ¯ Ø§Ù…Ø¶Ø§ (Falcon)...');
  const dataHex = U.hex(H);
  // Falon API expects hash-bytes input in original code; reuse same helper
  let sigF = new Uint8Array(0);
  if(falconApi){ try{ sigF = await falconApi.sign(H, stateMasterPrivateKey); } catch(e){ console.warn('Falcon sign failed',e); } }

  // Prepare QR payload (LEFT)
  const qrObj = {
    serial, amount, H: U.hex(H), k1: U.hex(K1), sigF: U.hex(sigF), meta:{v:1, side:'left'}
  };
  // Prepare JAB payload (RIGHT)
  // Ideally SPHINCS+ signature placed here (large). For prototype we include cert_id placeholder.
  const jabObj = {
    serial, amount, H: U.hex(H), k2: U.hex(K2), sphincs_cert_id: 'SPH_CERT_2025_v1', meta:{v:1, side:'right'}
  };

  // encode images
  updateStatus('Ø¯Ø± Ø­Ø§Ù„ Ø§ÛŒØ¬Ø§Ø¯ JAB Ùˆ QR ...');
  const qrImgBase64 = await (async ()=>{ try{ return jab.encode_message(JSON.stringify(qrObj)); }catch(e){ console.error(e); return null } })();
  const jabImgBase64 = await (async ()=>{ try{ return jab.encode_message(JSON.stringify(jabObj)); }catch(e){ console.error(e); return null } })();

  // draw final note: left QR, right JAB, printed text
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // bg
  ctx.fillStyle='#050512'; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle='#fff'; ctx.font='bold 72px monospace'; ctx.textAlign='left'; ctx.fillText(serial,120,160);
  ctx.font='bold 150px monospace'; ctx.textAlign='right'; ctx.fillText(amount.toString(), canvas.width-120,190);

  // draw qr on left
  if(qrImgBase64){ const imgQ=new Image(); imgQ.onload=()=>{ ctx.fillStyle='#fff'; ctx.fillRect(80,260,380,380); ctx.drawImage(imgQ,80,260,380,380); // draw jab after
    if(jabImgBase64){ const imgJ=new Image(); imgJ.onload=()=>{ ctx.fillStyle='#fff'; ctx.fillRect(canvas.width-460,260,380,380); ctx.drawImage(imgJ,canvas.width-460,260,380,380); updateStatus('Ø§Ø³Ú©Ù†Ø§Ø³ Ø³Ø§Ø®ØªÙ‡ Ø´Ø¯ â€” Ù‡Ø± Ø¯Ùˆ Ú©ÙØ¯ Ú†Ù¾/Ø±Ø§Ø³Øª Ù…ÙˆØ¬ÙˆØ¯ Ø§Ø³Øª.'); }; imgJ.src=jabImgBase64; } }; imgQ.src=qrImgBase64; }

  // store for validation later on window
  window._currentNote = { qrObj, jabObj, enc, aad };
}

// validate function: receives image containing both codes -> decode both -> reconstruct K -> decrypt
async function validateFromCanvasImage(img){ updateStatus('Ø´Ø±ÙˆØ¹ Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ ...');
  // decode regions like earlier sample -> here we assume we can decode left and right images separately
  // For prototype: we read objects from window._currentNote
  if(!window._currentNote){ updateStatus('Ù†Ù…ÙˆÙ†Ù‡ Ø³Ø§Ø®Øª Ù†Ø´Ø¯Ù‡ ÛŒØ§ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø¯Ø± ØµÙØ­Ù‡ Ù…ÙˆØ¬ÙˆØ¯ Ù†ÛŒØ³Øª. Ø¨Ø±Ø§ÛŒ ØªØ³Øª Ø§Ø¨ØªØ¯Ø§ "Ø³Ø§Ø®Øª Ø§Ø³Ú©Ù†Ø§Ø³" Ø±Ø§ Ø¨Ø²Ù†ÛŒØ¯.'); return; }
  const { qrObj, jabObj, enc, aad } = window._currentNote;
  // reconstruct K
  const K1 = new Uint8Array(Array.from(qrObj.k1.match(/.{1,2}/g)).map(h=>parseInt(h,16)));
  const K2 = new Uint8Array(Array.from(jabObj.k2.match(/.{1,2}/g)).map(h=>parseInt(h,16)));
  const K = U.xor(K1,K2);
  try{
    const ptCompressed = await aesGcmDecrypt(K, enc.iv, enc.ct, aad);
    const pt = decompress(ptCompressed);
    const H = await sha256(ptCompressed.buffer);
    if(U.hex(H) !== qrObj.H || U.hex(H) !== jabObj.H){ updateStatus('Ù‡Ø´ ØªØ·Ø§Ø¨Ù‚ Ù†Ø¯Ø§Ø±Ø¯ â€” Ø¯Ø§Ø¯Ù‡ Ú†Ø§Ù¾ÛŒ ÛŒØ§ Ú©Ø¯Ù‡Ø§ Ø¯Ø³ØªÚ©Ø§Ø±ÛŒ Ø´Ø¯Ù‡.'); return; }
    updateStatus('âœ… Ù…ÙˆÙÙ‚: Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ù…Ø®ÙÛŒ Ø¨Ø§ Ù‡Ù… Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ùˆ Ù‡Ø´ Ø¨Ø±Ø§Ø¨Ø± Ø§Ø³Øª. Ø§Ù…Ø¶Ø§Ù‡Ø§ (Falcon/SPHINCS) Ø¨Ø§ÛŒØ¯ Ø¬Ø¯Ø§Ú¯Ø§Ù†Ù‡ Ú†Ú© Ø´ÙˆÙ†Ø¯.');
  }catch(e){ updateStatus('âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ ÛŒØ§ Ø±Ù…Ø²Ú¯Ø´Ø§ÛŒÛŒ â€” Ù…Ù…Ú©Ù† Ø§Ø³Øª Ú©Ø¯Ù‡Ø§ Ù†Ø§Ù‚Øµ Ø¨Ø§Ø´Ù†Ø¯ ÛŒØ§ Ú©Ù„ÛŒØ¯Ù‡Ø§ Ø§Ø´ØªØ¨Ø§Ù‡ Ø¨Ø§Ø´Ù†Ø¯.'); console.error(e); }
}

// --- init falcon (if available) and event handlers ---
let stateMasterPrivateKey = null; // in real system private key is secret in HSM; here we simulate
(async ()=>{
  try{ falconApi = await pqcSignFalcon1024(); updateStatus('Ù…Ø§Ú˜ÙˆÙ„ Falcon Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯');
    // for prototype: generate ephemeral master keypair to simulate sign/verify (NOT for production)
    const kp = await falconApi.keypair(); stateMasterPrivateKey = kp.privateKey; window._protoMasterPub = kp.publicKey;
  }catch(e){ console.warn('Falcon unavailable',e); updateStatus('Falcon Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù†Ø´Ø¯ â€” Ø§Ù…Ø¶Ø§ Ø¯Ø±ÙˆÙ†-Ø³Ø§ÛŒØª ØºÛŒØ±ÙØ¹Ø§Ù„ Ø§Ø³Øª'); }
})();

document.getElementById('gen').addEventListener('click', generateBanknote);
document.getElementById('validate').addEventListener('click', ()=>validateFromCanvasImage());
document.getElementById('download').addEventListener('click', ()=>{ canvas.toBlob(b=>{ const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download='sadat-note.png'; a.click(); }, 'image/png'); });

</script>

</body>
</html>




