<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <title>Sadat Digital Banknote (Post-Quantum Security)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    
    <script src="shake256.js"></script>
    <script src="ed25519.js"></script>
    <script src="falcon.js"></script> <style>
        :root {
            --primary-font: 'Poppins', 'Segoe UI', sans-serif;
            --mono-font: 'Roboto Mono', monospace;
            --dark-bg: #10101a;
            --medium-bg: #1a1a2e;
            --light-bg: #2a2a3e;
            --accent-color-1: #00e676; /* Green for PQC */
            --accent-color-2: #40c4ff; /* Blue for reliability */
            --text-color: #e0e0e0;
            --text-muted: #a0a0c0;
            --success-color: #00e676;
            --error-color: #ff5252;
            --info-color: #40c4ff;
            --warning-color: #ffab40;
            --border-color: rgba(64, 196, 255, 0.2);
        }
        body{margin:0;font-family:var(--primary-font);background-color:var(--dark-bg);background-image:radial-gradient(at 0% 0%, hsla(253, 100%, 15%, 0.3) 0px, transparent 50%),radial-gradient(at 100% 100%, hsla(150, 100%, 20%, 0.3) 0px, transparent 50%);color:var(--text-color);text-align:center;padding:24px}
        .container{max-width:900px;margin:0 auto;background:rgba(26,26,46,0.7);backdrop-filter:blur(12px);padding:24px;border-radius:24px;border:1px solid var(--border-color);box-shadow:0 8px 32px rgba(0,0,0,0.2)}
        .header{border-bottom:1px solid var(--border-color);padding-bottom:16px;margin-bottom:24px}
        h1{font-size:2.5rem;font-weight:600;color:#fff;margin:0 0 8px 0;letter-spacing:1px;background:linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
        .header p{font-size:1rem;color:var(--text-muted);margin:0}
        canvas{border-radius:16px;margin-top:24px;background:#050508;cursor:default;box-shadow:0 0 50px rgba(64,196,255,0.15);width:100%;max-width:900px;height:auto;border:1px solid var(--border-color)}
        input[type="number"],button,label{padding:14px 22px;font-size:16px;font-family:var(--primary-font);border-radius:12px;margin:8px 5px;border:1px solid var(--border-color);background:var(--medium-bg);color:#fff;transition:all .3s ease;cursor:pointer;outline:none;display:inline-flex;align-items:center;justify-content:center;gap:8px}
        input[type="number"]{font-family:var(--mono-font);font-weight:700;text-align:center;width:150px}
        input[type="number"]:focus{border-color:var(--accent-color-2);box-shadow:0 0 15px rgba(64,196,255,0.5)}
        button:not([disabled]),label:not([disabled]){font-weight:600;background:linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2));border:none;box-shadow:0 4px 15px rgba(0,0,0,0.2)}
        button.sub-button,label.sub-button{background:var(--light-bg);border:1px solid var(--border-color)}
        button[disabled],label[disabled]{cursor:not-allowed;opacity:0.5;background:var(--light-bg);border:1px solid var(--border-color)}
        button:hover:not([disabled]),label:hover:not([disabled]){transform:translateY(-2px);box-shadow:0 6px 20px rgba(64,196,255,0.4)}
        .section{background:rgba(16,16,26,0.5);padding:20px;margin-top:30px;border-radius:16px;border:1px solid var(--border-color)}
        h2{font-size:1.5rem;color:var(--text-color);margin-top:0;margin-bottom:20px;font-weight:600;border-bottom:1px solid var(--border-color);padding-bottom:10px}
        .controls-grid{display:flex;justify-content:center;align-items:center;flex-wrap:wrap;gap:16px}
        #validation-result, #key-status{margin-top:20px;font-size:12px;font-weight:normal;min-height:50px;line-height:1.6;text-align:left;background:var(--dark-bg);padding:15px 20px;border-radius:12px;white-space:pre-wrap;font-family:var(--mono-font);border:1px solid var(--border-color);transition:all .3s ease}
        .valid{color:var(--success-color)}.invalid{color:var(--error-color)}.info{color:var(--info-color)}.warning{color:var(--warning-color)}
        .error-block{background:rgba(255,82,82,0.1);border-left:4px solid var(--error-color);padding:10px;margin-top:10px;border-radius:4px}
        .error-block strong{color:var(--error-color)}
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>Sadat Digital Banknote</h1>
        <p>A quantum-resistant, verifiable digital currency using a hybrid signature scheme: <strong>Ed25519 + Falcon-512</strong> with <strong>SHAKE256 (1024-bit)</strong> hash and LSB Steganography.</p>
    </div>

    <canvas id="noteCanvas" width="1350" height="750"></canvas>

    <div class="section">
        <h2>Banknote Controls</h2>
        <div class="controls-grid">
            <span class="input-label">Amount:</span>
            <input type="number" id="amount-input" value="50000">
            <span class="input-label">Quantity:</span>
            <input type="number" id="quantity-input" value="1" min="1" max="100">
            <button id="create-note-button" onclick="handleCreateNewNote()" disabled>ğŸ¨ Redesign Banknote</button>
            <button id="download-batch-button" onclick="handleDownloadBatch()" disabled>ğŸ“¥ Download Batch</button>
        </div>
    </div>

    <div class="section">
        <h2>Bank Key Management</h2>
        <div class="controls-grid">
            <button id="generate-keys-button" onclick="handleGenerateAndExportKeys()" disabled>ğŸ”‘ Generate & Export Hybrid Keys</button>
            <label for="import-public-key" class="sub-button" id="import-public-label" disabled>Import Public Key</label>
            <input type="file" id="import-public-key" accept=".json" style="display: none;">
            <label for="import-private-key" class="sub-button" id="import-private-label" disabled>Import Private Key</label>
            <input type="file" id="import-private-key" accept=".json" style="display: none;">
        </div>
        <div id="key-status">Key pair status will be displayed here.</div>
    </div>

    <div class="section" id="validator-section">
        <h2>Validate Banknote</h2>
        <label for="validator-input" id="validator-label" disabled>Select Image for Validation</label>
        <input type="file" id="validator-input" accept="image/png" style="display: none;">
        <div id="validation-result">Validation result will be displayed here.</div>
    </div>
</div>

<script>
// ===================================================================================
// == Ù„Ø§ÛŒÙ‡ Ø§Ù†ØªØ²Ø§Ø¹ÛŒ Ùˆ Ù…Ø¯ÛŒØ±ÛŒØª Ù‡ÙˆØ´Ù…Ù†Ø¯ Ø®Ø·Ø§
// ===================================================================================
const ErrorHandler = (() => {
    const errorMap = {
        'CRYPTO_LIBS_MISSING': {
            algorithm: "System",
            cause: "ÛŒÚ© ÛŒØ§ Ú†Ù†Ø¯ Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡ Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ (shake256.js, ed25519.js, falcon.js) Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù†Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯ ÛŒØ§ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ù†Ø¯.",
            solution: "Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø­Ø§ØµÙ„ Ú©Ù†ÛŒØ¯ Ú©Ù‡ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ .js Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡â€ŒÙ‡Ø§ Ø¯Ø± Ú©Ù†Ø§Ø± Ø§ÛŒÙ† ÙØ§ÛŒÙ„ HTML Ù‚Ø±Ø§Ø± Ø¯Ø§Ø±Ù†Ø¯ Ùˆ Ù†Ø§Ù… Ø¢Ù†â€ŒÙ‡Ø§ ØµØ­ÛŒØ­ Ø§Ø³Øª. Ú©Ù†Ø³ÙˆÙ„ Ù…Ø±ÙˆØ±Ú¯Ø± (F12) Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ø®Ø·Ø§Ù‡Ø§ÛŒ 404 Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯."
        },
        'KEY_GENERATION_ED25519': {
            algorithm: "Ed25519",
            cause: "Ø®Ø·Ø§ÛŒ Ø¯Ø§Ø®Ù„ÛŒ Ø¯Ø± Ù‡Ù†Ú¯Ø§Ù… ØªÙˆÙ„ÛŒØ¯ Ø²ÙˆØ¬ Ú©Ù„ÛŒØ¯ Ed25519.",
            solution: "Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ ØªØ§Ø¨Ø¹ generateKeyPair Ø¯Ø± Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡ ed25519.js Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯. Ù…Ù…Ú©Ù† Ø§Ø³Øª Ù…Ø±ÙˆØ±Ú¯Ø± Ø§Ø² ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ù†Ú©Ù†Ø¯."
        },
        'KEY_GENERATION_FALCON': {
            algorithm: "Falcon-512",
            cause: "Ø®Ø·Ø§ÛŒ Ø¯Ø§Ø®Ù„ÛŒ Ø¯Ø± Ù‡Ù†Ú¯Ø§Ù… ØªÙˆÙ„ÛŒØ¯ Ø²ÙˆØ¬ Ú©Ù„ÛŒØ¯ Falcon-512.",
            solution: "Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ ØªØ§Ø¨Ø¹ generateKeyPair Ø¯Ø± Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡ falcon.js (Ø§Ø­ØªÙ…Ø§Ù„Ø§Ù‹ WebAssembly) Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯. Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø­Ø§ØµÙ„ Ú©Ù†ÛŒØ¯ Ú©Ù‡ Ø¨Ø±Ø§ÛŒ Ø³Ø·Ø­ Ø§Ù…Ù†ÛŒØªÛŒ Falcon-512 Ù¾ÛŒÚ©Ø±Ø¨Ù†Ø¯ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª."
        },
        'HASH_FAILURE': {
            algorithm: "SHAKE256",
            cause: "ÙØ±Ø§ÛŒÙ†Ø¯ Ù‡Ø´ Ú©Ø±Ø¯Ù† Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø¨Ø§ Ø´Ú©Ø³Øª Ù…ÙˆØ§Ø¬Ù‡ Ø´Ø¯.",
            solution: "ÙˆØ±ÙˆØ¯ÛŒ ØªØ§Ø¨Ø¹ Ù‡Ø´ Ùˆ Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ SHAKE256 Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯. ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø¨Ø§ÛŒØ¯ null ÛŒØ§ undefined Ø¨Ø§Ø´Ø¯."
        },
        'SIGNATURE_FAILURE_ED25519': {
            algorithm: "Ed25519",
            cause: "ØªÙˆÙ„ÛŒØ¯ Ø§Ù…Ø¶Ø§ Ø¨Ø§ Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ Ed25519 Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯.",
            solution: "Ø§Ø² Ù…Ø¹ØªØ¨Ø± Ø¨ÙˆØ¯Ù† Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ Ùˆ ÙØ±Ù…Øª ØµØ­ÛŒØ­ Ø¢Ù† Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø­Ø§ØµÙ„ Ú©Ù†ÛŒØ¯. Ú©Ù„ÛŒØ¯ Ù†Ø¨Ø§ÛŒØ¯ Ø¢Ø³ÛŒØ¨ Ø¯ÛŒØ¯Ù‡ Ø¨Ø§Ø´Ø¯."
        },
        'SIGNATURE_FAILURE_FALCON': {
            algorithm: "Falcon-512",
            cause: "ØªÙˆÙ„ÛŒØ¯ Ø§Ù…Ø¶Ø§ Ø¨Ø§ Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ Falcon-512 Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯.",
            solution: "Ø§Ø² Ù…Ø¹ØªØ¨Ø± Ø¨ÙˆØ¯Ù† Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ Falcon Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø­Ø§ØµÙ„ Ú©Ù†ÛŒØ¯. Ø§ÛŒÙ† Ø§Ù„Ú¯ÙˆØ±ÛŒØªÙ… Ø¨Ù‡ Ù…Ù†Ø§Ø¨Ø¹ Ù…Ø­Ø§Ø³Ø¨Ø§ØªÛŒ Ø¨ÛŒØ´ØªØ±ÛŒ Ù†ÛŒØ§Ø² Ø¯Ø§Ø±Ø¯Ø› Ù…Ù…Ú©Ù† Ø§Ø³Øª Ø¨Ù‡ Ø¯Ù„ÛŒÙ„ Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ù…Ù†Ø§Ø¨Ø¹ Ø¨Ø§ Ø´Ú©Ø³Øª Ù…ÙˆØ§Ø¬Ù‡ Ø´ÙˆØ¯."
        },
        'VERIFICATION_FAILURE_ED25519': {
            algorithm: "Ed25519",
            cause: "Ø§Ù…Ø¶Ø§ÛŒ Ed25519 Ø¨Ø§ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ùˆ Ú©Ù„ÛŒØ¯ Ø¹Ù…ÙˆÙ…ÛŒ Ù…Ø·Ø§Ø¨Ù‚Øª Ù†Ø¯Ø§Ø±Ø¯.",
            solution: "Ø§ÛŒÙ† Ø®Ø·Ø§ Ù†Ø´Ø§Ù†â€ŒØ¯Ù‡Ù†Ø¯Ù‡ Ø¯Ø³ØªÚ©Ø§Ø±ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ ÛŒØ§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ú©Ù„ÛŒØ¯ Ø¹Ù…ÙˆÙ…ÛŒ Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª. Ø§Ø³Ú©Ù†Ø§Ø³ Ø¬Ø¹Ù„ÛŒ Ø§Ø³Øª."
        },
        'VERIFICATION_FAILURE_FALCON': {
            algorithm: "Falcon-512",
            cause: "Ø§Ù…Ø¶Ø§ÛŒ Falcon-512 Ø¨Ø§ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ùˆ Ú©Ù„ÛŒØ¯ Ø¹Ù…ÙˆÙ…ÛŒ Ù…Ø·Ø§Ø¨Ù‚Øª Ù†Ø¯Ø§Ø±Ø¯.",
            solution: "Ø§ÛŒÙ† Ø®Ø·Ø§ Ù†Ø´Ø§Ù†â€ŒØ¯Ù‡Ù†Ø¯Ù‡ Ø¯Ø³ØªÚ©Ø§Ø±ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ ÛŒØ§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ú©Ù„ÛŒØ¯ Ø¹Ù…ÙˆÙ…ÛŒ Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª. Ø§ÛŒÙ† ÛŒÚ© Ù¾Ø±Ú†Ù… Ù‚Ø±Ù…Ø² Ø¬Ø¯ÛŒ Ø¨Ø±Ø§ÛŒ Ø§Ù…Ù†ÛŒØª Ù¾Ø³Ø§-Ú©ÙˆØ§Ù†ØªÙˆÙ…ÛŒ Ø§Ø³Øª. Ø§Ø³Ú©Ù†Ø§Ø³ Ø¬Ø¹Ù„ÛŒ Ø§Ø³Øª."
        },
        'KEY_IMPORT_INVALID_FORMAT': {
            algorithm: 'System',
            cause: 'ÙØ§ÛŒÙ„ Ú©Ù„ÛŒØ¯ ÙˆØ§Ø±Ø¯ Ø´Ø¯Ù‡ ÙØ±Ù…Øª JSON Ù…Ø¹ØªØ¨Ø±ÛŒ Ù†Ø¯Ø§Ø±Ø¯ ÛŒØ§ Ø³Ø§Ø®ØªØ§Ø± Ù…ÙˆØ±Ø¯ Ø§Ù†ØªØ¸Ø§Ø± (ed25519/falcon) Ø±Ø§ Ù†Ø¯Ø§Ø±Ø¯.',
            solution: 'ÙÙ‚Ø· Ø§Ø² ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ú©Ù„ÛŒØ¯ÛŒ Ú©Ù‡ ØªÙˆØ³Ø· Ù‡Ù…ÛŒÙ† Ø³ÛŒØ³ØªÙ… ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯. ÙØ§ÛŒÙ„ Ù†Ø¨Ø§ÛŒØ¯ Ø¨Ù‡ ØµÙˆØ±Øª Ø¯Ø³ØªÛŒ ÙˆÛŒØ±Ø§ÛŒØ´ Ø´Ø¯Ù‡ Ø¨Ø§Ø´Ø¯.'
        },
        'KEY_DECRYPTION_FAILURE': {
            algorithm: 'System (AES-GCM)',
            cause: 'Ø±Ù…Ø²Ú¯Ø´Ø§ÛŒÛŒ Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ Ø¨Ø§ Ø´Ú©Ø³Øª Ù…ÙˆØ§Ø¬Ù‡ Ø´Ø¯. Ø¨Ù‡ Ø§Ø­ØªÙ…Ø§Ù„ Ø²ÛŒØ§Ø¯ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª.',
            solution: 'Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ØµØ­ÛŒØ­ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯. Ø§Ú¯Ø± Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø±Ø§ ÙØ±Ø§Ù…ÙˆØ´ Ú©Ø±Ø¯Ù‡â€ŒØ§ÛŒØ¯ØŒ Ú©Ù„ÛŒØ¯ ØºÛŒØ±Ù‚Ø§Ø¨Ù„ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø³Øª.'
        }
    };

    function generateReport(errorCode, error) {
        const details = errorMap[errorCode] || {
            algorithm: "Unknown",
            cause: "ÛŒÚ© Ø®Ø·Ø§ÛŒ Ù†Ø§Ø´Ù†Ø§Ø®ØªÙ‡ Ø±Ø® Ø¯Ø§Ø¯Ù‡ Ø§Ø³Øª.",
            solution: "Ú©Ù†Ø³ÙˆÙ„ Ù…Ø±ÙˆØ±Ú¯Ø± (F12) Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨ÛŒØ´ØªØ± Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯."
        };
        console.error(`[CRITICAL ERROR] Code: ${errorCode}`, 'Details:', details, 'Original Error:', error);
        return `
            <div class="error-block">
                <strong>âŒ Ø®Ø·Ø§ÛŒ Ø§Ù…Ù†ÛŒØªÛŒ: Ø¹Ø¯Ù… ØªØ·Ø§Ø¨Ù‚ Ø¯Ø± Ø§Ù„Ú¯ÙˆØ±ÛŒØªÙ… ${details.algorithm}</strong><br>
                <strong>Ø¹Ù„Øª Ø§Ø­ØªÙ…Ø§Ù„ÛŒ:</strong> ${details.cause}<br>
                <strong>Ø±Ø§Ù‡ Ø­Ù„ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ÛŒ:</strong> ${details.solution}
            </div>
        `;
    }
    return { report: generateReport };
})();

// ===================================================================================
// == Ù¾Ù„ Ø§Ø±ØªØ¨Ø§Ø·ÛŒ Ø¨Ø§ Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡ Ù‡Ø§ÛŒ Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ (Ed25519, Falcon, SHAKE256)
// ===================================================================================
const CryptoBridge = (() => {
    function hash(data) {
        if (typeof window.shake256 !== 'function') throw new Error('HASH_FAILURE');
        try {
            return window.shake256(data, 128); // Generate a 1024-bit hash
        } catch (e) {
            console.error("SHAKE256 Hashing failed:", e);
            throw new Error('HASH_FAILURE');
        }
    }

    async function generateNewKeyPair() {
        let ed25519_keys, falcon_keys;
        try {
            if (typeof window.ed25519?.generateKeyPair !== 'function') throw new Error('KEY_GENERATION_ED25519');
            ed25519_keys = await window.ed25519.generateKeyPair();
        } catch (e) {
            console.error("Ed25519 key generation failed:", e);
            throw new Error('KEY_GENERATION_ED25519');
        }
        try {
            if (typeof window.falcon?.generateKeyPair !== 'function') throw new Error('KEY_GENERATION_FALCON');
            falcon_keys = await window.falcon.generateKeyPair();
        } catch (e) {
            console.error("Falcon-512 key generation failed:", e);
            throw new Error('KEY_GENERATION_FALCON');
        }
        return {
            ed25519: {
                publicKey: arrayBufferToBase64(ed25519_keys.publicKey),
                privateKey: arrayBufferToBase64(ed25519_keys.privateKey)
            },
            falcon: {
                publicKey: arrayBufferToBase64(falcon_keys.publicKey),
                privateKey: arrayBufferToBase64(falcon_keys.privateKey)
            }
        };
    }
    
    async function sign(dataToSign, privateKeys) {
        const messageHash = hash(dataToSign);
        let edSignature, falconSignature;
        try {
            const edPrivateKey = base64ToArrayBuffer(privateKeys.ed25519.privateKey);
            edSignature = await window.ed25519.sign(messageHash, edPrivateKey);
        } catch(e) {
            console.error("Ed25519 signing failed:", e);
            throw new Error('SIGNATURE_FAILURE_ED25519');
        }
        try {
            const falconPrivateKey = base64ToArrayBuffer(privateKeys.falcon.privateKey);
            falconSignature = await window.falcon.sign(messageHash, falconPrivateKey);
        } catch(e) {
            console.error("Falcon-512 signing failed:", e);
            throw new Error('SIGNATURE_FAILURE_FALCON');
        }
        return {
            ed25519_sig: arrayBufferToBase64(edSignature),
            falcon_sig: arrayBufferToBase64(falconSignature)
        };
    }

    async function verify(combinedSignature, dataToVerify, publicKeys) {
        const messageHash = hash(dataToVerify);
        let isEd25519Valid = false;
        try {
            const edPublicKey = base64ToArrayBuffer(publicKeys.ed25519.publicKey);
            const edSignature = base64ToArrayBuffer(combinedSignature.ed25519_sig);
            isEd25519Valid = await window.ed25519.verify(edSignature, messageHash, edPublicKey);
        } catch (e) {
             console.error("Ed25519 verification failed:", e);
             throw new Error('VERIFICATION_FAILURE_ED25519');
        }
        if (!isEd25519Valid) throw new Error('VERIFICATION_FAILURE_ED25519');
        
        let isFalconValid = false;
        try {
            const falconPublicKey = base64ToArrayBuffer(publicKeys.falcon.publicKey);
            const falconSignature = base64ToArrayBuffer(combinedSignature.falcon_sig);
            isFalconValid = await window.falcon.verify(falconSignature, messageHash, falconPublicKey);
        } catch(e) {
             console.error("Falcon-512 verification failed:", e);
             throw new Error('VERIFICATION_FAILURE_FALCON');
        }
        if (!isFalconValid) throw new Error('VERIFICATION_FAILURE_FALCON');
        return isEd25519Valid && isFalconValid;
    }

    return { generateNewKeyPair, sign, verify, hash };
})();


// ===================================================================================
// == Ù…Ù†Ø·Ù‚ Ø§ØµÙ„ÛŒ Ø¨Ø±Ù†Ø§Ù…Ù‡ Ùˆ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ù„ÛŒØ¯Ù‡Ø§
// ===================================================================================
const App = (() => {
    let activeKeys = { publicKeys: null, privateKeys: null };
    
    const AES_ALGO = "AES-GCM";
    const PBKDF2_ITERATIONS = 100000;
    const PBKDF2_HASH_ALGO = "SHA-256";

    async function encryptKeys(privateKeys, password) {
        const salt = window.crypto.getRandomValues(new Uint8Array(16));
        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const keyMaterial = await window.crypto.subtle.importKey("raw", new TextEncoder().encode(password), { name: "PBKDF2" }, false, ["deriveKey"]);
        const derivedKey = await window.crypto.subtle.deriveKey(
            { name: "PBKDF2", salt, iterations: PBKDF2_ITERATIONS, hash: PBKDF2_HASH_ALGO },
            keyMaterial, { name: AES_ALGO, length: 256 }, true, ["encrypt"]
        );
        const encodedKeys = new TextEncoder().encode(JSON.stringify(privateKeys));
        const encrypted = await window.crypto.subtle.encrypt({ name: AES_ALGO, iv }, derivedKey, encodedKeys);
        return {
            cipherText: arrayBufferToBase64(encrypted), salt: arrayBufferToBase64(salt), iv: arrayBufferToBase64(iv)
        };
    }

    async function decryptKeys(encryptedData, password) {
        try {
            const salt = base64ToArrayBuffer(encryptedData.salt);
            const iv = base64ToArrayBuffer(encryptedData.iv);
            const cipherText = base64ToArrayBuffer(encryptedData.cipherText);
            const keyMaterial = await window.crypto.subtle.importKey("raw", new TextEncoder().encode(password), { name: "PBKDF2" }, false, ["deriveKey"]);
            const derivedKey = await window.crypto.subtle.deriveKey(
                { name: "PBKDF2", salt, iterations: PBKDF2_ITERATIONS, hash: PBKDF2_HASH_ALGO },
                keyMaterial, { name: AES_ALGO, length: 256 }, true, ["decrypt"]
            );
            const decrypted = await window.crypto.subtle.decrypt({ name: AES_ALGO, iv }, derivedKey, cipherText);
            return JSON.parse(new TextDecoder().decode(decrypted));
        } catch (e) {
            throw new Error('KEY_DECRYPTION_FAILURE');
        }
    }

    async function handleGenerateAndExport() {
        const password = prompt("ÛŒÚ© Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ù‚ÙˆÛŒ Ø¨Ø±Ø§ÛŒ Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ ÙØ§ÛŒÙ„ Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ ØªØ±Ú©ÛŒØ¨ÛŒ Ø®ÙˆØ¯ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:");
        if (!password) {
            updateKeyStatus('<span class="warning">âš ï¸ Ø¹Ù…Ù„ÛŒØ§Øª Ù„ØºÙˆ Ø´Ø¯. Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ø±Ø§ÛŒ Ø§Ù…Ù†ÛŒØª Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª.</span>');
            return;
        }

        updateKeyStatus('<span class="info">â³ Ø¯Ø± Ø­Ø§Ù„ ØªÙˆÙ„ÛŒØ¯ Ø²ÙˆØ¬ Ú©Ù„ÛŒØ¯Ù‡Ø§ÛŒ ØªØ±Ú©ÛŒØ¨ÛŒ (Ed25519 & Falcon-512)... Ø§ÛŒÙ† ÙØ±Ø¢ÛŒÙ†Ø¯ Ù…Ù…Ú©Ù† Ø§Ø³Øª Ú©Ù…ÛŒ Ø·ÙˆÙ„ Ø¨Ú©Ø´Ø¯.</span>');
        
        try {
            const keyPair = await CryptoBridge.generateNewKeyPair();
            
            // From this point on, we have a valid keypair.
            activeKeys.privateKeys = keyPair;
            activeKeys.publicKeys = {
                 ed25519: { publicKey: keyPair.ed25519.publicKey },
                 falcon: { publicKey: keyPair.falcon.publicKey }
            };
            
            downloadFile(JSON.stringify(activeKeys.publicKeys, null, 2), 'Sadat-Hybrid-PublicKey-512.json', 'application/json');
            
            const encryptedPrivate = await encryptKeys(keyPair, password);
            downloadFile(JSON.stringify(encryptedPrivate, null, 2), 'Sadat-Hybrid-PrivateKey-512.json', 'application/json');

            updateKeyStatus('<span class="valid">âœ… Ø²ÙˆØ¬ Ú©Ù„ÛŒØ¯Ù‡Ø§ÛŒ ØªØ±Ú©ÛŒØ¨ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªÙˆÙ„ÛŒØ¯ Ùˆ ØµØ§Ø¯Ø± Ø´Ø¯Ù†Ø¯. Ø³ÛŒØ³ØªÙ… Ø¨Ø±Ø§ÛŒ ØµØ¯ÙˆØ± Ø§Ø³Ú©Ù†Ø§Ø³ Ø¢Ù…Ø§Ø¯Ù‡ Ø§Ø³Øª.</span>');
            updateControlsState(true);
            await handleCreateNewNote();
        } catch (error) {
            updateKeyStatus(ErrorHandler.report(error.message, error));
        }
    }

    function importPublicKey(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const keyData = JSON.parse(e.target.result);
                if (!keyData.ed25519?.publicKey || !keyData.falcon?.publicKey) {
                    throw new Error('KEY_IMPORT_INVALID_FORMAT');
                }
                activeKeys.publicKeys = keyData;
                updateKeyStatus('<span class="valid">âœ… Ú©Ù„ÛŒØ¯ Ø¹Ù…ÙˆÙ…ÛŒ ØªØ±Ú©ÛŒØ¨ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ÙˆØ§Ø±Ø¯ Ø´Ø¯. Ø§Ú©Ù†ÙˆÙ† Ø¨Ø±Ø§ÛŒ ØªØ£ÛŒÛŒØ¯ Ø§Ø³Ú©Ù†Ø§Ø³â€ŒÙ‡Ø§ ÙØ¹Ø§Ù„ Ø§Ø³Øª.</span>');
                document.getElementById('validator-label').removeAttribute('disabled');
            } catch (error) {
                updateKeyStatus(ErrorHandler.report(error.message || 'KEY_IMPORT_INVALID_FORMAT', error));
            }
        };
        reader.readAsText(file);
    }
    
    function importPrivateKey(file) {
        const password = prompt("Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ÙØ§ÛŒÙ„ Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ø±Ù…Ø²Ú¯Ø´Ø§ÛŒÛŒ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:");
        if (!password) {
            updateKeyStatus('<span class="warning">âš ï¸ Ø¹Ù…Ù„ÛŒØ§Øª Ù„ØºÙˆ Ø´Ø¯. Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª.</span>');
            return;
        }
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const encryptedData = JSON.parse(e.target.result);
                updateKeyStatus('<span class="info">â³ Ø¯Ø± Ø­Ø§Ù„ Ø±Ù…Ø²Ú¯Ø´Ø§ÛŒÛŒ Ùˆ ÙˆØ§Ø±Ø¯ Ú©Ø±Ø¯Ù† Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ...</span>');
                const privateKeys = await decryptKeys(encryptedData, password);
                if (!privateKeys.ed25519?.privateKey || !privateKeys.falcon?.privateKey) {
                    throw new Error('KEY_IMPORT_INVALID_FORMAT');
                }
                activeKeys.privateKeys = privateKeys;
                activeKeys.publicKeys = {
                    ed25519: { publicKey: privateKeys.ed25519.publicKey },
                    falcon: { publicKey: privateKeys.falcon.publicKey }
                };
                updateKeyStatus('<span class="valid">âœ… Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ ØªØ±Ú©ÛŒØ¨ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ÙˆØ§Ø±Ø¯ Ø´Ø¯. Ø§Ú©Ù†ÙˆÙ† Ø¨Ø±Ø§ÛŒ Ø§Ù…Ø¶Ø§ÛŒ Ø§Ø³Ú©Ù†Ø§Ø³â€ŒÙ‡Ø§ ÙØ¹Ø§Ù„ Ø§Ø³Øª.</span>');
                updateControlsState(true);
            } catch (error) {
                updateKeyStatus(ErrorHandler.report(error.message, error));
            }
        };
        reader.readAsText(file);
    }
    
    async function getSignedNoteData(amount, index = 0) {
        if (!activeKeys.privateKeys) {
            alert("Ø®Ø·Ø§: Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ Ø¨Ø±Ø§ÛŒ Ø§Ù…Ø¶Ø§ ÙØ¹Ø§Ù„ Ù†ÛŒØ³Øª.");
            return null;
        }
        const now = Date.now();
        const noteData = {
            amount: parseInt(amount) || 0,
            verificationKey: "SVK-" + Math.random().toString(16).substring(2, 10).toUpperCase(),
            serial: "SDT-" + (now + index).toString().slice(-8),
            timestamp: now,
            sig_scheme: "Ed25519+Falcon-512/SHAKE256"
        };
        const stringToSign = getStandardizedDataForSigning(noteData);
        
        try {
            const combinedSignature = await CryptoBridge.sign(stringToSign, activeKeys.privateKeys);
            noteData.signature = arrayBufferToBase64(new TextEncoder().encode(JSON.stringify(combinedSignature)));
            noteData.visualHash = arrayBufferToHex(await CryptoBridge.hash(noteData.signature));
            return noteData;
        } catch (error) {
            updateKeyStatus(ErrorHandler.report(error.message, error));
            return null;
        }
    }

    async function validateNote(file) {
        if (!activeKeys.publicKeys) {
            alert("Ø®Ø·Ø§: Ú©Ù„ÛŒØ¯ Ø¹Ù…ÙˆÙ…ÛŒ Ø¨Ø±Ø§ÛŒ ØªØ£ÛŒÛŒØ¯ ÙØ¹Ø§Ù„ Ù†ÛŒØ³Øª. Ù„Ø·ÙØ§Ù‹ ÛŒÚ© Ú©Ù„ÛŒØ¯ Ø¹Ù…ÙˆÙ…ÛŒ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.");
            return;
        }
        const resultDiv = document.getElementById('validation-result');
        resultDiv.innerHTML = `<span class="info">â³ Ø¢Ù…Ø§Ø¯Ù‡ Ø³Ø§Ø²ÛŒ ØªØµÙˆÛŒØ± Ø¨Ø±Ø§ÛŒ Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ...</span>`;
        const img = new Image();
        img.src = URL.createObjectURL(file);
        img.onload = async () => {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = 1350; tempCanvas.height = 750;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
            let resultHTML = "";

            try {
                resultHTML += `<span class="info">Û±. Ø®ÙˆØ§Ù†Ø¯Ù† Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¯ÛŒØ¬ÛŒØªØ§Ù„ Ø§Ø² Ú©Ø¯ QR...</span>\n`;
                const qrData = readQRCodeFromCanvas(tempCanvas);
                if (!qrData) {
                    resultHTML += `<span class="invalid">âŒ Ø®Ø·Ø§ÛŒ Ù…Ù‡Ù„Ú©: Ú©Ø¯ QR ÛŒØ§ÙØª Ù†Ø´Ø¯ ÛŒØ§ ØºÛŒØ±Ù‚Ø§Ø¨Ù„ Ø®ÙˆØ§Ù†Ø¯Ù† Ø§Ø³Øª.</span>`;
                    resultDiv.innerHTML = resultHTML;
                    return;
                }
                resultHTML += `<span class="valid">âœ… Ú©Ø¯ QR Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø®ÙˆØ§Ù†Ø¯Ù‡ Ø´Ø¯.</span>\n\n`;

                resultHTML += `<span class="info">Û². ØªØ£ÛŒÛŒØ¯ Ø§Ù…Ø¶Ø§ÛŒ Ø¯ÛŒØ¬ÛŒØªØ§Ù„ ØªØ±Ú©ÛŒØ¨ÛŒ (${qrData.sig_scheme || 'N/A'})...</span>\n`;
                const isSignatureValid = await validateDigitalSignature(qrData);
                if (isSignatureValid) {
                     resultHTML += `<span class="valid">âœ… Ø§Ù…Ø¶Ø§ÛŒ Ø¯ÛŒØ¬ÛŒØªØ§Ù„ ØªØ±Ú©ÛŒØ¨ÛŒ Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª. Ø§ØµØ§Ù„Øª Ùˆ ÛŒÚ©Ù¾Ø§Ø±Ú†Ú¯ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ ØªØ£ÛŒÛŒØ¯ Ø´Ø¯.</span>\n\n`;
                }
                
                resultHTML += `<span class="info">Û³. Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ùˆ ØªØ·Ø¨ÛŒÙ‚ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù¾Ù†Ù‡Ø§Ù† Ø´Ø¯Ù‡ (Steganography)...</span>\n`;
                const expectedSignatureString = JSON.stringify(JSON.parse(new TextDecoder().decode(base64ToArrayBuffer(qrData.signature))));
                const decodedSignature = LSB.decode(tempCtx);
                if (decodedSignature && decodedSignature === expectedSignatureString) {
                    resultHTML += `<span class="valid">âœ… Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù¾Ù†Ù‡Ø§Ù† Ø´Ø¯Ù‡ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ùˆ Ø¨Ø§ Ø§Ù…Ø¶Ø§ÛŒ Ø§ØµÙ„ÛŒ ØªØ·Ø¨ÛŒÙ‚ Ø¯Ø§Ø¯Ù‡ Ø´Ø¯. ÛŒÚ©Ù¾Ø§Ø±Ú†Ú¯ÛŒ ØªØµÙˆÛŒØ± ØªØ£ÛŒÛŒØ¯ Ø´Ø¯.</span>\n\n`;
                } else {
                     resultHTML += `<span class="invalid">âŒ Ø®Ø·Ø§ÛŒ Ù…Ù‡Ù„Ú©: Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù¾Ù†Ù‡Ø§Ù† Ø´Ø¯Ù‡ Ø¯Ø± ØªØµÙˆÛŒØ± Ø¨Ø§ Ø§Ù…Ø¶Ø§ÛŒ Ø¯ÛŒØ¬ÛŒØªØ§Ù„ Ù…Ø·Ø§Ø¨Ù‚Øª Ù†Ø¯Ø§Ø±Ø¯. ØªØµÙˆÛŒØ± Ø§Ø³Ú©Ù†Ø§Ø³ Ø¯Ø³ØªÚ©Ø§Ø±ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª.</span>\n`;
                     resultDiv.innerHTML = resultHTML;
                     return;
                }

                resultHTML += `<hr style="border-color: var(--border-color); border-style: dashed; margin: 15px 0 10px;">\n<span style="font-size: 14px; font-weight: 600;">âœ… Ø±Ø£ÛŒ Ù†Ù‡Ø§ÛŒÛŒ: Ø§Ø³Ú©Ù†Ø§Ø³ Ù…Ø¹ØªØ¨Ø± Ùˆ Ø§ØµÛŒÙ„ Ø§Ø³Øª.</span>`;
                resultDiv.innerHTML = resultHTML;

            } catch (error) {
                resultHTML += ErrorHandler.report(error.message, error);
                resultHTML += `<hr style="border-color: var(--border-color); border-style: dashed; margin: 15px 0 10px;">\n<span style="font-size: 14px; font-weight: 600;">âŒ Ø±Ø£ÛŒ Ù†Ù‡Ø§ÛŒÛŒ: Ø§Ø³Ú©Ù†Ø§Ø³ Ø¬Ø¹Ù„ÛŒ ÛŒØ§ Ø¯Ø³ØªÚ©Ø§Ø±ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª.</span>`;
                resultDiv.innerHTML = resultHTML;
            }
        };
    }

    async function validateDigitalSignature(qrData) {
        const { signature, ...dataToVerify } = qrData;
        const stringToVerify = getStandardizedDataForSigning(dataToVerify);
        const combinedSignature = JSON.parse(new TextDecoder().decode(base64ToArrayBuffer(signature)));
        return await CryptoBridge.verify(combinedSignature, stringToVerify, activeKeys.publicKeys);
    }
    
    function getStandardizedDataForSigning(noteData) {
        const data = { ...noteData };
        delete data.signature;
        delete data.visualHash;
        return JSON.stringify(data, Object.keys(data).sort());
    }

    return { 
        handleGenerateAndExport, 
        importPublicKey, 
        importPrivateKey, 
        getSignedNoteData,
        validateNote
    };
})();

// ===================================================================================
// == Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ Ùˆ Ú©Ù†ØªØ±Ù„ Ù‡Ø§ÛŒ UI
// ===================================================================================
// Global variables and utility functions
let currentNoteData = {};
const canvas = document.getElementById("noteCanvas");
const ctx = canvas.getContext("2d");

function updateKeyStatus(message) { document.getElementById('key-status').innerHTML = message; }
function updateControlsState(isEnabled) {
    document.getElementById('create-note-button').disabled = !isEnabled;
    document.getElementById('download-batch-button').disabled = !isEnabled;
    if (isEnabled) {
        document.getElementById('validator-label').removeAttribute('disabled');
    }
}
function downloadFile(data, filename, type) {
    const blob = new Blob([data], { type: type });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(a.href);
}
function arrayBufferToBase64(buffer) {
    return btoa(String.fromCharCode.apply(null, new Uint8Array(buffer)));
}
function base64ToArrayBuffer(base64) {
    const binary_string = atob(base64);
    const len = binary_string.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
        bytes[i] = binary_string.charCodeAt(i);
    }
    return bytes.buffer;
}
function arrayBufferToHex(buffer) {
    return Array.from(new Uint8Array(buffer)).map(b => b.toString(16).padStart(2, '0')).join('');
}

// UI Event Listeners
document.getElementById('import-public-key').addEventListener('change', (e) => e.target.files[0] && App.importPublicKey(e.target.files[0]));
document.getElementById('import-private-key').addEventListener('change', (e) => e.target.files[0] && App.importPrivateKey(e.target.files[0]));
document.getElementById('validator-input').addEventListener('change', (e) => e.target.files[0] && App.validateNote(e.target.files[0]));
function handleGenerateAndExportKeys() { App.handleGenerateAndExport(); }


async function handleCreateNewNote() {
    const amount = document.getElementById("amount-input").value;
    updateKeyStatus('<span class="info">â³ Ø¯Ø± Ø­Ø§Ù„ ØªÙˆÙ„ÛŒØ¯ Ø·Ø±Ø­ Ø§Ø³Ú©Ù†Ø§Ø³ Ø¬Ø¯ÛŒØ¯...</span>');
    const noteData = await App.getSignedNoteData(amount);
    if (noteData) {
        currentNoteData = noteData;
        await drawNoteOnCanvas(canvas, currentNoteData, canvas.width, canvas.height, true);
        updateKeyStatus('<span class="valid">âœ… Ø·Ø±Ø­ Ø§Ø³Ú©Ù†Ø§Ø³ Ø¬Ø¯ÛŒØ¯ Ø¢Ù…Ø§Ø¯Ù‡ Ø§Ø³Øª.</span>');
    }
}

async function handleDownloadBatch() {
    const quantity = parseInt(document.getElementById('quantity-input').value) || 1;
    const amount = document.getElementById("amount-input").value;
    const resultDiv = document.getElementById('validation-result');
    if (!window.showDirectoryPicker) {
         alert("Ù…Ø±ÙˆØ±Ú¯Ø± Ø´Ù…Ø§ Ø§Ø² File System Access API Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ù†Ù…ÛŒâ€ŒÚ©Ù†Ø¯. Ù„Ø·ÙØ§Ù‹ Ø§Ø³Ú©Ù†Ø§Ø³â€ŒÙ‡Ø§ Ø±Ø§ Ø¨Ù‡ ØµÙˆØ±Øª ØªÚ©ÛŒ Ø¯Ø§Ù†Ù„ÙˆØ¯ Ú©Ù†ÛŒØ¯.");
         return;
    }
     try {
        const dirHandle = await window.showDirectoryPicker();
        resultDiv.innerHTML = `<span class="info">Ù¾Ø±Ø¯Ø§Ø²Ø´ ${quantity} Ø§Ø³Ú©Ù†Ø§Ø³... Ù„Ø·ÙØ§Ù‹ Ù…Ù†ØªØ¸Ø± Ø¨Ù…Ø§Ù†ÛŒØ¯.</span>`;
        const offscreenCanvas = document.createElement('canvas');
        offscreenCanvas.width = canvas.width;
        offscreenCanvas.height = canvas.height;

        for (let i = 0; i < quantity; i++) {
            const noteData = await App.getSignedNoteData(amount, i);
            if (!noteData) {
                resultDiv.innerHTML += `<br><span class="invalid">âŒ Ø¹Ù…Ù„ÛŒØ§Øª Ù…ØªÙˆÙ‚Ù Ø´Ø¯. Ø®Ø·Ø§ÛŒ Ø§Ù…Ø¶Ø§ Ø±Ø§ Ø¯Ø± Ø¨Ø®Ø´ ÙˆØ¶Ø¹ÛŒØª Ú©Ù„ÛŒØ¯ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯.</span>`;
                return;
            }
            await drawNoteOnCanvas(offscreenCanvas, noteData, offscreenCanvas.width, offscreenCanvas.height, true);
            const blob = await new Promise(resolve => offscreenCanvas.toBlob(resolve, 'image/png'));
            const fileHandle = await dirHandle.getFileHandle(`SADAT-NOTE-HYBRID-512-${noteData.serial}.png`, { create: true });
            const writable = await fileHandle.createWritable();
            await writable.write(blob);
            await writable.close();
            resultDiv.innerHTML = `<span class="info">Ø§Ø³Ú©Ù†Ø§Ø³ ${i + 1} Ø§Ø² ${quantity} Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯.</span>`;
        }
        resultDiv.innerHTML = `<span class="valid">âœ… ${quantity} Ø§Ø³Ú©Ù†Ø§Ø³ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¯Ø± Ù¾ÙˆØ´Ù‡ Ø§Ù†ØªØ®Ø§Ø¨ÛŒ Ø´Ù…Ø§ Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯.</span>`;
        await handleCreateNewNote();
    } catch (error) {
        if (error.name !== 'AbortError') {
             resultDiv.innerHTML = `<span class="invalid">âŒ Ø®Ø·Ø§: ${error.message}</span>`;
        }
    }
}

// Pre-loader and Initialization
window.onload = () => {
    updateKeyStatus('<span class="info">â³ Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ùˆ Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡â€ŒÙ‡Ø§ÛŒ Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ...</span>');
    
    setTimeout(() => {
        const libsReady = typeof window.shake256 === 'function' && typeof window.ed25519 === 'object' && typeof window.falcon === 'object';
        
        if (!libsReady) {
            updateKeyStatus(ErrorHandler.report('CRYPTO_LIBS_MISSING'));
            // Keep buttons disabled
            return;
        }
        
        updateKeyStatus('<span class="valid">âœ… Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡â€ŒÙ‡Ø§ÛŒ Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ Ø¢Ù…Ø§Ø¯Ù‡ Ù‡Ø³ØªÙ†Ø¯.</span><br><span class="info">Ù„Ø·ÙØ§Ù‹ ÛŒÚ© Ø²ÙˆØ¬ Ú©Ù„ÛŒØ¯ Ø¬Ø¯ÛŒØ¯ ØªÙˆÙ„ÛŒØ¯ Ú©Ø±Ø¯Ù‡ ÛŒØ§ Ú©Ù„ÛŒØ¯Ù‡Ø§ÛŒ Ù…ÙˆØ¬ÙˆØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ù†Ù…Ø§ÛŒÛŒØ¯.</span>');
        document.getElementById('generate-keys-button').removeAttribute('disabled');
        document.getElementById('import-public-label').removeAttribute('disabled');
        document.getElementById('import-private-label').removeAttribute('disabled');

    }, 500);
};


// ===================================================================================
// == ØªÙˆØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ Ùˆ Ø·Ø±Ø§Ø­ÛŒ (Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ±)
// ===================================================================================
const LSB = (() => { const t="00000000";function o(o){return o.split("").map(t=>t.charCodeAt(0).toString(2).padStart(8,"0")).join("")+t}return{encode:function(e,n){const r=o(n),c=e.getImageData(0,0,e.canvas.width,e.canvas.height),i=c.data;if(r.length>3*i.length/4)throw new Error("Message too long");let d=0;for(let t=0;t<r.length;t++)(d+1)%4===0&&d++,i[d]=(254&i[d])|parseInt(r[t],10),d++;e.putImageData(c,0,0)},decode:function(o){const e=o.getImageData(0,0,o.canvas.width,o.canvas.height).data;let n="",r="";for(let o=0;o<e.length;o++){if((o+1)%4===0)continue;const c=1&e[o];if(n+=c,8===n.length){if(n===t)return r;r+=String.fromCharCode(parseInt(n,2)),n=""}}return null}}}();
function readQRCodeFromCanvas(canvasToCheck) { const context = canvasToCheck.getContext('2d'); const qrRegion = { x: 800, y: 210, width: 420, height: 420 }; const imageData = context.getImageData(qrRegion.x, qrRegion.y, qrRegion.width, qrRegion.height); const code = jsQR(imageData.data, imageData.width, imageData.height); if (code) { try { return JSON.parse(code.data); } catch { return null; } } return null; }
async function drawNoteOnCanvas(targetCanvas,noteData,width,height,applySteganography=!0){return new Promise(async(resolve,reject)=>{if(Object.keys(noteData).length===0)return reject("No note data provided.");const ctx=targetCanvas.getContext("2d"),{amount:amount,verificationKey:verificationKey,serial:serial,visualHash:visualHash,signature:signature}=noteData,w=width,h=height,scale=w/1350,bgGradient=ctx.createLinearGradient(0,0,0,h),baseHue=H(visualHash,0,0,360);bgGradient.addColorStop(0,`hsl(${baseHue}, 50%, 6%)`),bgGradient.addColorStop(1,`hsl(${baseHue}, 40%, 4%)`),ctx.fillStyle=bgGradient,ctx.fillRect(0,0,w,h),drawWatermark(ctx,visualHash,w,h),drawKochGuilloche(ctx,visualHash,w,h),drawNoisePattern(ctx,visualHash,w,h),ctx.shadowColor="rgba(0, 0, 0, 0.7)",ctx.shadowBlur=8*scale,ctx.shadowOffsetX=2*scale,ctx.shadowOffsetY=2*scale,ctx.fillStyle="#EAEAEA",ctx.font=`bold ${80*scale}px 'Roboto Mono'`,ctx.textAlign="left",ctx.fillText(serial.substring(4),150*scale,160*scale),ctx.fillText(verificationKey.substring(4),150*scale,280*scale),ctx.font=`bold ${150*scale}px 'Roboto Mono'`,ctx.textAlign="right",ctx.shadowBlur=12*scale,ctx.shadowOffsetX=4*scale,ctx.shadowOffsetY=4*scale,ctx.fillText(amount.toString(),w-120*scale,190*scale),ctx.shadowColor="transparent";const qrDataString=JSON.stringify(noteData),qrCanvas=document.createElement("canvas"),qrSize=380*scale;QRCode.toCanvas(qrCanvas,qrDataString,{width:qrSize,errorCorrectionLevel:"H",color:{dark:"#000000",light:"#FFFFFF"}},err=>{if(err)return reject(err);const qrX=w-150*scale-qrSize,qrY=h-520*scale;ctx.drawImage(qrCanvas,qrX,qrY,qrSize,qrSize),ctx.font=`${30*scale}px 'Roboto Mono'`,ctx.fillStyle="rgba(255, 255, 255, 0.4)",ctx.textAlign="center",ctx.fillText("Digitally Signed by Sadat Bank Authority (PQC)",w/2,h-60*scale);if(applySteganography&&signature){try{const sigString=JSON.stringify(JSON.parse(new TextDecoder().decode(base64ToArrayBuffer(signature))));LSB.encode(ctx,sigString)}catch(t){console.error("LSB Encoding Error:",t),reject(t)}}resolve()})})}
const H=(text,index,min,max)=>min+(parseInt(text.substring(index,index+2),16)%(max-min+1));function drawKochGuilloche(g_ctx,hash,w,h){g_ctx.save(),g_ctx.translate(w/2,h/2);const scale=w/1350,iteration=H(hash,2,2,4),size=w*(H(hash,4,10,20)/100),angleOffset=H(hash,6,0,360)/360*2*Math.PI,numLines=H(hash,8,3,6),hueOffset=H(hash,10,0,360);function drawKochSegment(x1,y1,x2,y2,level){if(0===level)return void g_ctx.lineTo(x2,y2);const dx=x2-x1,dy=y2-y1,dist=Math.sqrt(dx*dx+dy*dy),unitVecX=dx/dist,unitVecY=dy/dist,p1x=x1+unitVecX*dist/3,p1y=y1+unitVecY*dist/3,p2x=x1+2*unitVecX*dist/3,p2y=y1+2*unitVecY*dist/3,p3x=p1x+unitVecX*dist/6-unitVecY*dist*Math.sqrt(3)/6,p3y=p1y+unitVecY*dist/6+unitVecX*dist*Math.sqrt(3)/6;drawKochSegment(x1,y1,p1x,p1y,level-1),drawKochSegment(p1x,p1y,p3x,p3y,level-1),drawKochSegment(p3x,p3y,p2x,p2y,level-1),drawKochSegment(p2x,p2y,x2,y2,level-1)}g_ctx.lineWidth=1*scale,g_ctx.lineJoin="bevel",g_ctx.lineCap="round";for(let i=0;i<numLines;i++){const hue=(hueOffset+i*(360/numLines))%360;g_ctx.strokeStyle=`hsla(${hue}, 70%, 60%, 0.15)`;const lineAngle=i/numLines*2*Math.PI+angleOffset,x1=Math.cos(lineAngle)*size,y1=Math.sin(lineAngle)*size,x2=Math.cos(lineAngle+Math.PI)*size,y2=Math.sin(lineAngle+Math.PI)*size;g_ctx.beginPath(),g_ctx.moveTo(x1,y1),drawKochSegment(x1,y1,x2,y2,iteration),g_ctx.stroke()}g_ctx.restore()}
function drawWatermark(g_ctx,hash,w,h){g_ctx.save(),g_ctx.translate(w/2,h/2);const scale=w/1350,numSpirals=H(hash,16,3,6),spiralRadius=w*(H(hash,18,10,25)/100)*scale,hue=H(hash,20,0,360);g_ctx.strokeStyle=`hsla(${hue}, 50%, 80%, 0.05)`,g_ctx.lineWidth=4*scale;for(let i=0;i<numSpirals;i++){g_ctx.beginPath();const startAngle=i/numSpirals*2*Math.PI+H(hash,22,0,100)/100,endAngle=startAngle+H(hash,24,6,12)*Math.PI;for(let t=startAngle;t<endAngle;t+=.05){const r=spiralRadius*(t-startAngle)/(endAngle-startAngle),x=r*Math.cos(t),y=r*Math.sin(t);t===startAngle?g_ctx.moveTo(x,y):g_ctx.lineTo(x,y)}g_ctx.stroke()}g_ctx.restore()}
function drawNoisePattern(g_ctx,hash,w,h){g_ctx.save();for(let i=0;i<2e4;i++){const x=Math.random()*w,y=Math.random()*h,o=.15*Math.random(),hue=H(hash,4+i%30,0,360);g_ctx.fillStyle=`hsla(${hue},50%,80%,${o})`,g_ctx.fillRect(x,y,1,1)}g_ctx.restore()}

</script>
</body>
</html>
