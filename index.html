<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>Ø§Ø³Ú©Ù†Ø§Ø³ Ø¯ÛŒØ¬ÛŒØªØ§Ù„ Ø§Ù…Ù† | Ù…Ø¹Ù…Ø§Ø±ÛŒ Ù‡ÛŒØ¨Ø±ÛŒØ¯ÛŒ Ù¾Ø³Ø§Ú©ÙˆØ§Ù†ØªÙˆÙ…</title>
    
    <script type="module" src="https://cdn.skypack.dev/tweetnacl"></script>
    <script type="module" src="https://cdn.skypack.dev/js-sha3"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;600;700&family=Roboto+Mono:wght@700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --primary-font: 'Vazirmatn', 'Segoe UI', sans-serif;
            --mono-font: 'Roboto Mono', monospace;
            --dark-bg: #10101a;
            --medium-bg: #1a1a2e;
            --light-bg: #2a2a3e;
            --accent-color-1: #e040fb;
            --accent-color-2: #7c4dff;
            --text-color: #e0e0e0;
            --text-muted: #a0a0c0;
            --success-color: #00e676;
            --error-color: #ff5252;
            --info-color: #40c4ff;
            --border-color: rgba(124, 77, 255, 0.2);
        }

        body {
            margin: 0;
            font-family: var(--primary-font);
            background-color: var(--dark-bg);
            background-image:
                radial-gradient(at 0% 0%, hsla(253, 100%, 15%, 0.3) 0px, transparent 50%),
                radial-gradient(at 100% 100%, hsla(263, 100%, 20%, 0.3) 0px, transparent 50%);
            color: var(--text-color);
            text-align: center;
            padding: 24px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: rgba(26, 26, 46, 0.7);
            backdrop-filter: blur(12px);
            padding: 24px;
            border-radius: 24px;
            border: 1px solid var(--border-color);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .header {
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 16px;
            margin-bottom: 24px;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            color: #fff;
            margin: 0 0 8px 0;
            letter-spacing: 1px;
            background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header p {
            font-size: 1rem;
            color: var(--text-muted);
            margin: 0;
        }

        canvas {
            border-radius: 16px;
            margin-top: 24px;
            background: #050508;
            cursor: default;
            box-shadow: 0 0 50px rgba(124, 77, 255, 0.15);
            width: 100%;
            max-width: 900px;
            height: auto;
            border: 1px solid var(--border-color);
        }

        input[type="number"], button, label {
            padding: 14px 22px;
            font-size: 16px;
            font-family: var(--primary-font);
            border-radius: 12px;
            margin: 8px 5px;
            border: 1px solid var(--border-color);
            background: var(--medium-bg);
            color: #fff;
            transition: all 0.3s ease;
            cursor: pointer;
            outline: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        input[type="number"] {
            font-family: var(--mono-font);
            font-weight: 700;
            text-align: center;
            width: 150px;
        }

        input[type="number"]:focus {
            border-color: var(--accent-color-2);
            box-shadow: 0 0 15px rgba(124, 77, 255, 0.5);
        }

        button:not([disabled]), label:not([disabled]) {
            font-weight: 600;
            background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2));
            border: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        button.sub-button, label.sub-button {
            background: var(--light-bg);
            border: 1px solid var(--border-color);
        }
        
        button[disabled], label[disabled] {
            cursor: not-allowed;
            opacity: 0.5;
            background: var(--light-bg);
            border: 1px solid var(--border-color);
        }

        button:hover:not([disabled]), label:hover:not([disabled]) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(124, 77, 255, 0.4);
        }

        .section {
            background: rgba(16, 16, 26, 0.5);
            padding: 20px;
            margin-top: 30px;
            border-radius: 16px;
            border: 1px solid var(--border-color);
        }

        h2 {
            font-size: 1.5rem;
            color: var(--text-color);
            margin-top: 0;
            margin-bottom: 20px;
            font-weight: 600;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }

        .controls-grid {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 16px;
        }
        
        #validation-result, #key-status {
            margin-top: 20px;
            font-size: 14px;
            font-weight: normal;
            min-height: 50px;
            line-height: 1.8;
            text-align: right;
            background: var(--dark-bg);
            padding: 15px 20px;
            border-radius: 12px;
            white-space: pre-wrap;
            font-family: var(--mono-font);
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }

        .valid { color: var(--success-color); }
        .invalid { color: var(--error-color); }
        .info { color: var(--info-color); }
        
        .input-label {
            font-size: 0.9rem;
            color: var(--text-muted);
            margin-left: -10px;
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>Ø§Ø³Ú©Ù†Ø§Ø³ Ø¯ÛŒØ¬ÛŒØªØ§Ù„ Ø§Ù…Ù†</h1>
        <p>ÛŒÚ© Ù…ÙÙ‡ÙˆÙ… Ø§Ø±Ø² Ø¯ÛŒØ¬ÛŒØªØ§Ù„ Ø§Ù…Ù† Ùˆ Ù‚Ø§Ø¨Ù„ ØªØ§ÛŒÛŒØ¯ Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø§Ù…Ø¶Ø§ÛŒ Ù‡ÛŒØ¨Ø±ÛŒØ¯ÛŒ Ed25519 + Falcon-512 Ùˆ Ù¾Ù†Ù‡Ø§Ù†â€ŒÙ†Ú¯Ø§Ø±ÛŒ LSB</p>
    </div>

    <canvas id="noteCanvas" width="1350" height="750"></canvas>

    <div class="section">
        <h2>Ú©Ù†ØªØ±Ù„ Ø§Ø³Ú©Ù†Ø§Ø³</h2>
        <div class="controls-grid">
            <span class="input-label">Ù…Ø¨Ù„Øº:</span>
            <input type="number" id="amount-input" value="50000">
            <button id="create-note-button" disabled>ğŸ¨ Ø·Ø±Ø§Ø­ÛŒ Ø§Ø³Ú©Ù†Ø§Ø³ Ø¬Ø¯ÛŒØ¯</button>
            <button id="download-note-button" disabled>ğŸ“¥ Ø¯Ø§Ù†Ù„ÙˆØ¯ Ø§Ø³Ú©Ù†Ø§Ø³</button>
        </div>
    </div>

    <div class="section">
        <h2>Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ù„ÛŒØ¯ Ø¨Ø§Ù†Ú©</h2>
        <div class="controls-grid">
            <button id="generate-keys-button">ğŸ”‘ ØªÙˆÙ„ÛŒØ¯ Ùˆ Ø°Ø®ÛŒØ±Ù‡ Ú©Ù„ÛŒØ¯Ù‡Ø§</button>
            <label for="import-public-key" class="sub-button">ÙˆØ§Ø±Ø¯ Ú©Ø±Ø¯Ù† Ú©Ù„ÛŒØ¯ Ø¹Ù…ÙˆÙ…ÛŒ</label>
            <input type="file" id="import-public-key" accept=".json" style="display: none;">
            <label for="import-private-key" class="sub-button">ÙˆØ§Ø±Ø¯ Ú©Ø±Ø¯Ù† Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ</label>
            <input type="file" id="import-private-key" accept=".json" style="display: none;">
        </div>
        <div id="key-status">ÙˆØ¶Ø¹ÛŒØª Ú©Ù„ÛŒØ¯Ù‡Ø§ Ø¯Ø± Ø§ÛŒÙ†Ø¬Ø§ Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.</div>
    </div>

    <div class="section" id="validator-section">
        <h2>Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ø§Ø³Ú©Ù†Ø§Ø³</h2>
        <label for="validator-input">Ø§Ù†ØªØ®Ø§Ø¨ ØªØµÙˆÛŒØ± Ø¨Ø±Ø§ÛŒ Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ</label>
        <input type="file" id="validator-input" accept="image/png" style="display: none;">
        <div id="validation-result">Ù†ØªÛŒØ¬Ù‡ Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ø¯Ø± Ø§ÛŒÙ†Ø¬Ø§ Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.</div>
    </div>
</div>


<script type="module" id="crypto-module">
    import nacl from 'https://cdn.skypack.dev/tweetnacl';
    import { shake256 } from 'https://cdn.skypack.dev/js-sha3';
    // falcon.js Ø¨Ø§ÛŒØ¯ Ø¨Ù‡ ØµÙˆØ±Øª Ù…Ø­Ù„ÛŒ Ø¯Ø± Ú©Ù†Ø§Ø± Ø§ÛŒÙ† ÙØ§ÛŒÙ„ HTML ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯.
    import pqcSignFalcon512 from './falcon.js';

    // --- Configuration ---
    const AES_ALGO = "AES-GCM";
    const PBKDF2_ITERATIONS = 100000;
    const PBKDF2_HASH_ALGO = "SHA-256";
    const AES_KEY_LENGTH = 256;

    // --- Helper Functions ---
    const bytesToBase64 = (bytes) => btoa(String.fromCharCode.apply(null, bytes));
    const base64ToBytes = (b64) => new Uint8Array(atob(b64).split("").map(c => c.charCodeAt(0)));
    const hexToBytes = (hex) => new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
    const bytesToHex = (bytes) => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');
    
    // --- Core Functions ---
    export const hashMessage = (msg) => hexToBytes(shake256(msg, 1024));

    let falconApi;
    export async function initializeFalcon() {
        if (!falconApi) {
            falconApi = await pqcSignFalcon512();
        }
        return falconApi;
    }

    export async function generateNewKeyPair() {
        const falcon = await initializeFalcon();
        const ed25519 = nacl.sign.keyPair();
        const falconKeys = await falcon.keypair();
        return {
            publicKeys: { ed25519: ed25519.publicKey, falcon: falconKeys.publicKey },
            privateKeys: { ed25519: ed25519.secretKey, falcon: falconKeys.privateKey }
        };
    }

    export async function signData(data, privateKeys) {
        if (!privateKeys || !privateKeys.ed25519 || !privateKeys.falcon) {
            throw new Error("Ú©Ù„ÛŒØ¯Ù‡Ø§ÛŒ Ø®ØµÙˆØµÛŒ Ø¨Ø±Ø§ÛŒ Ø§Ù…Ø¶Ø§ Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³ØªÙ†Ø¯.");
        }
        const falcon = await initializeFalcon();
        const messageHash = hashMessage(data);
        
        const edSig = nacl.sign.detached(messageHash, privateKeys.ed25519);
        const { signature: falSig } = await falcon.sign(messageHash, privateKeys.falcon);

        return { ed25519Sig: edSig, falconSig: falSig };
    }

    export async function verifySignatures(signatures, data, publicKeys) {
        if (!publicKeys || !publicKeys.ed25519 || !publicKeys.falcon) return false;
        
        const falcon = await initializeFalcon();
        const messageHash = hashMessage(data);

        const edIsValid = nacl.sign.detached.verify(messageHash, signatures.ed25519Sig, publicKeys.ed25519);
        const falIsValid = await falcon.verify(signatures.falconSig, messageHash, publicKeys.falcon);

        return edIsValid && falIsValid;
    }

    // --- Key Encryption/Decryption ---
    export async function encryptKeys(privateKeys, password) {
        const passwordBuffer = new TextEncoder().encode(password);
        const salt = window.crypto.getRandomValues(new Uint8Array(16));
        const iv = window.crypto.getRandomValues(new Uint8Array(12));

        const keyMaterial = await window.crypto.subtle.importKey("raw", passwordBuffer, { name: "PBKDF2" }, false, ["deriveKey"]);
        const derivedKey = await window.crypto.subtle.deriveKey(
            { name: "PBKDF2", salt, iterations: PBKDF2_ITERATIONS, hash: PBKDF2_HASH_ALGO },
            keyMaterial,
            { name: AES_ALGO, length: AES_KEY_LENGTH },
            true,
            ["encrypt"]
        );

        const keysAsJson = JSON.stringify({
            ed25519: bytesToBase64(privateKeys.ed25519),
            falcon: bytesToBase64(privateKeys.falcon),
        });
        const encodedKeys = new TextEncoder().encode(keysAsJson);

        const encryptedData = await window.crypto.subtle.encrypt({ name: AES_ALGO, iv }, derivedKey, encodedKeys);

        return {
            cipherText: bytesToBase64(new Uint8Array(encryptedData)),
            salt: bytesToBase64(salt),
            iv: bytesToBase64(iv),
        };
    }

    export async function decryptKeys(encryptedFile, password) {
        const passwordBuffer = new TextEncoder().encode(password);
        const salt = base64ToBytes(encryptedFile.salt);
        const iv = base64ToBytes(encryptedFile.iv);
        const cipherText = base64ToBytes(encryptedFile.cipherText);

        const keyMaterial = await window.crypto.subtle.importKey("raw", passwordBuffer, { name: "PBKDF2" }, false, ["deriveKey"]);
        const derivedKey = await window.crypto.subtle.deriveKey(
            { name: "PBKDF2", salt, iterations: PBKDF2_ITERATIONS, hash: PBKDF2_HASH_ALGO },
            keyMaterial,
            { name: AES_ALGO, length: AES_KEY_LENGTH },
            true,
            ["decrypt"]
        );
        
        const decryptedData = await window.crypto.subtle.decrypt({ name: AES_ALGO, iv }, derivedKey, cipherText);
        const keysAsJson = new TextDecoder().decode(decryptedData);
        const keys = JSON.parse(keysAsJson);

        return {
            ed25519: base64ToBytes(keys.ed25519),
            falcon: base64ToBytes(keys.falcon)
        };
    }
    
    // --- Key Export/Import Helpers ---
    export function exportPublicKeys(publicKeys) {
        const exportable = {
            ed25519: bytesToBase64(publicKeys.ed25519),
            falcon: bytesToBase64(publicKeys.falcon)
        };
        return JSON.stringify(exportable, null, 2);
    }
    
    export function importPublicKeys(json) {
        const imported = JSON.parse(json);
        if (!imported.ed25519 || !imported.falcon) throw new Error("ÙØ§ÛŒÙ„ Ú©Ù„ÛŒØ¯ Ø¹Ù…ÙˆÙ…ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª.");
        return {
            ed25519: base64ToBytes(imported.ed25519),
            falcon: base64ToBytes(imported.falcon)
        };
    }
</script>

<script type="module" id="steganography-module">
    const MESSAGE_TERMINATOR = "00000000"; // Null character

    function messageToBinary(message) {
        return message.split('').map(char => 
            char.charCodeAt(0).toString(2).padStart(8, '0')
        ).join('') + MESSAGE_TERMINATOR;
    }

    export function encode(ctx, message) {
        const binaryMessage = messageToBinary(message);
        const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
        const data = imageData.data;

        if (binaryMessage.length > (data.length / 4 * 3)) {
            throw new Error("Ù¾ÛŒØ§Ù… Ø¨Ø±Ø§ÛŒ Ù¾Ù†Ù‡Ø§Ù†â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø± ØªØµÙˆÛŒØ± Ø¨ÛŒØ´ Ø§Ø² Ø­Ø¯ Ø·ÙˆÙ„Ø§Ù†ÛŒ Ø§Ø³Øª.");
        }

        let dataIndex = 0;
        for (let i = 0; i < binaryMessage.length; i++) {
            if ((dataIndex + 1) % 4 === 0) { // Skip alpha channel
                dataIndex++;
            }
            const bit = parseInt(binaryMessage[i], 10);
            data[dataIndex] = (data[dataIndex] & 0xFE) | bit; // Set LSB
            dataIndex++;
        }
        ctx.putImageData(imageData, 0, 0);
    }

    export function decode(ctx) {
        const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
        const data = imageData.data;
        let binaryMessage = "";
        let byte = "";

        for (let i = 0; i < data.length; i++) {
            if ((i + 1) % 4 === 0) continue; // Skip alpha
            const lsb = data[i] & 1;
            byte += lsb;
            
            if (byte.length === 8) {
                if (byte === MESSAGE_TERMINATOR) {
                    return binaryMessage;
                }
                binaryMessage += String.fromCharCode(parseInt(byte, 2));
                byte = "";
            }
        }
        return null; // Terminator not found
    }
</script>


<script type="module">
    import * as Crypto from '#crypto-module';
    import * as LSB from '#steganography-module';

    // --- DOM Elements ---
    const dom = {
        canvas: document.getElementById("noteCanvas"),
        amountInput: document.getElementById("amount-input"),
        createNoteBtn: document.getElementById("create-note-button"),
        downloadNoteBtn: document.getElementById("download-note-button"),
        generateKeysBtn: document.getElementById("generate-keys-button"),
        importPublicBtn: document.getElementById("import-public-key"),
        importPrivateBtn: document.getElementById("import-private-key"),
        validatorInput: document.getElementById("validator-input"),
        keyStatus: document.getElementById("key-status"),
        validationResult: document.getElementById("validation-result")
    };

    // --- State ---
    let activeKeys = { publicKeys: null, privateKeys: null };
    let currentNoteData = {};
    const ctx = dom.canvas.getContext("2d");

    // --- Utility ---
    const bytesToBase64 = (bytes) => btoa(String.fromCharCode.apply(null, bytes));

    // --- UI Update Functions ---
    function updateKeyStatus(message, type = 'info') {
        dom.keyStatus.innerHTML = `<span class="${type}">${message}</span>`;
    }

    function updateValidationResult(message, type = 'info') {
        dom.validationResult.innerHTML = `<span class="${type}">${message}</span>`;
    }

    function updateControlsState(hasPrivateKey) {
        dom.createNoteBtn.disabled = !hasPrivateKey;
        dom.downloadNoteBtn.disabled = !hasPrivateKey;
    }

    function downloadFile(data, filename, type) {
        const blob = new Blob([data], { type });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
    
    // --- Key Management Handlers ---
    async function handleGenerateAndExportKeys() {
        const password = prompt("ÛŒÚ© Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ù‚ÙˆÛŒ Ø¨Ø±Ø§ÛŒ Ø±Ù…Ø²Ú¯Ø°Ø§Ø±ÛŒ ÙØ§ÛŒÙ„ Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:");
        if (!password) {
            updateKeyStatus('âŒ Ø¹Ù…Ù„ÛŒØ§Øª Ù„ØºÙˆ Ø´Ø¯. Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª.', 'error');
            return;
        }

        updateKeyStatus('â³ Ø¯Ø± Ø­Ø§Ù„ ØªÙˆÙ„ÛŒØ¯ Ø²ÙˆØ¬ Ú©Ù„ÛŒØ¯ Ø¬Ø¯ÛŒØ¯ Ùˆ Ø±Ù…Ø²Ú¯Ø°Ø§Ø±ÛŒ... Ù„Ø·ÙØ§Ù‹ ØµØ¨Ø± Ú©Ù†ÛŒØ¯.', 'info');
        try {
            const keyPair = await Crypto.generateNewKeyPair();
            activeKeys = keyPair;

            const publicKeysJson = Crypto.exportPublicKeys(keyPair.publicKeys);
            downloadFile(publicKeysJson, 'bank-public-keys.json', 'application/json');

            const encryptedPrivate = await Crypto.encryptKeys(keyPair.privateKeys, password);
            downloadFile(JSON.stringify(encryptedPrivate, null, 2), 'bank-private-keys.json', 'application/json');

            updateKeyStatus('âœ… Ø²ÙˆØ¬ Ú©Ù„ÛŒØ¯ Ø¬Ø¯ÛŒØ¯ ØªÙˆÙ„ÛŒØ¯ Ùˆ Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯! Ú©Ù„ÛŒØ¯Ù‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ Ø§Ú©Ù†ÙˆÙ† ÙØ¹Ø§Ù„ Ù‡Ø³ØªÙ†Ø¯.', 'valid');
            updateControlsState(true);
            await handleCreateNewNote();
        } catch (e) {
            console.error(e);
            updateKeyStatus(`âŒ Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ú©Ù„ÛŒØ¯: ${e.message}`, 'error');
        }
    }

    async function handleImportPublicKeys(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                activeKeys.publicKeys = Crypto.importPublicKeys(e.target.result);
                updateKeyStatus('âœ… Ú©Ù„ÛŒØ¯ Ø¹Ù…ÙˆÙ…ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ÙˆØ§Ø±Ø¯ Ùˆ Ø¨Ø±Ø§ÛŒ Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ ÙØ¹Ø§Ù„ Ø´Ø¯.', 'valid');
            } catch (error) {
                updateKeyStatus(`âŒ Ø®Ø·Ø§ Ø¯Ø± ÙˆØ§Ø±Ø¯ Ú©Ø±Ø¯Ù† Ú©Ù„ÛŒØ¯ Ø¹Ù…ÙˆÙ…ÛŒ: ${error.message}`, 'error');
            }
        };
        reader.readAsText(file);
    }

    async function handleImportPrivateKeys(event) {
        const file = event.target.files[0];
        if (!file) return;
        const password = prompt("Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ÙØ§ÛŒÙ„ Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ø±Ù…Ø²Ú¯Ø´Ø§ÛŒÛŒ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:");
        if (!password) {
            updateKeyStatus('âŒ Ø¹Ù…Ù„ÛŒØ§Øª Ù„ØºÙˆ Ø´Ø¯. Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ø±Ø§ÛŒ Ø±Ù…Ø²Ú¯Ø´Ø§ÛŒÛŒ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª.', 'error');
            return;
        }
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const encryptedData = JSON.parse(e.target.result);
                updateKeyStatus('â³ Ø¯Ø± Ø­Ø§Ù„ Ø±Ù…Ø²Ú¯Ø´Ø§ÛŒÛŒ Ùˆ ÙˆØ§Ø±Ø¯ Ú©Ø±Ø¯Ù† Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ...', 'info');
                const privateKeys = await Crypto.decryptKeys(encryptedData, password);
                activeKeys.privateKeys = privateKeys;
                updateKeyStatus('âœ… Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ÙˆØ§Ø±Ø¯ Ùˆ Ø¨Ø±Ø§ÛŒ Ø§Ù…Ø¶Ø§ÛŒ Ø§Ø³Ú©Ù†Ø§Ø³ ÙØ¹Ø§Ù„ Ø´Ø¯.', 'valid');
                updateControlsState(true);
            } catch (error) {
                updateKeyStatus(`âŒ Ø®Ø·Ø§ Ø¯Ø± Ø±Ù…Ø²Ú¯Ø´Ø§ÛŒÛŒ Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ. Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ÛŒØ§ ÙØ§ÛŒÙ„ Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯.`, 'error');
            }
        };
        reader.readAsText(file);
    }

    // --- Banknote Creation Logic ---
    function getStandardizedDataForSigning(noteData) {
        const dataToSign = {
            amount: noteData.amount,
            serial: noteData.serial,
            timestamp: noteData.timestamp,
        };
        return JSON.stringify(dataToSign, Object.keys(dataToSign).sort());
    }

    async function createNoteData(amount) {
        if (!activeKeys.privateKeys) {
            alert("Ø®Ø·Ø§: Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ Ø¨Ø±Ø§ÛŒ Ø§Ù…Ø¶Ø§ÛŒ Ø§Ø³Ú©Ù†Ø§Ø³ ÙØ¹Ø§Ù„ Ù†ÛŒØ³Øª.");
            return null;
        }
        const timestamp = Date.now();
        const noteData = {
            amount: parseInt(amount) || 0,
            serial: "SDB-" + timestamp.toString().slice(-8) + Math.random().toString(16).substring(2, 6).toUpperCase(),
            timestamp: timestamp,
            signatures: null,
            visualHash: null
        };

        const stringToSign = getStandardizedDataForSigning(noteData);
        noteData.signatures = await Crypto.signData(stringToSign, activeKeys.privateKeys);
        
        const combinedSigsForHash = bytesToBase64(noteData.signatures.ed25519Sig) + bytesToBase64(noteData.signatures.falconSig);
        noteData.visualHash = new TextDecoder().decode(Crypto.hashMessage(combinedSigsForHash));

        return noteData;
    }

    async function handleCreateNewNote() {
        const amount = dom.amountInput.value;
        updateKeyStatus('â³ Ø¯Ø± Ø­Ø§Ù„ Ø·Ø±Ø§Ø­ÛŒ Ø§Ø³Ú©Ù†Ø§Ø³ Ø¬Ø¯ÛŒØ¯...', 'info');
        const noteData = await createNoteData(amount);
        if (noteData) {
            currentNoteData = noteData;
            await drawNoteOnCanvas(dom.canvas, currentNoteData, true);
            updateKeyStatus('âœ… Ø§Ø³Ú©Ù†Ø§Ø³ Ø¬Ø¯ÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ Ø¢Ù…Ø§Ø¯Ù‡ Ø§Ø³Øª.', 'valid');
        } else {
            updateKeyStatus('âŒ ØªÙˆÙ„ÛŒØ¯ Ø§Ø³Ú©Ù†Ø§Ø³ Ø¬Ø¯ÛŒØ¯ Ø¨Ø§ Ø´Ú©Ø³Øª Ù…ÙˆØ§Ø¬Ù‡ Ø´Ø¯.', 'error');
        }
    }
    
    function handleDownloadNote() {
        if (!currentNoteData.serial) {
            alert("Ø§Ø¨ØªØ¯Ø§ ÛŒÚ© Ø§Ø³Ú©Ù†Ø§Ø³ Ø·Ø±Ø§Ø­ÛŒ Ú©Ù†ÛŒØ¯.");
            return;
        }
        const link = document.createElement("a");
        link.download = `SDB-NOTE-${currentNoteData.serial}.png`;
        link.href = dom.canvas.toDataURL("image/png");
        link.click();
    }


    // --- Banknote Validation Logic ---
    async function handleFileSelectForValidation(event) {
        const file = event.target.files[0];
        if (!file) return;

        if (!activeKeys.publicKeys) {
            alert("Ø®Ø·Ø§: Ù‡ÛŒÚ† Ú©Ù„ÛŒØ¯ Ø¹Ù…ÙˆÙ…ÛŒ Ø¨Ø±Ø§ÛŒ Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ ÙØ¹Ø§Ù„ Ù†ÛŒØ³Øª. Ù„Ø·ÙØ§Ù‹ ÛŒÚ© Ú©Ù„ÛŒØ¯ ØªÙˆÙ„ÛŒØ¯ ÛŒØ§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.");
            return;
        }
        
        let resultHTML = '';
        const addResult = (msg, type) => { 
            resultHTML += `<span class="${type}">${msg}</span>\n`;
            dom.validationResult.innerHTML = resultHTML;
        };

        addResult('â³ Ø¯Ø± Ø­Ø§Ù„ Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ ØªØµÙˆÛŒØ± Ø¨Ø±Ø§ÛŒ Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ...', 'info');

        const img = new Image();
        img.src = URL.createObjectURL(file);
        img.onload = async () => {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = 1350;
            tempCanvas.height = 750;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);

            // 1. Read QR Code
            addResult('1. Ø¯Ø± Ø­Ø§Ù„ Ø®ÙˆØ§Ù†Ø¯Ù† Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¯ÛŒØ¬ÛŒØªØ§Ù„ Ø§Ø² Ú©Ø¯ QR...', 'info');
            const qrData = readQRCodeFromCanvas(tempCanvas);
            if (!qrData) {
                addResult('âŒ Ø®Ø·Ø§ÛŒ Ø­ÛŒØ§ØªÛŒ: Ú©Ø¯ QR ÛŒØ§ÙØª Ù†Ø´Ø¯ ÛŒØ§ ØºÛŒØ±Ù‚Ø§Ø¨Ù„ Ø®ÙˆØ§Ù†Ø¯Ù† Ø§Ø³Øª. Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ù…ØªÙˆÙ‚Ù Ø´Ø¯.', 'invalid');
                return;
            }
            addResult('âœ… Û±. Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ QR Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø®ÙˆØ§Ù†Ø¯Ù‡ Ø´Ø¯.', 'valid');

            // 2. Verify Digital Signatures
            addResult('2. Ø¯Ø± Ø­Ø§Ù„ ØªØ§ÛŒÛŒØ¯ Ø§Ù…Ø¶Ø§Ù‡Ø§ÛŒ Ø¯ÛŒØ¬ÛŒØªØ§Ù„ (Ed25519 + Falcon-512)...', 'info');
            // Reconstruct signatures from Base64
            qrData.signatures.ed25519Sig = base64ToBytes(qrData.signatures.ed25519Sig.data);
            qrData.signatures.falconSig = base64ToBytes(qrData.signatures.falconSig.data);
            
            const stringToVerify = getStandardizedDataForSigning(qrData);
            const isSignatureValid = await Crypto.verifySignatures(qrData.signatures, stringToVerify, activeKeys.publicKeys);

            if (!isSignatureValid) {
                addResult('âŒ Ø®Ø·Ø§ÛŒ Ø­ÛŒØ§ØªÛŒ: Ø§Ù…Ø¶Ø§ÛŒ Ø¯ÛŒØ¬ÛŒØªØ§Ù„ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª. Ø§Ø³Ú©Ù†Ø§Ø³ Ø¬Ø¹Ù„ÛŒ ÛŒØ§ Ø¯Ø³ØªÚ©Ø§Ø±ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª.', 'invalid');
                return;
            }
            addResult('âœ… Û². Ø§Ù…Ø¶Ø§Ù‡Ø§ÛŒ Ø¯ÛŒØ¬ÛŒØªØ§Ù„ ØªØ§ÛŒÛŒØ¯ Ø´Ø¯. Ø§ØµØ§Ù„Øª Ø§Ø³Ú©Ù†Ø§Ø³ ØªÙˆØ³Ø· Ú©Ù„ÛŒØ¯ Ø¹Ù…ÙˆÙ…ÛŒ Ø¨Ø§Ù†Ú© ØªØ§ÛŒÛŒØ¯ Ù…ÛŒâ€ŒØ´ÙˆØ¯.', 'valid');

            // 3. Verify LSB Steganography
            addResult('3. Ø¯Ø± Ø­Ø§Ù„ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ùˆ ØªØ§ÛŒÛŒØ¯ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù¾Ù†Ù‡Ø§Ù†â€ŒØ´Ø¯Ù‡ (LSB)...', 'info');
            const decodedLSBData = LSB.decode(tempCtx);
            const expectedLSBData = bytesToBase64(qrData.signatures.ed25519Sig) + bytesToBase64(qrData.signatures.falconSig);
            
            if (!decodedLSBData || decodedLSBData !== expectedLSBData) {
                addResult('âŒ Ø®Ø·Ø§ÛŒ Ø­ÛŒØ§ØªÛŒ: Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù¾Ù†Ù‡Ø§Ù†â€ŒØ´Ø¯Ù‡ Ø¯Ø± ØªØµÙˆÛŒØ± Ø¨Ø§ Ø§Ù…Ø¶Ø§ Ù…Ø·Ø§Ø¨Ù‚Øª Ù†Ø¯Ø§Ø±Ø¯. ØªØµÙˆÛŒØ± Ø§Ø³Ú©Ù†Ø§Ø³ ØªØºÛŒÛŒØ± Ú©Ø±Ø¯Ù‡ Ø§Ø³Øª.', 'invalid');
                return;
            }
            addResult('âœ… Û³. Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù¾Ù†Ù‡Ø§Ù†â€ŒØ´Ø¯Ù‡ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ùˆ ØªØ§ÛŒÛŒØ¯ Ø´Ø¯. ÛŒÚ©Ù¾Ø§Ø±Ú†Ú¯ÛŒ ØªØµÙˆÛŒØ± ØªØ§ÛŒÛŒØ¯ Ù…ÛŒâ€ŒØ´ÙˆØ¯.', 'valid');

            // --- FINAL VERDICT ---
            resultHTML += `<hr style="border-color: var(--border-color); margin: 15px 0;">\n<strong class="valid">âœ… Ø±Ø£ÛŒ Ù†Ù‡Ø§ÛŒÛŒ: Ø§Ø³Ú©Ù†Ø§Ø³ Ù…Ø¹ØªØ¨Ø± Ùˆ Ø§ØµÛŒÙ„ Ø§Ø³Øª.</strong>`;
            dom.validationResult.innerHTML = resultHTML;
        };
    }
    
    const base64ToBytes = (b64) => new Uint8Array(atob(b64).split("").map(c => c.charCodeAt(0)));

    function readQRCodeFromCanvas(canvas) {
        const context = canvas.getContext('2d');
        const qrRegion = { x: 800, y: 210, width: 420, height: 420 };
        const imageData = context.getImageData(qrRegion.x, qrRegion.y, qrRegion.width, qrRegion.height);
        try {
            const code = jsQR(imageData.data, imageData.width, imageData.height);
            return code ? JSON.parse(code.data) : null;
        } catch {
            return null;
        }
    }


    // --- Drawing Logic ---
    function H(text, index, min, max) { return min + (text.charCodeAt(index % text.length) % (max - min + 1)); }

    async function drawNoteOnCanvas(targetCanvas, noteData, applySteganography = true) {
        if (Object.keys(noteData).length === 0) return;

        const g_ctx = targetCanvas.getContext("2d");
        const { amount, serial, visualHash, signatures } = noteData;
        const w = targetCanvas.width;
        const h = targetCanvas.height;
        const scale = w / 1350;

        const bgGradient = g_ctx.createLinearGradient(0, 0, 0, h);
        const baseHue = H(visualHash, 0, 0, 360);
        bgGradient.addColorStop(0, `hsl(${baseHue}, 50%, 6%)`);
        bgGradient.addColorStop(1, `hsl(${baseHue}, 40%, 4%)`);
        g_ctx.fillStyle = bgGradient;
        g_ctx.fillRect(0, 0, w, h);
        
        drawWatermark(g_ctx, visualHash, w, h);
        drawGuilloche(g_ctx, visualHash, w, h);

        g_ctx.shadowColor = "rgba(0, 0, 0, 0.7)";
        g_ctx.shadowBlur = 8 * scale;
        g_ctx.shadowOffsetX = 2 * scale;
        g_ctx.shadowOffsetY = 2 * scale;
        g_ctx.fillStyle = "#EAEAEA";
        g_ctx.font = `bold ${90 * scale}px 'Roboto Mono'`;
        g_ctx.textAlign = 'right';
        g_ctx.fillText(serial.substring(4), w - 150 * scale, 160 * scale);
        
        g_ctx.font = `bold ${150 * scale}px 'Roboto Mono'`;
        g_ctx.textAlign = "left";
        g_ctx.shadowBlur = 12 * scale;
        g_ctx.fillText(amount.toLocaleString('fa-IR'), 120 * scale, 190 * scale);
        g_ctx.shadowColor = "transparent";

        // To make signatures JSON serializable for QR code, we convert buffers to a format JSON likes
        const serializableNoteData = { ...noteData };
        serializableNoteData.signatures.ed25519Sig = { type: 'Buffer', data: Array.from(serializableNoteData.signatures.ed25519Sig) };
        serializableNoteData.signatures.falconSig = { type: 'Buffer', data: Array.from(serializableNoteData.signatures.falconSig) };
        const qrDataString = JSON.stringify(serializableNoteData);

        const qrCanvas = document.createElement("canvas");
        await QRCode.toCanvas(qrCanvas, qrDataString, { width: 420 * scale, errorCorrectionLevel: 'H', color: { dark: '#000000', light: '#FFFFFF' } });
        g_ctx.drawImage(qrCanvas, 800 * scale, 210 * scale, 420 * scale, 420 * scale);
        
        if (applySteganography && signatures) {
            try {
                const combinedSigs = bytesToBase64(signatures.ed25519Sig) + bytesToBase64(signatures.falconSig);
                LSB.encode(g_ctx, combinedSigs);
            } catch (lsbError) {
                console.error("LSB Encoding Error:", lsbError);
            }
        }
    }
    
    function drawGuilloche(g_ctx, hash, w, h) {
        g_ctx.save();
        g_ctx.translate(w / 2, h / 2);
        const scale = w / 1350;
        const numLines = H(hash, 2, 8, 15);
        const hueOffset = H(hash, 10, 0, 360);
        g_ctx.lineWidth = 1.5 * scale;

        for (let i = 0; i < numLines; i++) {
            const hue = (hueOffset + i * (360 / numLines)) % 360;
            g_ctx.strokeStyle = `hsla(${hue}, 70%, 50%, 0.18)`;
            const R1 = w * (H(hash, i+4, 10, 40)/100);
            const R2 = w * (H(hash, i+5, 10, 40)/100);
            const f1 = H(hash, i+6, 1, 12);
            const f2 = H(hash, i+7, 1, 12);
            const p1 = H(hash, i+8, 0, 10);
            const p2 = H(hash, i+9, 0, 10);
            
            g_ctx.beginPath();
            for (let t = 0; t < 2 * Math.PI; t+= 0.01) {
                const x = (R1 + R2) * Math.cos(t) - R2 * Math.cos(((R1+R2)/R2)*t);
                const y = (R1 + R2) * Math.sin(t) - R2 * Math.sin(((R1+R2)/R2)*t);
                if (t === 0) g_ctx.moveTo(x,y); else g_ctx.lineTo(x,y);
            }
            g_ctx.stroke();
        }
        g_ctx.restore();
    }

    function drawWatermark(g_ctx, hash, w, h) {
        g_ctx.save();
        g_ctx.translate(w / 2, h / 2);
        const scale = w / 1350;
        const numSpirals = H(hash, 16, 3, 6);
        const spiralRadius = w * (H(hash, 18, 10, 25) / 100) * scale;
        const hue = H(hash, 20, 0, 360);
        g_ctx.strokeStyle = `hsla(${hue}, 50%, 80%, 0.05)`;
        g_ctx.lineWidth = 4 * scale;
        for (let i = 0; i < numSpirals; i++) {
            g_ctx.beginPath();
            const startAngle = (i / numSpirals) * Math.PI * 2;
            const endAngle = startAngle + H(hash, 24, 6, 12) * Math.PI;
            for (let t = startAngle; t < endAngle; t += 0.05) {
                const r = spiralRadius * (t - startAngle) / (endAngle - startAngle);
                const x = r * Math.cos(t);
                const y = r * Math.sin(t);
                if (t === startAngle) g_ctx.moveTo(x, y); else g_ctx.lineTo(x, y);
            }
            g_ctx.stroke();
        }
        g_ctx.restore();
    }


    // --- Initialization ---
    window.onload = async () => {
        try {
            updateKeyStatus('â³ Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§ÛŒ Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ...', 'info');
            await Crypto.initializeFalcon();
            updateKeyStatus('Ø¢Ù…Ø§Ø¯Ù‡. Ù„Ø·ÙØ§Ù‹ ÛŒÚ© Ø²ÙˆØ¬ Ú©Ù„ÛŒØ¯ Ø¬Ø¯ÛŒØ¯ ØªÙˆÙ„ÛŒØ¯ Ú©Ø±Ø¯Ù‡ ÛŒØ§ Ú©Ù„ÛŒØ¯Ù‡Ø§ÛŒ Ù…ÙˆØ¬ÙˆØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.', 'info');
        } catch (e) {
            updateKeyStatus(`âŒ Ø®Ø·Ø§ÛŒ Ø­ÛŒØ§ØªÛŒ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù…Ø§Ú˜ÙˆÙ„ Falcon: ${e.message}. ØµÙØ­Ù‡ Ø±Ø§ Ù…Ø¬Ø¯Ø¯Ø§Ù‹ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ú©Ù†ÛŒØ¯.`, 'error');
            console.error(e);
        }
        updateControlsState(false);
    };
    
    dom.generateKeysBtn.addEventListener('click', handleGenerateAndExportKeys);
    dom.importPublicBtn.addEventListener('change', handleImportPublicKeys);
    dom.importPrivateBtn.addEventListener('change', handleImportPrivateKeys);
    dom.createNoteBtn.addEventListener('click', handleCreateNewNote);
    dom.downloadNoteBtn.addEventListener('click', handleDownloadNote);
    dom.validatorInput.addEventListener('change', handleFileSelectForValidation);

</script>
</body>
</html>
