<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <title>Sadat Digital Banknote - QR Code System</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator/qrcode.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>

    <style>
        :root {
            --primary-font: 'Poppins', 'Segoe UI', sans-serif;
--mono-font: 'Roboto Mono', monospace;
            --dark-bg: #10101a;
            --medium-bg: #1a1a2e;
            --light-bg: #2a2a3e;
            --accent-color-1: #e040fb;
            --accent-color-2: #7c4dff;
            --text-color: #e0e0e0;
            --text-muted: #a0a0c0;
            --success-color: #00e676;
--error-color: #ff5252;
            --info-color: #40c4ff;
            --warning-color: #ffab40;
            --border-color: rgba(124, 77, 255, 0.2);
}
        body { 
            margin: 0;
font-family: var(--primary-font); 
            background-color: var(--dark-bg); 
            background-image: radial-gradient(at 0% 0%, hsla(253, 100%, 15%, 0.3) 0px, transparent 50%), radial-gradient(at 100% 100%, hsla(263, 100%, 20%, 0.3) 0px, transparent 50%);
color: var(--text-color); 
            text-align: center; 
            padding: 24px; 
        }
        .container { max-width: 1200px;
margin: 0 auto; background: rgba(26, 26, 46, 0.7); backdrop-filter: blur(12px); padding: 24px; border-radius: 24px; border: 1px solid var(--border-color);
box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2); }
        .header { border-bottom: 1px solid var(--border-color);
padding-bottom: 16px; margin-bottom: 24px; }
        h1 { font-size: 2.5rem; font-weight: 600; color: #fff;
margin: 0 0 8px 0; letter-spacing: 1px; background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
}
        .header p { font-size: 1rem; color: var(--text-muted); margin: 0;
}
        canvas#noteCanvas { border-radius: 16px; margin-top: 24px; background: #050508; cursor: default;
box-shadow: 0 0 50px rgba(124, 77, 255, 0.15); width: 100%; max-width: 790px; height: auto; border: 1px solid var(--border-color);
}
        input, button, label { padding: 14px 22px; font-size: 16px; font-family: var(--primary-font);
border-radius: 12px; margin: 8px 5px; border: 1px solid var(--border-color); background: var(--medium-bg); color: #fff; transition: all 0.3s ease; cursor: pointer;
outline: none; display: inline-flex; align-items: center; justify-content: center; gap: 8px;
}
        input[type="number"], input[type="password"] { font-family: var(--mono-font); font-weight: 700; text-align: center; width: 150px;
}
        input:focus { border-color: var(--accent-color-2); box-shadow: 0 0 15px rgba(124, 77, 255, 0.5);
}
        button:not([disabled]), label.button:not([disabled]) { font-weight: 600; background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); border: none;
box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        button.sub-button, label.button.sub-button { background: var(--light-bg);
border: 1px solid var(--border-color); }
        button[disabled], label.button[disabled] { cursor: not-allowed; opacity: 0.5;
background: var(--light-bg); border: 1px solid var(--border-color); }
        button:hover:not([disabled]), label.button:hover:not([disabled]) { transform: translateY(-2px);
box-shadow: 0 6px 20px rgba(124, 77, 255, 0.4); }
        .section { background: rgba(16, 16, 26, 0.5);
padding: 20px; margin-top: 30px; border-radius: 16px; border: 1px solid var(--border-color);
}
        h2 { font-size: 1.5rem; color: var(--text-color); margin-top: 0; margin-bottom: 20px; font-weight: 600;
border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        .controls-grid { display: flex; justify-content: center;
align-items: center; flex-wrap: wrap; gap: 16px; }
        .status-box { margin-top: 20px; font-size: 13px;
font-weight: normal; min-height: 50px; line-height: 1.6; text-align: left; background: var(--dark-bg); padding: 15px 20px; border-radius: 12px; white-space: pre-wrap; font-family: var(--mono-font);
border: 1px solid var(--border-color); transition: all 0.3s ease; }
        .valid { color: var(--success-color);
} .invalid { color: var(--error-color); } .info { color: var(--info-color); } .warning { color: var(--warning-color);
}
        code { background: var(--medium-bg); padding: 2px 6px; border-radius: 4px; font-size: 1em;
}
        .input-label { font-size: 0.9rem; color: var(--text-muted); margin-right: -10px;
}
        .modal { position: fixed; z-index: 100; left: 0; top: 0; width: 100%;
height: 100%; overflow: auto; background-color: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center;
}
        .modal-content { background-color: var(--medium-bg); padding: 30px; border: 1px solid var(--border-color); width: 80%;
max-width: 500px; border-radius: 16px; text-align: center; }
        #jab-display { margin: 20px auto;
background: white; padding: 15px; border-radius: 8px; width: fit-content; }
        #jab-display img { max-width: 100%;
height: auto; }
        .pill { background-color: var(--border-color); color: var(--accent-color-1); padding: 5px 15px;
border-radius: 20px; font-size: 14px; font-weight: 600; margin: 5px; display: inline-block;
}
    </style>
</head>
<body>
<div class="container">
    <div class="header"><h1>Sadat Digital Banknote</h1><p>A Quantum-Resistant, Offline, Dual-Signature & <strong>Multi-QR-Code</strong> Digital Currency System.</p></div>
    <div class="section"><h2><span class="pill">Step 1</span> Guardian Setup: Create Master Keys</h2><div class="controls-grid"><button id="generate-keys-button">üîë Generate Master Key Pair</button><label for="import-public-key" class="button sub-button"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg> Load Public Key</label><input type="file" id="import-public-key" accept=".json" style="display: none;"></div><div id="key-gen-status" class="status-box"><span class="info">‚ÑπÔ∏è Welcome, Guardian.
Generate a new Master Key Pair to begin your financial ecosystem.
This process is fully offline and secure.</span></div></div>
    <div class="section"><h2><span class="pill">Step 2</span> Activate System: Reconstruct Private Key</h2><p style="color: var(--text-muted); font-size: 0.9em; max-width: 700px; margin: -10px auto 20px auto;">To create banknotes, you must prove your identity by solving the "Three-Piece Puzzle".
This ensures maximum security.</p><div class="controls-grid"><label for="file-key-input" class="button sub-button">1. Upload File Key</label><input type="file" id="file-key-input" accept=".json" style="display:none;"
/><input type="password" id="password-key-input" placeholder="2. Enter Password Key"><label for="visual-key-input" class="button sub-button">3. Upload Visual Key (QR)</label><input type="file" id="visual-key-input" accept="image/png, image/jpeg" style="display:none;"
/></div><button id="reconstruct-key-button" disabled style="margin-top: 20px;">üîì Activate Master Private Key</button><div id="key-reconstruction-status" class="status-box"><span class="warning">‚ö†Ô∏è Master Private Key is INACTIVE.
Solve the puzzle to activate.</span></div></div>
    <div class="section"><h2><span class="pill">Step 3</span> Create Wealth: Generate Banknotes</h2><div class="controls-grid"><span class="input-label">Amount:</span><input type="number" id="amount-input" value="50000"><span class="input-label">Quantity:</span><input type="number" id="quantity-input" value="1" min="1" max="100"><button id="create-note-button" disabled>üé® Create & Display Banknote</button><button id="download-batch-button" disabled>üì• Download Batch</button></div><div id="banknote-status" class="status-box">Use the controls above to create and sign new banknotes.</div><canvas id="noteCanvas" width="790" height="790"></canvas></div>
    <div class="section" id="validator-section"><h2><span class="pill">Step 4</span> Verify Authenticity</h2><p style="color: var(--text-muted); font-size: 0.9em; max-width: 700px; margin: -10px auto 20px auto;">To verify a banknote, upload a clear picture of the <strong>entire banknote</strong>.
The system will find and validate all QR Codes.</p><label for="validator-input" class="button"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 15 17 10"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg> Select Banknote Image for Validation</label><input type="file" id="validator-input" accept="image/png, image/jpeg" style="display: none;"><div id="validation-result" class="status-box">Awaiting banknote for validation...</div></div>
</div>
<div id="jab-modal" class="modal"><div class="modal-content"><h2 id="jab-modal-title">Your Visual Key</h2><p>Print this QR Code or save the image file and store it in a secure physical location.
It is the third piece of your Master Key puzzle.</p><div id="jab-display"></div><button id="download-jab-button" style="margin-top: 15px;">üíæ Download QR Code</button><button onclick="document.getElementById('jab-modal').style.display='none'">Close</button></div></div>

<script type="module">
// --- DEPENDENCIES ---
import pqcSignFalcon1024 from './pqc-sign-falcon-1024.min.js';
import { shake256 } from 'https://cdn.skypack.dev/js-sha3';

// --- Global State ---
const state = {
    falconApi: null,
    masterPublicKey: null,
    masterPrivateKey: null,
    puzzlePieces: { fileKey: null, passwordKey: null, visualKey: null }
};
// --- CONSTANTS ---
const Constants = {
    FALCON_PUBKEY_SIZE: 1793,
    EPOCH: new Date('2024-01-01T00:00:00Z').getTime(),
    VALIDATION_PREFIX: "SADAT_V2_PART",
    NUM_QR_CODES: 9, 
    MAX_IMAGE_DIMENSION: 2000
};
// --- DOM Elements ---
const DOMElements = {
    generateKeysButton: document.getElementById('generate-keys-button'),
    importPublicKey: document.getElementById('import-public-key'),
    keyGenStatus: document.getElementById('key-gen-status'),
    fileKeyInput: document.getElementById('file-key-input'),
    passwordKeyInput: document.getElementById('password-key-input'),
    visualKeyInput: document.getElementById('visual-key-input'),
    reconstructKeyButton: document.getElementById('reconstruct-key-button'),
    keyReconstructionStatus: document.getElementById('key-reconstruction-status'),
    amountInput: document.getElementById('amount-input'),
    quantityInput: document.getElementById('quantity-input'),
    createNoteButton: document.getElementById('create-note-button'),
    downloadBatchButton: document.getElementById('download-batch-button'),
    noteCanvas: document.getElementById('noteCanvas'),
    banknoteStatus: document.getElementById('banknote-status'),
    validatorInput: document.getElementById('validator-input'),
    validationResult: document.getElementById('validation-result'),
    jabModal: document.getElementById('jab-modal'),
    jabDisplay: document.getElementById('jab-display'),
   
 jabModalTitle: document.getElementById('jab-modal-title'),
    downloadJabButton: document.getElementById('download-jab-button')
};

// --- Utility Functions ---
const Utils = {
    arrayBufferToBase64: (buffer) => btoa(String.fromCharCode(...new Uint8Array(buffer))),
    base64ToUint8Array: (base64) => {
        const binaryString = atob(base64);
const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i);
return bytes;
    },
    hexToUint8Array: (hex) => new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16))),
    downloadFile: (data, filename, type) => {
        const blob = new Blob([data], { type });
const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = filename;
        document.body.appendChild(a); a.click();
        document.body.removeChild(a); URL.revokeObjectURL(url);
},
    updateStatus: (element, message, type = 'info') => {
        element.innerHTML = `<span class="${type}">${message}</span>`;
},
    log: (message, type = 'info') => {
        const icon = { info: '‚ÑπÔ∏è', success: '‚úÖ', warning: '‚ö†Ô∏è', error: '‚ùå' }[type];
console.log(`[Sadat System] ${icon} ${message}`);
    },
    async preprocessImage(dataUrl) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
        
        canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.filter = 'grayscale(1) contrast(2.5) brightness(1.1)';
                ctx.drawImage(img, 0, 0);
                resolve(canvas.toDataURL('image/jpeg'));
            };
     
       img.onerror = reject;
            img.src = dataUrl;
        });
},
    async resizeImage(file, maxSize) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            const reader = new FileReader();
            reader.onload = (e) => {
                img.onload = () => {
            
        const canvas = document.createElement('canvas');
                    let { width, height } = img;
                    if (width > height) {
                        if (width > maxSize) {
           
                 height *= maxSize / width;
                            width = maxSize;
                        }
                    } else {
   
                     if (height > maxSize) {
                            width *= maxSize / height;
                            height = maxSize;
             
           }
                    }
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
  
                  ctx.drawImage(img, 0, 0, width, height);
resolve(canvas.toDataURL('image/jpeg'));
                };
                img.onerror = reject;
                img.src = e.target.result;
            };
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });
},
    async createQrCodeImage(payload, asPngDataUrl = false) {
        const qr = qrcode(0, 'L');
qr.addData(payload);
        qr.make();
        const gifDataUrl = qr.createDataURL(10, 5);

        if (!asPngDataUrl) {
            const img = new Image();
img.src = gifDataUrl;
            await new Promise((resolve, reject) => { img.onload = resolve; img.onerror = reject; });
            return img;
} else {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                  
  canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    resolve(canvas.toDataURL('image/png'));
         
       };
                img.onerror = reject;
                img.src = gifDataUrl;
            });
}
    },
    async decodeQrCodeFromImage(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
    
            canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
         
       const code = jsQR(imageData.data, imageData.width, imageData.height);
                if (code) {
                    resolve(code.data);
                } else {
                    reject(new Error("QR Code not found."));
        
        }
            };
            img.src = event.target.result;
        };
        reader.onerror = () => reject(new Error("FileReader failed."));
        reader.readAsDataURL(file);
});
    }
};

// --- CORE CRYPTO ENGINE (Unchanged) ---
const BankCrypto = (() => {
    const AES_ALGO = "AES-GCM";
    const PBKDF2_ITERATIONS = 100000;
    const PBKDF2_KEY_LENGTH = 32;
    async function pbkdf2DeriveKey(password, salt) {
        const passwordBuffer = new TextEncoder().encode(password);
        const importedKey = await crypto.subtle.importKey("raw", passwordBuffer, { name: "PBKDF2" }, false, ["deriveKey"]);
        return await crypto.subtle.deriveKey({ name: "PBKDF2", salt: salt, iterations: PBKDF2_ITERATIONS, hash: "SHA-256" }, importedKey, { name: AES_ALGO, length: 256 }, 
false, ["encrypt", "decrypt"]);
    }
    function hashMessageForSigning(message) { return Utils.hexToUint8Array(shake256(message, 1536)); }
    return {
        async generateNewKeyPair() {
            if (!state.falconApi) throw new Error("Falcon API not initialized.");
            return state.falconApi.keypair();
        },
        async signData(data, privateKey) {
            if (!privateKey || !state.falconApi) throw new 
Error("Signing prerequisites not met.");
            const dataHash = hashMessageForSigning(data);
            const { signature } = await state.falconApi.sign(dataHash, privateKey);
            return signature;
},
        async verifySignature(signature, data, publicKey) {
            if (!publicKey || !state.falconApi) throw new Error("Verification prerequisites not met.");
const dataHash = hashMessageForSigning(data);
            return state.falconApi.verify(signature, dataHash, publicKey);
        },
        async encryptMasterKey(masterPrivateKeyBytes, passwordKey, visualKeySecret) {
            const visualKeySalt = crypto.getRandomValues(new Uint8Array(16));
const visualKeyIV = crypto.getRandomValues(new Uint8Array(12));
            const cryptoVisualKey = await pbkdf2DeriveKey(visualKeySecret, visualKeySalt);
const encryptedWithVisual = await crypto.subtle.encrypt({ name: AES_ALGO, iv: visualKeyIV }, cryptoVisualKey, masterPrivateKeyBytes);
const intermediatePayload = JSON.stringify({ encryptedKey: Utils.arrayBufferToBase64(encryptedWithVisual), salt: Utils.arrayBufferToBase64(visualKeySalt), iv: Utils.arrayBufferToBase64(visualKeyIV) });
            const passwordSalt = crypto.getRandomValues(new Uint8Array(16));
const passwordIV = crypto.getRandomValues(new Uint8Array(12));
            const cryptoPasswordKey = await pbkdf2DeriveKey(passwordKey, passwordSalt);
const finalEncryptedKey = await crypto.subtle.encrypt({ name: AES_ALGO, iv: passwordIV }, cryptoPasswordKey, new TextEncoder().encode(intermediatePayload));
return { fileKey: { cipherText: Utils.arrayBufferToBase64(finalEncryptedKey), salt: Utils.arrayBufferToBase64(passwordSalt), iv: Utils.arrayBufferToBase64(passwordIV) } };
},
        async reconstructMasterKey(fileKey, passwordKey, visualKeySecret) {
            const passwordSalt = Utils.base64ToUint8Array(fileKey.salt);
const passwordIV = Utils.base64ToUint8Array(fileKey.iv);
            const passwordCipherText = Utils.base64ToUint8Array(fileKey.cipherText);
            const cryptoPasswordKey = await pbkdf2DeriveKey(passwordKey, passwordSalt);
const decryptedIntermediateBuffer = await crypto.subtle.decrypt({ name: AES_ALGO, iv: passwordIV }, cryptoPasswordKey, passwordCipherText);
            const intermediatePayload = JSON.parse(new TextDecoder().decode(decryptedIntermediateBuffer));
const visualKeySalt = Utils.base64ToUint8Array(intermediatePayload.salt);
            const visualKeyIV = Utils.base64ToUint8Array(intermediatePayload.iv);
            const visualCipherText = Utils.base64ToUint8Array(intermediatePayload.encryptedKey);
            const cryptoVisualKey = await pbkdf2DeriveKey(visualKeySecret, visualKeySalt);
const masterPrivateKeyBytes = await crypto.subtle.decrypt({ name: AES_ALGO, iv: visualKeyIV }, cryptoVisualKey, visualCipherText);
            return new Uint8Array(masterPrivateKeyBytes);
        }
    };
})();

// --- UI EVENT HANDLERS ---
const UIHandlers = (() => {
    function updatePuzzleStatus() {
        const { fileKey, passwordKey, visualKey } = state.puzzlePieces;
        let statusHtml = '';
        statusHtml += fileKey ? '<span class="valid">‚úÖ File Key loaded.</span>\n' : '<span class="invalid">‚ùå File Key NOT loaded.</span>\n';
        statusHtml += passwordKey ? '<span class="valid">‚úÖ Password Key entered.</span>\n' : '<span class="invalid">‚ùå Password Key NOT entered.</span>\n';
        statusHtml += visualKey 
? '<span class="valid">‚úÖ Visual Key scanned.</span>\n' : '<span class="invalid">‚ùå Visual Key NOT scanned.</span>\n';
        DOMElements.keyReconstructionStatus.innerHTML = statusHtml;
        const allPiecesProvided = fileKey && passwordKey && visualKey;
        DOMElements.reconstructKeyButton.disabled = !allPiecesProvided;
        if (allPiecesProvided) {
            Utils.updateStatus(DOMElements.keyReconstructionStatus, "‚ö†Ô∏è All puzzle pieces provided. Click 'Activate' to unlock your private key.", 'warning');
}
    }
    
    return {
        handleGenerateAndExportKeys: async () => {
            const password = prompt("Enter a strong password. This will be your 'Password Key' (Piece 2/3).");
if (!password) { Utils.updateStatus(DOMElements.keyGenStatus, '‚ùå Key generation cancelled. Password is required.', 'error'); return;
}
            Utils.updateStatus(DOMElements.keyGenStatus, '‚è≥ Generating new Falcon-1024 key pair...', 'info');
try {
                const keyPair = await BankCrypto.generateNewKeyPair();
state.masterPublicKey = keyPair.publicKey;
                Utils.log("New Master Key Pair generated.", 'success');
                Utils.updateStatus(DOMElements.keyGenStatus, '‚è≥ Creating puzzle pieces and encrypting private key...', 'info');
const visualKeySecret = crypto.randomUUID();
                const { fileKey } = await BankCrypto.encryptMasterKey(keyPair.privateKey, password, visualKeySecret);
                const publicKeyB64 = Utils.arrayBufferToBase64(keyPair.publicKey);
Utils.downloadFile(JSON.stringify({ masterPublicKey: publicKeyB64 }, null, 2), 'Sadat-MASTER-PUBLIC-KEY.json', 'application/json');
                Utils.downloadFile(JSON.stringify(fileKey, null, 2), 'Sadat-FILE-KEY.json', 'application/json');
                DOMElements.jabModalTitle.innerText = "Your Visual Key (Piece 3/3)";
DOMElements.jabDisplay.innerHTML = '';
                
                const qrPngDataUrl = await Utils.createQrCodeImage(visualKeySecret, true);
                const qrImage = new Image();
                qrImage.src = qrPngDataUrl;
                DOMElements.jabDisplay.appendChild(qrImage);
DOMElements.jabModal.style.display = 'flex';
                Utils.updateStatus(DOMElements.keyGenStatus, `‚úÖ New key pair generated!\n- MASTER-PUBLIC-KEY.json (share this)\n- FILE-KEY.json (keep this on a USB)\n- Password (memorize this)\n- Visual Key QR Code (print and secure this)\nThe new Public Key is now active for validation.`, 'success');
} catch (e) {
                Utils.log(`Key generation failed: ${e.message}`, 'error');
Utils.updateStatus(DOMElements.keyGenStatus, `‚ùå Failed to generate keys: ${e.message}`, 'error');
            }
        },
        handleImportPublicKey: async (event) => { const file = event.target.files[0];
if (!file) return; try { const data = JSON.parse(await file.text()); if (!data.masterPublicKey) throw new Error("Invalid public key file format.");
state.masterPublicKey = Utils.base64ToUint8Array(data.masterPublicKey); Utils.updateStatus(DOMElements.keyGenStatus, '‚úÖ Public key imported. Ready to validate banknotes.', 'success'); DOMElements.validatorInput.disabled = false;
} catch (error) { Utils.updateStatus(DOMElements.keyGenStatus, `‚ùå Error importing public key: ${error.message}`, 'error'); } event.target.value = '';
},
        handleFileKeyInput: async (event) => { const file = event.target.files[0]; if (!file) return;
try { state.puzzlePieces.fileKey = JSON.parse(await file.text()); Utils.log("File Key loaded.", 'success'); } catch(e) { state.puzzlePieces.fileKey = null;
Utils.log(`Failed to load File Key: ${e.message}`, 'error'); } updatePuzzleStatus(); event.target.value = '';
},
        handlePasswordKeyInput: (event) => { state.puzzlePieces.passwordKey = event.target.value || null; updatePuzzleStatus();
},
        handleVisualKeyInput: async (event) => {
            const file = event.target.files[0];
if (!file) return;
            try {
                const decodedText = await Utils.decodeQrCodeFromImage(file);
state.puzzlePieces.visualKey = decodedText;
                Utils.log("Visual Key loaded from QR Code.", 'success');
} catch (error) {
                state.puzzlePieces.visualKey = null;
Utils.log(`Error decoding QR Code: ${error.message}`, 'error');
            } finally {
                updatePuzzleStatus();
event.target.value = '';
            }
        },
        handleReconstructKey: async () => {
            const { fileKey, passwordKey, visualKey } = state.puzzlePieces;
if (!fileKey || !passwordKey || !visualKey) { Utils.updateStatus(DOMElements.keyReconstructionStatus, "‚ùå All three puzzle pieces are required.", 'error'); return;
}
            Utils.updateStatus(DOMElements.keyReconstructionStatus, "‚è≥ Reconstructing Master Private Key...", 'info');
try {
                state.masterPrivateKey = await BankCrypto.reconstructMasterKey(fileKey, passwordKey, visualKey);
const testData = new TextEncoder().encode("test");
                const testSig = await BankCrypto.signData(testData, state.masterPrivateKey);
                const isTestValid = await BankCrypto.verifySignature(testSig, testData, state.masterPublicKey);
if (!isTestValid) throw new Error("Key reconstruction failed self-test. The provided pieces do not match the active public key.");
Utils.updateStatus(DOMElements.keyReconstructionStatus, "‚úÖ Master Private Key ACTIVE. You can now create banknotes.", 'success');
                DOMElements.createNoteButton.disabled = false; DOMElements.downloadBatchButton.disabled = false;
} catch (error) {
                console.error(error);
Utils.updateStatus(DOMElements.keyReconstructionStatus, `‚ùå Failed to reconstruct key. ${error.message}`, 'error');
                state.masterPrivateKey = null; DOMElements.createNoteButton.disabled = true; DOMElements.downloadBatchButton.disabled = true;
}
        },
    };
})();
// --- BANKNOTE LOGIC ---
const BanknoteLogic = (() => {
    const getStandardizedDataForSigning = (noteData) => JSON.stringify({ amount: noteData.amount, timestamp: noteData.timestamp, serial: noteData.serial }, ['amount', 'timestamp', 'serial']);
    
    const getStandardizedDataForMasterSig = (noteData) => {
        const tempNoteData = {
            amount: noteData.amount,
            serial: noteData.serial,
            timestamp: noteData.timestamp,
            signatureOne: Utils.arrayBufferToBase64(noteData.signatureOne)
        };
        return JSON.stringify(tempNoteData, Object.keys(tempNoteData).sort());
    };

    const createNoteData = async (amount) => {
        if (!state.masterPrivateKey) throw new Error("Master Private Key is not active.");

        // Apply a standard: ensure the amount is a safe, non-negative integer.
        const integerAmount = Math.floor(Number(amount));
        if (!Number.isFinite(integerAmount) || integerAmount < 0) {
            throw new Error("Invalid amount. Must be a non-negative number.");
        }

        const ephemeralKeyPair = await BankCrypto.generateNewKeyPair();
        const noteData = {
            amount: integerAmount, // Use the sanitized integer amount
            serial: Math.random().toString(36).substring(2, 10).toUpperCase(),
            timestamp: Math.floor((Date.now() - Constants.EPOCH) / 1000),
            ephemeralPublicKey: ephemeralKeyPair.publicKey,
            signatureOne: null,
            signatureTwo: null
        };
        const dataForSigOne = getStandardizedDataForSigning(noteData);
        noteData.signatureOne = await BankCrypto.signData(dataForSigOne, ephemeralKeyPair.privateKey);
        
        const dataForSigTwo = getStandardizedDataForMasterSig(noteData);
        noteData.signatureTwo = await BankCrypto.signData(dataForSigTwo, state.masterPrivateKey);
        return noteData;
    };
    
    const createUnifiedVerificationPayload = (noteData) => {
        const payload = { a: noteData.amount, s: noteData.serial, t: noteData.timestamp, epk: Utils.arrayBufferToBase64(noteData.ephemeralPublicKey), s1: Utils.arrayBufferToBase64(noteData.signatureOne), s2: Utils.arrayBufferToBase64(noteData.signatureTwo) };
const jsonString = JSON.stringify(payload);
        const compressedData = pako.deflate(jsonString);
        return Utils.arrayBufferToBase64(compressedData);
    };
const parseUnifiedVerificationPayload = (base64CompressedString) => {
        const compressedData = Utils.base64ToUint8Array(base64CompressedString);
const jsonString = pako.inflate(compressedData, { to: 'string' });
        const p = JSON.parse(jsonString);
return { amount: p.a, serial: p.s, timestamp: p.t, ephemeralPublicKey: Utils.base64ToUint8Array(p.epk), signatureOne: Utils.base64ToUint8Array(p.s1), signatureTwo: Utils.base64ToUint8Array(p.s2) };
    };
const handleCreateAndSignNotes = async () => {
        if (!state.masterPrivateKey) { alert("Master Private Key is not active. Please activate it in Step 2.");
return; }
        Utils.updateStatus(DOMElements.banknoteStatus, `‚è≥ Creating and displaying banknote...`, 'info');
try {
            const noteData = await createNoteData(DOMElements.amountInput.value);
const fullPayload = createUnifiedVerificationPayload(noteData);
            await BanknoteDrawer.drawNoteOnCanvas(DOMElements.noteCanvas, noteData, fullPayload);
            Utils.updateStatus(DOMElements.banknoteStatus, `‚úÖ New banknote designed. For security, the key has been cleared. Re-activate to create more.`, 'success');
} catch (error) {
            Utils.updateStatus(DOMElements.banknoteStatus, `‚ùå Error: ${error.message}`, 'error');
console.error(error);
        } finally {
            if (state.masterPrivateKey) {
                state.masterPrivateKey = null;
DOMElements.createNoteButton.disabled = true;
                DOMElements.downloadBatchButton.disabled = true;
                UIHandlers.handlePasswordKeyInput({ target: { value: null } });
                DOMElements.passwordKeyInput.value = '';
Utils.updateStatus(DOMElements.keyReconstructionStatus, "‚ö†Ô∏è Master Private Key is INACTIVE. For security, it has been cleared from memory. Solve the puzzle again to activate.", 'warning');
Utils.log("Key cleared for security after single note creation.", 'warning');
            }
        }
    };
const handleDownloadBatch = async () => {
        if (!state.masterPrivateKey) { alert("Master Private Key is not active. Please activate it in Step 2.");
return; }
        const quantity = parseInt(DOMElements.quantityInput.value) || 1;
Utils.updateStatus(DOMElements.banknoteStatus, `‚è≥ Preparing to create ${quantity} banknote(s)...`, 'info');
        if (quantity > 1 && !window.showDirectoryPicker) {
            Utils.log("Directory Picker API not available. Falling back to individual downloads.", 'warning');
alert("Your browser or security context does not support directory selection.\n\nThe banknotes will be downloaded individually to your default 'Downloads' folder.");
}
        try {
            const offscreenCanvas = document.createElement('canvas');
const notesToDownload = [];
            Utils.updateStatus(DOMElements.banknoteStatus, `‚è≥ Generating ${quantity} banknote(s) in memory...`, 'info');
for (let i = 0; i < quantity; i++) {
                const noteData = await createNoteData(DOMElements.amountInput.value);
const fullPayload = createUnifiedVerificationPayload(noteData);
                await BanknoteDrawer.drawNoteOnCanvas(offscreenCanvas, noteData, fullPayload);
                const blob = await new Promise(resolve => offscreenCanvas.toBlob(resolve, 'image/png'));
notesToDownload.push({ blob, filename: `SADAT-NOTE-${noteData.serial}.png` });
                if (i === quantity - 1) {
                    await BanknoteDrawer.drawNoteOnCanvas(DOMElements.noteCanvas, noteData, fullPayload);
}
            }
            if (window.showDirectoryPicker && quantity > 1) {
                Utils.updateStatus(DOMElements.banknoteStatus, `‚ÑπÔ∏è Please select a folder to save the banknotes.`, 'info');
const dirHandle = await window.showDirectoryPicker();
                Utils.updateStatus(DOMElements.banknoteStatus, `‚è≥ Saving ${quantity} notes to your selected folder...`, 'info');
for (const note of notesToDownload) {
                    const fileHandle = await dirHandle.getFileHandle(note.filename, { create: true });
const writable = await fileHandle.createWritable();
                    await writable.write(note.blob);
                    await writable.close();
                }
                Utils.updateStatus(DOMElements.banknoteStatus, `‚úÖ Saved ${quantity} notes to your selected folder.`, 'success');
} else {
                Utils.updateStatus(DOMElements.banknoteStatus, `‚è≥ Downloading ${quantity} note(s) individually...`, 'info');
notesToDownload.forEach(note => Utils.downloadFile(note.blob, note.filename, 'image/png'));
                Utils.updateStatus(DOMElements.banknoteStatus, `‚úÖ Saved ${quantity} note(s). Check your downloads folder.`, 'success');
}
        } catch (error) {
            Utils.updateStatus(DOMElements.banknoteStatus, `‚ùå Operation cancelled or failed: ${error.message}`, 'error');
console.error(error);
        } finally {
            state.masterPrivateKey = null;
DOMElements.createNoteButton.disabled = true;
            DOMElements.downloadBatchButton.disabled = true;
            UIHandlers.handlePasswordKeyInput({ target: { value: null } });
            DOMElements.passwordKeyInput.value = '';
Utils.updateStatus(DOMElements.keyReconstructionStatus, "‚ö†Ô∏è Master Private Key is INACTIVE. For security, it has been cleared from memory. Solve the puzzle again to activate.", 'warning');
Utils.log("Key cleared for security after batch operation.", 'warning');
        }
    };
async function decodeAllQrCodesFromImage(processedDataUrl, banknoteImage) {
        const mainCanvas = document.createElement('canvas');
        mainCanvas.width = banknoteImage.width;
mainCanvas.height = banknoteImage.height;
        const mainCtx = mainCanvas.getContext('2d');
        mainCtx.drawImage(banknoteImage, 0, 0);

        const layout = BanknoteDrawer.getLayout(mainCanvas.width, mainCanvas.height);
        const scanResults = [];
for (let i = 0; i < Constants.NUM_QR_CODES; i++) {
            Utils.updateStatus(DOMElements.validationResult, `‚è≥ Scanning Exact Location ${i + 1} of ${Constants.NUM_QR_CODES}...`, 'info');
const row = Math.floor(i / 3);
            const col = i % 3;
// This calculation is now for a cropped image, starting at 0,0
            const regionX = col * (layout.qrSize + layout.xSpacing);
const regionY = row * (layout.qrSize + layout.ySpacing);
            const regionSize = layout.qrSize;
            
            const imageData = mainCtx.getImageData(regionX, regionY, regionSize, regionSize);
const code = jsQR(imageData.data, imageData.width, imageData.height);
            
            const result = { x: regionX, y: regionY, size: regionSize, data: null, success: false };
if (code && code.data) {
                result.data = code.data;
result.success = true;
            } else {
                 console.warn(`Could not decode QR in zone ${i + 1}.`);
}
            scanResults.push(result);
}
        
        if (scanResults.every(r => !r.success)) {
             throw new Error("Validation Failed. No QR codes found at exact locations. Tip: Use a flat, well-lit photo.");
}
        return scanResults;
}

    return {
        handleCreateAndSignNotes,
        handleDownloadBatch,
        handleFileSelectForValidation: async (event) => {
            const file = event.target.files[0];
if (!file || !state.masterPublicKey) { Utils.updateStatus(DOMElements.validationResult, '‚ùå Load a Master Public Key in Step 1 before validating.', 'error'); return;
}
            const resultDiv = DOMElements.validationResult;
            const noteCanvas = DOMElements.noteCanvas;
const noteCtx = noteCanvas.getContext('2d');
            Utils.updateStatus(resultDiv, '‚è≥ Preparing image for validation...', 'info');
try {
                const resizedDataUrl = await Utils.resizeImage(file, Constants.MAX_IMAGE_DIMENSION);
const processedDataUrl = await Utils.preprocessImage(resizedDataUrl);
                
                const banknoteImage = await new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = () => reject('Could not load banknote image');
           
         img.src = processedDataUrl;
                });
noteCanvas.width = banknoteImage.width;
                noteCanvas.height = banknoteImage.height;
                noteCtx.drawImage(banknoteImage, 0, 0);

                const scanResults = await decodeAllQrCodesFromImage(processedDataUrl, banknoteImage);
scanResults.forEach(result => {
                    if (result.success) {
                        noteCtx.font = `bold ${result.size * 0.8}px sans-serif`;
                        noteCtx.fillStyle = 'rgba(0, 255, 0, 0.7)';
                 
       noteCtx.textAlign = 'center';
                        noteCtx.textBaseline = 'middle';
                        noteCtx.fillText('‚úî', result.x + result.size / 2, result.y + result.size / 2);
                    } else {
         
               noteCtx.font = `bold ${result.size * 0.8}px sans-serif`;
                        noteCtx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                        noteCtx.textAlign = 'center';
                        
noteCtx.textBaseline = 'middle';
                        noteCtx.fillText('‚úñ', result.x + result.size / 2, result.y + result.size / 2);
                    }
                });
const decodedCodes = scanResults.filter(r => r.success);
                let resultHTML = `<span class="info">Found ${decodedCodes.length}/${Constants.NUM_QR_CODES} QR code(s). Assembling payload...</span>\n`;
                resultDiv.innerHTML = resultHTML;
let expectedTotalParts = Constants.NUM_QR_CODES;
                const receivedParts = {};
                let uniqueCodes = 0;
for (const code of decodedCodes) {
                    if (code.data.startsWith(Constants.VALIDATION_PREFIX)) {
                        const payload = code.data.substring(Constants.VALIDATION_PREFIX.length);
const match = payload.match(/^(\d+)\/(\d+):(.*)$/s);
                        if (match) {
                            const partNum = parseInt(match[1], 10);
if (!receivedParts[partNum]) {
                                receivedParts[partNum] = match[3];
uniqueCodes++;
                            }
                        }
                    }
                }
                
                if (uniqueCodes < expectedTotalParts) {
   
                 Utils.updateStatus(resultDiv, `‚ùå Incomplete banknote data. Found ${uniqueCodes}/${expectedTotalParts} required QR codes. The banknote may be damaged or fake.`, 'error');
return;
                }

                let fullPayloadString = '';
for (let i = 1; i <= expectedTotalParts; i++) {
                    fullPayloadString += receivedParts[i];
}

                resultHTML += `<span class="valid">‚úÖ Found all ${expectedTotalParts} parts.
Reconstructing payload...</span>\n`;
                resultDiv.innerHTML = resultHTML;
                
                const parsedData = parseUnifiedVerificationPayload(fullPayloadString);
                resultHTML += `<span class="info">‚ÑπÔ∏è Verifying Ephemeral Signature (Sig 1)...</span>\n`;
resultDiv.innerHTML = resultHTML;
                const dataForSigOne = getStandardizedDataForSigning(parsedData);
                const isSigOneValid = await BankCrypto.verifySignature(parsedData.signatureOne, dataForSigOne, parsedData.ephemeralPublicKey);
if (!isSigOneValid) { resultHTML += '<span class="invalid">‚ùå Ephemeral Signature (Sig 1) INVALID.</span>\n<hr><span>‚ùå VERDICT: FORGERY</span>'; resultDiv.innerHTML = resultHTML; return;
}
                resultHTML += '<span class="valid">‚úÖ Ephemeral Signature (Sig 1) OK.</span>\n';
resultHTML += `<span class="info">‚ÑπÔ∏è Verifying Master Signature (Sig 2)...</span>\n`;
                resultDiv.innerHTML = resultHTML;
                const dataForSigTwo = getStandardizedDataForMasterSig(parsedData);
const isSigTwoValid = await BankCrypto.verifySignature(parsedData.signatureTwo, dataForSigTwo, state.masterPublicKey);
                if (!isSigTwoValid) { resultHTML += '<span class="invalid">‚ùå Master Signature (Sig 2) INVALID.</span>\n<hr><span>‚ùå VERDICT: FORGERY (Not issued by this Guardian)</span>';
resultDiv.innerHTML = resultHTML; return; }
                resultHTML += '<span class="valid">‚úÖ Master Signature (Sig 2) OK.</span>\n<hr><span style="font-size:14px;font-weight:600;">‚úÖ VERDICT: BANKNOTE IS AUTHENTIC</span>';
resultDiv.innerHTML = resultHTML;
            } catch (e) {
                if (e.message.includes("incorrect header check") || e.message.includes("invalid block type")) {
                     Utils.updateStatus(resultDiv, `‚ùå Validation Error: Decompression failed. The QR code data is corrupt or invalid.`, 'error');
} else {
                     Utils.updateStatus(resultDiv, `‚ùå Validation Error: ${e.message}`, 'error');
}
                console.error(e);
} finally {
                event.target.value = '';
}
        }
    };
})();
// ===================================================================================
// BANKNOTE DRAWER -- THIS SECTION CONTAINS THE LAYOUT FIX
// ===================================================================================
const BanknoteDrawer = (() => {
    /**
     * Draws microprint text in the gaps between QR codes.
     * All coordinates are relative to a 0,0 origin.
     */
    function drawMicroprint(ctx, layout, amount, serial) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.35)"; // Watermark color
        ctx.font = "bold 9px 'Roboto Mono'";
        ctx.textAlign = 
'center';
        ctx.textBaseline = 'middle';

        const amountStr = amount.toLocaleString('en-US');
        const serialStr = serial;

        // --- Draw 6 VERTICAL texts ---
        const verticalTextX1 = layout.qrSize + (layout.xSpacing / 2);
        const verticalTextX2 = (layout.qrSize * 2) + layout.xSpacing + (layout.xSpacing / 2);

        for (let i = 0; i < 3; i++) {
   
         const yPos = (layout.qrSize / 2) + i * (layout.qrSize + layout.ySpacing);
ctx.save();
            ctx.translate(verticalTextX1, yPos);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(serialStr, 0, 0);
            ctx.restore();

            ctx.save();
            ctx.translate(verticalTextX2, yPos);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(amountStr, 0, 0);
            ctx.restore();
}

        // --- Draw 4 HORIZONTAL texts ---
        const horizontalTextY1 = layout.qrSize + (layout.ySpacing / 2);
const horizontalTextY2 = (layout.qrSize * 2) + layout.ySpacing + (layout.ySpacing / 2);
        
        const xPos1 = (layout.qrSize / 2);
const xPos2 = (layout.qrSize * 2.5) + (layout.xSpacing * 2);

        ctx.fillText(amountStr, xPos1, horizontalTextY1);
        ctx.fillText(amountStr, xPos2, horizontalTextY1);
        
        ctx.fillText(serialStr, xPos1, horizontalTextY2);
ctx.fillText(serialStr, xPos2, horizontalTextY2);
    }

    return {
        // getLayout is used by the validator to know where to scan for QR codes
        getLayout: (width, height) => {
            const qrSize = 250;
const xSpacing = 20;
            const ySpacing = 20;
            const totalGridWidth = (qrSize * 3) + (xSpacing * 2);
const totalGridHeight = (qrSize * 3) + (ySpacing * 2);
            return { qrSize, xSpacing, ySpacing, totalGridWidth, totalGridHeight };
},
        drawNoteOnCanvas: async (targetCanvas, noteData, fullPayload) => {
            // Define layout constants directly
            const layout = {
                qrSize: 250,
                xSpacing: 20,
                ySpacing: 20,
    
        };

            // Calculate the exact canvas dimensions based on the QR grid
            const finalWidth = (layout.qrSize * 3) + (layout.xSpacing * 2);
const finalHeight = (layout.qrSize * 3) + (layout.ySpacing * 2);
// Set the canvas size precisely
            targetCanvas.width = finalWidth;
targetCanvas.height = finalHeight;

            const ctx = targetCanvas.getContext("2d");
            const { amount, serial } = noteData;
// Simple white background, no borders or shadows
            ctx.fillStyle = 'white';
ctx.fillRect(0, 0, finalWidth, finalHeight);
            
            ctx.imageSmoothingEnabled = false;
            
            // Prepare QR code data
            const partLength = Math.ceil(fullPayload.length / Constants.NUM_QR_CODES);
const qrPayloads = [];
            for (let i = 0; i < Constants.NUM_QR_CODES; i++) {
                const partData = fullPayload.substring(i * partLength, (i + 1) * partLength);
qrPayloads.push(`${Constants.VALIDATION_PREFIX}${i + 1}/${Constants.NUM_QR_CODES}:${partData}`);
            }

            const qrImages = await Promise.all(qrPayloads.map(payload => Utils.createQrCodeImage(payload)));
// Draw QR codes starting from origin 0,0
            qrImages.forEach((img, index) => {
                const row = Math.floor(index / 3);
                const col = index % 3;
                const x = col * (layout.qrSize + layout.xSpacing);
             
   const y = row * (layout.qrSize + layout.ySpacing);
                ctx.drawImage(img, x, y, Math.round(layout.qrSize), Math.round(layout.qrSize));
            });
// Draw the microprint text in the gaps
            drawMicroprint(ctx, layout, amount, serial);
}
    };
})();

// ===================================================================================
// APPLICATION INITIALIZATION
// ===================================================================================
async function main() {
    Utils.updateStatus(DOMElements.keyGenStatus, '‚è≥ Loading Falcon-1024 Module...', 'info');
try {
        state.falconApi = await pqcSignFalcon1024();
Utils.updateStatus(DOMElements.keyGenStatus, '‚úÖ Modules loaded. Please generate or import keys to begin.', 'success');
Utils.log("All cryptographic and QR code modules initialized successfully.", 'success');
    } catch (e) {
        Utils.log(`Critical Error: Could not load required modules: ${e.message}`, 'error');
Utils.updateStatus(DOMElements.keyGenStatus, `‚ùå Critical Error: Could not load modules. See console for details.`, 'error');
alert("Error: Failed to load a required cryptographic module. The application cannot run.");
        return;
}
    
    DOMElements.generateKeysButton.addEventListener('click', UIHandlers.handleGenerateAndExportKeys);
    DOMElements.importPublicKey.addEventListener('change', UIHandlers.handleImportPublicKey);
    DOMElements.fileKeyInput.addEventListener('change', UIHandlers.handleFileKeyInput);
    DOMElements.passwordKeyInput.addEventListener('input', UIHandlers.handlePasswordKeyInput);
    DOMElements.visualKeyInput.addEventListener('change', UIHandlers.handleVisualKeyInput);
    DOMElements.reconstructKeyButton.addEventListener('click', UIHandlers.handleReconstructKey);
DOMElements.createNoteButton.addEventListener('click', BanknoteLogic.handleCreateAndSignNotes);
    DOMElements.downloadBatchButton.addEventListener('click', BanknoteLogic.handleDownloadBatch);
    DOMElements.validatorInput.addEventListener('change', BanknoteLogic.handleFileSelectForValidation);
    
    DOMElements.downloadJabButton.addEventListener('click', () => {
        const img = DOMElements.jabDisplay.querySelector('img');
        if (img && img.src) {
            const a = document.createElement('a');
            a.href = img.src; 
            a.download = 'Sadat-VISUAL-KEY.png';
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
        }
  
  });

    const canvas = DOMElements.noteCanvas;
    const ctx = canvas.getContext('2d');
    const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
bgGradient.addColorStop(0, `hsl(250, 50%, 6%)`);
    bgGradient.addColorStop(1, `hsl(260, 40%, 4%)`);
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.font = `bold 30px 'Poppins'`;
ctx.textAlign = 'center';
    ctx.fillStyle = "rgba(255,255,255,0.4)";
    ctx.fillText("Banknote design will appear here", canvas.width/2, canvas.height/2);
}

main();
</script>
</body>
</html>
