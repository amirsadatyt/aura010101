<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="UTF-8">
    <title>Aura Wallet (Pinata Ledger)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
        :root {
            --primary-color: #333333;
            --secondary-color: #000000;
            --danger-color: #d9534f;
            --light-gray: #f5f5f5;
            --dark-gray: #555555;
            --success-color: #1e8e3e;
            --text-light: #ffffff;
            --text-dark: #212529;
            --card-bg: #ffffff;
            --border-color: #dee2e6;
        }
        body { font-family: 'Roboto', sans-serif; background-color: var(--light-gray); display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; color: var(--text-dark); }
        .view { display: none; }
        .view.active { display: block; }
        .card { background-color: var(--card-bg); padding: 30px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); width: 380px; text-align: center; border-top: 5px solid var(--secondary-color); }
        input, textarea { width: calc(100% - 22px); padding: 10px; margin-bottom: 15px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 16px; text-align: center; font-family: 'Roboto', sans-serif; background-color: #fff; color: #000; }
        textarea { resize: vertical; height: 80px; }
        button { width: 100%; padding: 12px; background: linear-gradient(90deg, var(--primary-color), var(--secondary-color)); color: var(--text-light); border: none; border-radius: 6px; font-size: 16px; cursor: pointer; transition: all 0.2s; }
        button:hover { opacity: 0.9; transform: translateY(-2px); }
        button:disabled { background: #999; cursor: not-allowed; transform: translateY(0); }
        .back-button { background: var(--dark-gray); margin-top: 10px; }
        .logout-button { background: var(--danger-color); margin-top: 10px; }
        .link-button { background: none; border: none; color: var(--primary-color); text-decoration: underline; cursor: pointer; padding: 5px; width: auto; }
        .status-box { font-weight: bold; min-height: 20px; margin-top: 10px; word-wrap: break-word; }
        .error { color: var(--danger-color); }
        .success { color: var(--success-color); }
        .info { color: #007bff; }
        .seed-phrase-box { padding: 15px; border: 1px dashed var(--danger-color); border-radius: 8px; margin: 20px 0; background-color: #fff8f8; color: #333; font-size: 18px; letter-spacing: 1px; }
        #my-qr-code img, #qr-display-box img, #static-qr-code img { margin: 15px auto; display: block; border: 5px solid #eee; border-radius: 5px; }
        label.qr-upload-label { cursor: pointer; display: block; margin: 15px; padding: 10px; border: 2px dashed #ccc; border-radius: 8px; }
        label.qr-upload-label:hover { background-color: #f9f9f9; }
        input[type="file"] { display: none; }
        .loader { border: 4px solid #f3f3f3; border-radius: 50%; border-top: 4px solid var(--primary-color); width: 20px; height: 20px; -webkit-animation: spin 1s linear infinite; animation: spin 1s linear infinite; margin: 10px auto; }
        .loader.hidden { display: none; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        /* Transaction History Styles */
        .transaction-history { margin-top: 25px; text-align: left; }
        .transaction-history h3 { text-align: center; margin-bottom: 15px; color: var(--secondary-color); }
        .transaction-list { list-style-type: none; padding: 0; max-height: 200px; overflow-y: auto; }
        .transaction-item { display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid var(--border-color); }
        .transaction-item:last-child { border-bottom: none; }
        .transaction-details { display: flex; flex-direction: column; }
        .transaction-type { font-weight: bold; font-size: 16px; }
        .transaction-type.sent { color: var(--danger-color); }
        .transaction-type.received { color: var(--success-color); }
        .transaction-date { font-size: 12px; color: #888; }
        .transaction-amount { font-weight: bold; font-size: 16px; }
        .transaction-amount.sent { color: var(--danger-color); }
        .transaction-amount.received { color: var(--success-color); }
        .no-transactions { text-align: center; color: #999; padding: 20px; }
         /* Timer Style */
        #payment-timer { font-size: 18px; font-weight: bold; color: var(--danger-color); margin-top: 15px; }
        .address-display-box { background: #f0f2f5; padding: 10px; border-radius: 6px; margin-bottom: 15px; display: flex; align-items: center; justify-content: center; }
        .address-text { font-family: monospace; font-size: 14px; margin-right: 10px; }
        .copy-button { padding: 5px 10px; font-size: 12px; width: auto; background: var(--dark-gray); min-width: 60px; }
        #confirm-amount-display { line-height: 1.5; }
        
        /* Styles for Transaction Detail Modal */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 1000;
        }
        .modal-content {
            width: 400px; max-width: 90%; text-align: left; padding: 25px;
        }
        .modal-content h2 { text-align: center; margin-bottom: 20px; }
        .modal-content p { margin-bottom: 12px; font-size: 14px; }
        .modal-content p strong { color: var(--primary-color); }
    </style>
</head>
<body>

    <div id="app-container">
        <div id="onboarding-view" class="view active"><div class="card"><h1>Aura Wallet</h1><p>A new generation of asset security and control</p><button id="go-to-create-wallet">Create a New Wallet</button><button id="go-to-restore-wallet" class="back-button">Restore Wallet</button></div></div>
        
        <div id="create-wallet-view" class="view"><div class="card"><h2>Create Password</h2><p>Choose a strong password to encrypt your wallet. This password cannot be recovered.</p><input type="password" id="create-password-input" placeholder="Password"><input type="password" id="confirm-password-input" placeholder="Confirm Password"><div class="loader hidden" id="create-loader"></div><button id="create-wallet-button">Create Wallet</button><div id="create-status" class="status-box"></div><button class="back-button" id="back-from-create">Back</button></div></div>

        <div id="seed-phrase-view" class="view"><div class="card"><h2>Your Recovery Phrase</h2><p class="error">Write down these 12 words in a safe, offline place. This is the only way to recover your wallet.</p><div id="seed-phrase-display" class="seed-phrase-box"></div><button id="seed-phrase-confirm-button">I Understand, Take Me to My Wallet</button></div></div>

        <div id="restore-wallet-view" class="view"><div class="card"><h2>Restore Wallet</h2><p>Enter your 12-word recovery phrase.</p><textarea id="restore-seed-input" placeholder="Enter words separated by spaces..."></textarea><p>Choose a new password for this device.</p><input type="password" id="restore-password-input" placeholder="New Password"><div class="loader hidden" id="restore-loader"></div><button id="restore-wallet-button">Restore</button><div id="restore-status" class="status-box"></div><button class="back-button" id="back-from-restore">Back</button></div></div>
        
        <div id="login-view" class="view"><div class="card"><h1>Unlock Wallet</h1><p>Enter your password to decrypt your wallet.</p><input type="password" id="login-password-input" placeholder="Password"><div class="loader hidden" id="login-loader"></div><button id="login-button">Unlock</button><div id="login-status" class="status-box"></div><p style="margin-top:20px;">Want to use a different wallet? <button class="link-button" id="reset-app-button">Erase everything and start over</button></p></div></div>
        
        <div id="wallet-view" class="view"><div class="card">
            <h2>Your Wallet</h2>
            <div class="address-display-box">
                <span id="address-display" class="address-text"></span>
                <button id="copy-address-button" class="copy-button">Copy</button>
            </div>
            <p>Balance:</p>
            <h1 id="balance-display">$0.00</h1>
            <div id="sync-status" class="status-box" style="font-size: 14px;"></div>
            <p id="network-status" style="font-size: 12px; color: var(--success-color);">Ledger: Pinata IPFS</p>
            <button id="show-charge-view-button">Charge with Banknote</button>
            <button id="show-send-view-button" style="margin-top:10px;">Send (Aura)</button>
            <button id="show-receive-view-button" style="margin-top:10px;">Receive (Aura)</button>
            <div class="transaction-history">
                <h3>Recent Transactions</h3>
                <ul id="transaction-list-ul" class="transaction-list"></ul>
            </div>
        
            <button id="logout-button" class="logout-button">Logout (Lock Wallet)</button>
        </div></div>
        
        <div id="charge-view" class="view"><div class="card"><h2>Charge Wallet</h2><div><h3>Step 1: Bank Public Key</h3><p>The bank's public key is pre-loaded for verification.</p><div id="key-status" class="status-box"></div></div><div><h3>Step 2: Scan Digital Banknote</h3><label for="banknote-image-input" class="qr-upload-label" id="banknote-upload-label">Upload Banknote Image</label><input type="file" id="banknote-image-input" accept="image/*" disabled><div id="validation-status" class="status-box"></div></div><div id="charge-confirmation" style="display:none; margin-top: 20px;"><p>Validation successful! Amount: <b id="validated-amount"></b></p><button id="confirm-charge-button">Add to Balance</button></div><button class="back-button" id="back-from-charge">Back</button></div></div>
        
        <div id="receive-view" class="view"><div class="card">
            <h2>Receive Funds</h2>
            <p>Share your address to receive funds.</p>
            <div id="static-qr-code"></div>
            <p style="font-size: 12px; word-wrap: break-word; background: #f0f2f5; padding: 8px; border-radius: 4px;" id="full-receive-address"></p>
            <hr style="margin: 20px 0;">
            <p>Or request a specific amount:</p>
            <input type="number" id="request-amount-input" placeholder="Amount to receive">
            <button id="create-request-qr-button">Generate Payment Request QR</button>
            <div id="receive-status" class="status-box"></div>
            <button class="back-button" id="back-from-receive">Back</button>
        </div></div>
        
        <div id="send-view" class="view"><div class="card">
            <h2>Send Funds</h2>
            
            <p>Enter recipient address and amount.</p>
            <div>
                <input type="text" id="send-address-input" placeholder="Recipient's Aura Address" style="margin-bottom: 10px;">
                <input type="number" id="send-amount-input" placeholder="Amount to send" style="margin-bottom: 10px;">
                <button id="send-manual-button">Continue</button>
            </div>

            <p style="text-align:center; margin: 20px 0; font-weight: bold;">- OR -</p>

            <p>Scan a recipient's payment request QR code.</p>
            <div id="video-container" style="position: relative; width: 100%; max-width: 300px; margin: 15px auto; border-radius: 8px; overflow: hidden; border: 2px solid #333; background: #000;">
                <video id="qr-video" playsinline style="width: 100%; height: auto; display: block;"></video>
                <div id="loading-message" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); color: white; display: flex; align-items: center; justify-content: center;">Requesting camera access...</div>
            </div>
            <canvas id="qr-canvas" style="display: none;"></canvas> 
            <div id="send-status" class="status-box"></div>
            <button class="back-button" id="back-from-send">Back</button>
        </div></div>
        
        <div id="send-confirm-view" class="view"><div class="card">
            <h2>Confirm Payment</h2>
            <p>You are about to send:</p>
            <h2 id="confirm-amount-display" style="color: var(--primary-color);"></h2>
            <p>To:</p>
    
                <p id="confirm-recipient-address-display" style="font-size: 12px; word-wrap: break-word; background: #f0f2f5; padding: 8px; border-radius: 4px;"></p>
            <button id="confirm-payment-button">Confirm and Pay</button>
            <div id="send-confirm-status" class="status-box"></div>
            <button class="back-button" id="back-from-send-confirm">Cancel</button>
        </div></div>
        
        <div id="qr-display-view" class="view"><div class="card">
            <h2 id="qr-display-title"></h2>
            <p id="qr-display-instruction"></p>
            <div id="qr-display-box"></div>
            <div id="waiting-on-payment" style="display: none;">
                
            <div id="payment-timer"></div>
    
                    <div class="loader"></div>
                <p id="final-status-message" class="status-box" style="font-size:18px;"></p>
            </div>
            <button class="back-button" id="back-from-qr-display">Back to Wallet</button>
        </div></div>

        <div id="transaction-detail-modal" class="modal-overlay" style="display:none;">
            <div class="modal-content card">
                <h2>Transaction Details</h2>
            
                <div id="modal-details-content">
        
                            <p><strong>Status:</strong> <span id="detail-status"></span></p>
                    <p><strong>Type:</strong> <span id="detail-type"></span></p>
                    <p><strong>Date & Time:</strong> <span id="detail-datetime"></span></p>
                    <p><strong>Amount:</strong> <span id="detail-amount"></span></p>
        
                    <p><strong>Fee:</strong> <span id="detail-fee"></span></p>
                
            <p style="word-wrap: break-word;"><strong>From:</strong> <span id="detail-from"></span></p>
                    <p style="word-wrap: break-word;"><strong>To:</strong> <span id="detail-to"></span></p>
                    <p style="word-wrap: break-word;"><strong>Transaction Hash:</strong> <span id="detail-hash"></span></p>
                </div>
        
                <button id="download-tx-button">Download as JPG</button>
                <button id="close-modal-button" class="back-button">Close</button>
            </div>
        </div>
    </div>
 
    <script src="pako.min.js" integrity="sha256-p/3ffWSPuJj41f4cN5f23mI2lZ2S2KkrsP2i4gzO3So=" crossorigin="anonymous" data-trusted="true"></script>
    <script src="qrcode.js" integrity="sha256-ExpoH1p05AMy2dfp2L3s4OB/KtjV8W5B5F5Pq1O/iSg=" crossorigin="anonymous" data-trusted="true"></script>
    <script src="jsQR.js" integrity="sha256-gPAiTd/2Q40f7LpE42/1zCYfD1L2qZglkYnE+BLQhKc=" crossorigin="anonymous" data-trusted="true"></script>
    <script src="crypto-js.min.js" integrity="sha256-Q3OMY9243IZ/5FEymEnB9s23sR1iB/Tix2/opVhdIKg=" crossorigin="anonymous" data-trusted="true"></script>
    <script src="html2canvas.min.js" integrity="sha256-c3RzrmN4QhEPTzPFW3/321i+e/Iw/Sj/28Z+Vj9pL44=" crossorigin="anonymous" data-trusted="true"></script>
    
    <script type="module">
        import { ethers } from "./ethers.min.js";
        import pqcSignFalcon1024 from './pqc-sign-falcon-1024.min.js';
        import { shake256 } from 'https://cdn.skypack.dev/js-sha3';

        // --- SECURITY AND PERFORMANCE MODULES ---
        const SecurityManager = {
            async verifyCodeIntegrity() {
                // NOTE: Hashes must be updated if the library files change.
                const expectedHashes = {
                    'pako.min.js': 'sha256-p/3ffWSPuJj41f4cN5f23mI2lZ2S2KkrsP2i4gzO3So=',
                    'qrcode.js': 'sha256-ExpoH1p05AMy2dfp2L3s4OB/KtjV8W5B5F5Pq1O/iSg=',
                    'jsQR.js': 'sha256-gPAiTd/2Q40f7LpE42/1zCYfD1L2qZglkYnE+BLQhKc=',
                    'crypto-js.min.js': 'sha256-Q3OMY9243IZ/5FEymEnB9s23sR1iB/Tix2/opVhdIKg=',
                    'html2canvas.min.js': 'sha256-c3RzrmN4QhEPTzPFW3/321i+e/Iw/Sj/28Z+Vj9pL44='
                };
                for (const [file, expectedHash] of Object.entries(expectedHashes)) {
                    const script = document.querySelector(`script[src*="${file}"]`);
                    if (script && script.integrity !== expectedHash) {
                        throw new Error(`Code integrity violation: ${file} has been tampered with.`);
                    }
                }
            },
            setupAntiTampering() {
                // Detect DevTools opening
                const devtools = { open: false };
                setInterval(() => {
                    if (window.outerHeight - window.innerHeight > 160 || window.outerWidth - window.innerWidth > 160) {
                        if (!devtools.open) {
                            devtools.open = true;
                            this.handleTamperingAttempt('Developer Tools Detected');
                        }
                    } else {
                        devtools.open = false;
                    }
                }, 1000);
                // Detect unauthorized script injection
                const observer = new MutationObserver(mutations => {
                    mutations.forEach(mutation => {
                        if (mutation.type === 'childList') {
                            mutation.addedNodes.forEach(node => {
                                if (node.nodeName === 'SCRIPT' && !node.hasAttribute('data-trusted')) {
                                    this.handleTamperingAttempt('Unauthorized script injection detected');
                                    node.remove(); // Remove the malicious script
                                }
                            });
                        }
                    });
                });
                observer.observe(document.documentElement, { childList: true, subtree: true });
            },
            handleTamperingAttempt(reason) {
                console.warn(`SECURITY VIOLATION: ${reason}. Locking wallet.`);
                if (state.wallet) {
                    WalletLogic.logout();
                }
                localStorage.setItem('security_lock', Date.now());
                document.body.innerHTML = `<h1>Security Violation</h1><p>${reason}. For your protection, this wallet has been locked. Please close this tab and wait 5 minutes before trying again.</p>`;
            },
            async encryptSensitiveData(data, password) {
                const salt = crypto.getRandomValues(new Uint8Array(16));
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const keyMaterial = await crypto.subtle.importKey('raw', new TextEncoder().encode(password), 'PBKDF2', false, ['deriveKey']);
                const key = await crypto.subtle.deriveKey({ name: 'PBKDF2', salt, iterations: 200000, hash: 'SHA-256' }, keyMaterial, { name: 'AES-GCM', length: 256 }, false, ['encrypt']);
                const encrypted = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, new TextEncoder().encode(JSON.stringify(data)));
                return { encrypted: Array.from(new Uint8Array(encrypted)), salt: Array.from(salt), iv: Array.from(iv) };
            },
            async decryptSensitiveData(encryptedPayload, password) {
                const keyMaterial = await crypto.subtle.importKey('raw', new TextEncoder().encode(password), 'PBKDF2', false, ['deriveKey']);
                const key = await crypto.subtle.deriveKey({ name: 'PBKDF2', salt: new Uint8Array(encryptedPayload.salt), iterations: 200000, hash: 'SHA-256' }, keyMaterial, { name: 'AES-GCM', length: 256 }, false, ['decrypt']);
                const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: new Uint8Array(encryptedPayload.iv) }, key, new Uint8Array(encryptedPayload.encrypted));
                return JSON.parse(new TextDecoder().decode(decrypted));
            },
            rateLimiter: new Map(),
            isRateLimited(operation, maxAttempts = 5, windowMs = 60000) {
                const now = Date.now();
                const records = (this.rateLimiter.get(operation) || []).filter(timestamp => now - timestamp < windowMs);
                if (records.length >= maxAttempts) return true;
                records.push(now);
                this.rateLimiter.set(operation, records);
                return false;
            },
            async secureSignMessage(message, wallet) {
                if (this.isRateLimited('signMessage', 10, 60000)) throw new Error('Too many signing requests.');
                const payload = {
                    message: message,
                    timestamp: Date.now(),
                    nonce: crypto.getRandomValues(new Uint32Array(1))[0]
                };
                const messageToSign = JSON.stringify(payload, Object.keys(payload).sort());
                const signature = await wallet.signMessage(messageToSign);
                return { signedPayload: payload, signature };
            },
            async verifySignedMessage(signedPayload, signature, senderAddress) {
                const messageToVerify = JSON.stringify(signedPayload, Object.keys(signedPayload).sort());
                const signerAddress = ethers.verifyMessage(messageToVerify, signature);
                if (signerAddress !== senderAddress) throw new Error("Signature verification failed.");
                if (Date.now() - signedPayload.timestamp > 30000) throw new Error("Signature has expired (replay protection).");
                return true;
            },
            async performSecurityChecks() {
                if (!window.isSecureContext) throw new Error('Wallet must run in a secure context (HTTPS).');
                await this.verifyCodeIntegrity();
            }
        };

        const CacheManager = {
            cache: new Map(),
            DEFAULT_CACHE_DURATION: 30000,
            set(key, data, duration = this.DEFAULT_CACHE_DURATION) { this.cache.set(key, { data, expiresAt: Date.now() + duration }); },
            get(key) { const c = this.cache.get(key); if (!c || Date.now() > c.expiresAt) { this.cache.delete(key); return null; } return c.data; },
            invalidate(pattern) { for (const key of this.cache.keys()) { if (key.includes(pattern)) this.cache.delete(key); } }
        };

        const NetworkOptimizer = {
            getSyncStrategy() {
                const speed = navigator.connection?.effectiveType || '4g';
                switch (speed) {
                    case 'slow-2g': case '2g': return { interval: 45000, useCache: true, cacheDuration: 120000 };
                    case '3g': return { interval: 20000, useCache: true, cacheDuration: 60000 };
                    default: return { interval: 10000, useCache: true, cacheDuration: 20000 };
                }
            }
        };

        const BackgroundSync = {
            isRunning: false, syncIntervalId: null,
            start() {
                if (this.isRunning) return;
                this.isRunning = true;
                const strategy = NetworkOptimizer.getSyncStrategy();
                const syncCycle = () => { if (this.isRunning) this.performSync().catch(err => console.error("BG Sync Error:", err)); };
                syncCycle();
                this.syncIntervalId = setInterval(syncCycle, strategy.interval);
            },
            async performSync() {
                if (!state.wallet) { this.stop(); return; }
                const syncStatusEl = document.getElementById('sync-status');
                try {
                    const [incomingTxs, outgoingTxs] = await Promise.all([ PinataLedger.findIncomingTxs(state.wallet.address), PinataLedger.findOutgoingTxs(state.wallet.address) ]);
                    let newTxCount = 0;
                    for (const confirmation of incomingTxs) { if (await WalletLogic.processDiscoveredTransaction(confirmation)) newTxCount++; }
                    const balance = WalletLogic.calculateBalanceFromTxs(incomingTxs, outgoingTxs);
                    document.getElementById('balance-display').textContent = `$${balance.toFixed(2)}`;
                    if (newTxCount > 0) {
                        renderTransactionHistory();
                        if (syncStatusEl) { syncStatusEl.innerHTML = `<span class="success">âš¡ New transaction(s) detected!</span>`; setTimeout(() => { if (syncStatusEl) syncStatusEl.innerHTML = ''; }, 4000); }
                    }
                } catch (error) { if (syncStatusEl) syncStatusEl.innerHTML = '<span class="error">Sync failed. Retrying...</span>'; }
            },
            stop() { if (!this.isRunning) return; clearInterval(this.syncIntervalId); this.syncIntervalId = null; this.isRunning = false; }
        };
        // --- END MODULES ---

        const CoreLogic = (() => { const Constants = { VALIDATION_PREFIX: "SADAT_V2_PART", MAX_IMAGE_DIMENSION: 2000, NUM_QR_CODES: 9 }; const Utils = { arrayBufferToBase64: (b) => btoa(String.fromCharCode(...new Uint8Array(b))), base64ToUint8Array: (s) => { const bs=atob(s); const b=new Uint8Array(bs.length); for(let i=0;i<bs.length;i++)b[i]=bs.charCodeAt(i); return b; }, hexToUint8Array: (h) => new Uint8Array(h.match(/.{1,2}/g).map(b => parseInt(b, 16))), preprocessImage: (d) => new Promise((res, rej) => { const i=new Image(); i.onload=()=>{ const c=document.createElement('canvas'); c.width=i.width; c.height=i.height; const x=c.getContext('2d'); x.filter='grayscale(1) contrast(2.5) brightness(1.1)'; x.drawImage(i,0,0); res(c.toDataURL('image/jpeg')); }; i.onerror=rej; i.src=d; }), resizeImage: (f, m) => new Promise((res, rej) => { const r=new FileReader();r.onload=e=>{const i=new Image();i.onload=()=>{const c=document.createElement('canvas');let{width:w,height:h}=i;if(w>h){if(w>m){h*=m/w;w=m;}}else{if(h>m){w*=m/h;h=m;}}c.width=w;c.height=h;c.getContext('2d').drawImage(i,0,0,w,h);res(c.toDataURL('image/jpeg'));};i.onerror=rej;i.src=e.target.result;};r.onerror=rej;r.readAsDataURL(f);}), }; const Crypto = { hashMessageForSigning: (m) => Utils.hexToUint8Array(shake256(m, 1536)), async verifySignature(sig, data, pk, api) { const h=this.hashMessageForSigning(data); return api.verify(sig, h, pk); } }; const Banknote = { getStandardizedDataForSigning: (d) => JSON.stringify({timestamp:d.timestamp,serial:d.serial},['timestamp','serial']), getStandardizedDataForMasterSig: (d) => { const t={ephemeralPublicKey:Utils.arrayBufferToBase64(d.ephemeralPublicKey),signatureOne:Utils.arrayBufferToBase64(d.signatureOne)}; return JSON.stringify(t, Object.keys(t).sort()); }, parsePayload: (b64) => { const c=Utils.base64ToUint8Array(b64); const j=pako.inflate(c,{to:'string'}); const p=JSON.parse(j); return {amount:p.a,serial:p.s,timestamp:p.t,ephemeralPublicKey:Utils.base64ToUint8Array(p.epk),signatureOne:Utils.base64ToUint8Array(p.s1),signatureTwo:Utils.base64ToUint8Array(p.s2)}; }, getLayout: (w) => { const s=790; const c=w/s; return {qrSize:Math.round(250*c),xSpacing:Math.round(20*c),ySpacing:Math.round(20*c)}; }, decodeQrGrid: async (imgData, statusEl) => { const l=Banknote.getLayout(imgData.width); const parts={}; let count=0; const c=document.createElement('canvas'); const x=c.getContext('2d'); c.width=imgData.width;c.height=imgData.height;x.putImageData(imgData,0,0); for(let i=0;i<Constants.NUM_QR_CODES;i++){ statusEl.innerHTML=`<span class="info">Scanning section ${i+1}/${Constants.NUM_QR_CODES}...</span>`; await new Promise(r=>setTimeout(r,5)); const row=Math.floor(i/3),col=i%3,rX=col*(l.qrSize+l.xSpacing),rY=row*(l.qrSize+l.ySpacing),d=x.getImageData(rX,rY,l.qrSize,l.qrSize); const code=jsQR(d.data,d.width,d.height); if(code&&code.data.startsWith(Constants.VALIDATION_PREFIX)){const m=code.data.substring(Constants.VALIDATION_PREFIX.length).match(/^(\d+)\/(\d+):(.*)$/s); if(m){const pN=parseInt(m[1],10);if(!parts[pN]){parts[pN]=m[3];count++;}}} } if(count<Constants.NUM_QR_CODES){throw new Error(`Scan failed. Found ${count}/${Constants.NUM_QR_CODES} sections.`);} let payload=''; for(let i=1;i<=Constants.NUM_QR_CODES;i++){payload+=parts[i];} return payload; } }; return { Constants, Utils, Crypto, Banknote }; })();
        const PinataLedger = (() => { const PINATA_JWT = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySW5mb3JtYXRpb24iOnsiaWQiOiJiZTkzZDRkMC0yYjgzLTQwZDMtYjg5Mi1iMGJiZGVkMTdiZDYiLCJlbWFpbCI6ImExbTNpNXIuYWZnQGdtYWlsLmNvbSIsImVtYWlsX3ZlcmlmaWVkIjp0cnVlLCJwaW5fcG9saWN5Ijp7InJlZ2lvbnMiOlt7ImRlc2lyZWRSZXBsaWNhdGlvbkNvdW50IjoxLCJpZCI6IkZSQTEifSx7ImRlc2lyZWRSZXBsaWNhdGlvbkNvdW50IjoxLCJpZCI6Ik5ZQzEifV0sInZlcnNpb24iOjF9LCJtZmFfZW5hYmxlZCI6ZmFsc2UsInN0YXR1cyI6IkFDVElWRSJ9LCJhdXRoZW50aWNhdGlvblR5cGUiOiJzY29wZWRLZXkiLCJzY29wZWRLZXlLZXkiOiI0Y2UzOTU0ZjIxZGRhYTdlMmM1NiIsInNjb3BlZEtleVNlY3JldCI6ImU3YTA3NmZjZTJjN2Q0NzM0OWY0MTFjYmE5ODE5YmZiNzVjYTY2MzZmYTVhMDdiNDk2MTJmYWU3MjlhZmQxNmIiLCJleHAiOjE3ODcxMzI1NTh9.dV4M4P4LaqxiZ91ye3F4n5oP98sIqGQVA2waPrGDFJc'; const apiCall = async (endpoint, options) => { const response = await fetch(`https://api.pinata.cloud/${endpoint}`, options); if (!response.ok) throw new Error(`Pinata API error! Status: ${response.status}`); return response.json(); }; const recordSpentIdentifier = async (identifier, type) => { const dataToPin = { pinataContent: { identifier, type, status: "spent", timestamp: new Date().toISOString() }, pinataMetadata: { name: `${type}-${identifier}.json`, keyvalues: { identifier } } }; try { await apiCall('pinning/pinJSONToIPFS', { method: 'POST', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${PINATA_JWT}` }, body: JSON.stringify(dataToPin) }); return true; } catch (error) { console.error('Failed to record identifier to Pinata:', error); alert(`Critical Error: Could not write to the public ledger. Transaction cannot be safely completed. Reason: ${error.message}`); return false; } }; const hasBeenSpent = async (identifier) => { try { const result = await apiCall(`data/pinList?metadata[keyvalues]={"identifier":{"value":"${identifier}","op":"eq"}}&status=pinned`, { method: 'GET', headers: { Authorization: `Bearer ${PINATA_JWT}` } }); return result.count > 0; } catch (error) { console.error('Failed to check identifier status on Pinata:', error); alert(`Critical Error: Could not read from the public ledger. Cannot verify transaction safety. Reason: ${error.message}`); return true; } }; const pinConfirmation = async (confirmation) => { const metadata = { name: `confirmation-${confirmation.linkedTxHash}.json`, keyvalues: { type: 'confirmation', txHash: confirmation.linkedTxHash } }; if (confirmation.receiverAddress) metadata.keyvalues.receiverAddress = confirmation.receiverAddress; if (confirmation.senderAddress) metadata.keyvalues.senderAddress = confirmation.senderAddress; const dataToPin = { pinataContent: confirmation, pinataMetadata: metadata }; await apiCall('pinning/pinJSONToIPFS', { method: 'POST', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${PINATA_JWT}` }, body: JSON.stringify(dataToPin) }); }; const findConfirmation = async (txHash) => { const result = await apiCall(`data/pinList?metadata[keyvalues]={"type":{"value":"confirmation","op":"eq"},"txHash":{"value":"${txHash}","op":"eq"}}&status=pinned`, { method: 'GET', headers: { Authorization: `Bearer ${PINATA_JWT}` } }); if (result.count > 0) { const hash = result.rows[0].ipfs_pin_hash; const contentResponse = await fetch(`https://gateway.pinata.cloud/ipfs/${hash}`); return contentResponse.json(); } return null; }; const findIncomingTxs = async (receiverAddress) => { const cacheKey = `incoming_${receiverAddress}`; const strategy = NetworkOptimizer.getSyncStrategy(); if (strategy.useCache) { const cached = CacheManager.get(cacheKey); if (cached) return cached; } const result = await apiCall(`data/pinList?metadata[keyvalues]={"type":{"value":"confirmation","op":"eq"},"receiverAddress":{"value":"${receiverAddress}","op":"eq"}}&status=pinned`, { method: 'GET', headers: { Authorization: `Bearer ${PINATA_JWT}` } }); if (result.count === 0) return []; const txs = await Promise.all(result.rows.map(async (row) => { const content = await(await fetch(`https://gateway.pinata.cloud/ipfs/${row.ipfs_pin_hash}`)).json(); content.timestamp = new Date(row.date_pinned).getTime(); return content; })); if (strategy.useCache) CacheManager.set(cacheKey, txs, strategy.cacheDuration); return txs; }; const findOutgoingTxs = async (senderAddress) => { const cacheKey = `outgoing_${senderAddress}`; const strategy = NetworkOptimizer.getSyncStrategy(); if (strategy.useCache) { const cached = CacheManager.get(cacheKey); if (cached) return cached; } const result = await apiCall(`data/pinList?metadata[keyvalues]={"type":{"value":"confirmation","op":"eq"},"senderAddress":{"value":"${senderAddress}","op":"eq"}}&status=pinned`, { method: 'GET', headers: { Authorization: `Bearer ${PINATA_JWT}` } }); if (result.count === 0) return []; const txs = await Promise.all(result.rows.map(async (row) => { const content = await(await fetch(`https://gateway.pinata.cloud/ipfs/${row.ipfs_pin_hash}`)).json(); content.timestamp = new Date(row.date_pinned).getTime(); return content; })); if (strategy.useCache) CacheManager.set(cacheKey, txs, strategy.cacheDuration); return txs; }; return { recordSpentIdentifier, hasBeenSpent, pinConfirmation, findConfirmation, findIncomingTxs, findOutgoingTxs }; })();
        
        // --- AURA WALLET LOGIC ---
        const AppConstants = { MAX_LOGIN_ATTEMPTS: 5, LOGIN_LOCKOUT_PERIOD: 30000, POLLING_INTERVAL: 5000, PAYMENT_REQUEST_EXPIRY: 9 * 60 * 1000, TREASURY_ADDRESS: '0xF848aC6b7E16CF32A972ECE1529c73313375c6d5', FEE_PERCENTAGE: 0.009, PRECISION: 8, SECURE_STORAGE_KEY: 'aura_user_store_secure_v2' };
        let state = { wallet: null, masterPublicKey: null, userStore: null, falconApi: null, failedLoginAttempts: 0, isLockedOut: false, activePaymentRequest: null, activeManualSend: null, activePollingTimer: null, cameraStream: null, isScannerActive: false, currentBalance: 0, transactionIndex: new Map() };
        
        const WalletLogic = {
            async createWallet(password) {
                const entropy = crypto.getRandomValues(new Uint8Array(32));
                const wallet = ethers.Wallet.createRandom({ entropy });
                const userStore = { publicKey: wallet.publicKey, address: wallet.address, encryptedJson: wallet.encryptSync(password, { scrypt: { N: 65536 } }), chain: [{ hash: ethers.id("GENESIS_BLOCK"), type: 'creation', timestamp: Date.now() }] };
                const encryptedPayload = await SecurityManager.encryptSensitiveData(userStore, password);
                localStorage.setItem(AppConstants.SECURE_STORAGE_KEY, JSON.stringify(encryptedPayload));
                state.userStore = userStore;
                state.wallet = wallet;
                this.buildTransactionIndex();
                return { mnemonic: wallet.mnemonic.phrase };
            },
            async restoreWallet(mnemonic, password) {
                try {
                    const wallet = ethers.Wallet.fromPhrase(mnemonic);
                    const userStore = { publicKey: wallet.publicKey, address: wallet.address, encryptedJson: wallet.encryptSync(password, { scrypt: { N: 65536 } }), chain: [{ hash: ethers.id("GENESIS_BLOCK"), type: 'creation', timestamp: Date.now() }] };
                    const encryptedPayload = await SecurityManager.encryptSensitiveData(userStore, password);
                    localStorage.setItem(AppConstants.SECURE_STORAGE_KEY, JSON.stringify(encryptedPayload));
                    state.userStore = userStore;
                    state.wallet = wallet;
                    this.buildTransactionIndex();
                    return true;
                } catch (e) { console.error("Restore failed:", e); return false; }
            },
            async login(password) {
                const encryptedStoreJSON = localStorage.getItem(AppConstants.SECURE_STORAGE_KEY);
                if (!encryptedStoreJSON) return null;
                try {
                    const encryptedPayload = JSON.parse(encryptedStoreJSON);
                    const decryptedStore = await SecurityManager.decryptSensitiveData(encryptedPayload, password);
                    const wallet = await ethers.Wallet.fromEncryptedJson(decryptedStore.encryptedJson, password);
                    // Address verification check
                    if (wallet.address !== decryptedStore.address) throw new Error("Decryption failed: address mismatch.");
                    
                    state.userStore = decryptedStore;
                    state.wallet = wallet;
                    state.failedLoginAttempts = 0;
                    this.buildTransactionIndex();
                    return true;
                } catch (e) { console.error("Login failed:", e); state.failedLoginAttempts++; return false; }
            },
            logout() { BackgroundSync.stop(); state.wallet = null; state.userStore = null; state.transactionIndex.clear(); },
            buildTransactionIndex() {
                state.transactionIndex.clear();
                if (!state.userStore?.chain) return;
                state.userStore.chain.forEach(tx => state.transactionIndex.set(tx.linkedTxHash || tx.hash, tx));
            },
            addToChain(txData) {
                const prevTx = state.userStore.chain[state.userStore.chain.length - 1];
                const newTx = { ...txData, prevHash: prevTx.hash, timestamp: txData.timestamp || Date.now() };
                const amountInt = ethers.parseUnits((newTx.amount || 0).toFixed(AppConstants.PRECISION), AppConstants.PRECISION);
                const feeInt = ethers.parseUnits((newTx.fee || 0).toFixed(AppConstants.PRECISION), AppConstants.PRECISION);
                newTx.hash = ethers.solidityPackedKeccak256(['string', 'uint256', 'uint256', 'string', 'string', 'string'], [newTx.type, amountInt, feeInt, newTx.from || '', newTx.to || '', newTx.prevHash]);
                state.userStore.chain.push(newTx);
                state.transactionIndex.set(newTx.linkedTxHash || newTx.hash, newTx);
                // Note: Storing the unencrypted userStore in memory is a trade-off. Re-encrypting on every change is slow.
                // For this app's lifecycle, we accept this risk and re-encrypt on major state changes if needed.
                return newTx;
            },
            calculateBalanceFromTxs: (incoming, outgoing) => {
                const incomingTotal = incoming.reduce((sum, tx) => sum + (Number(tx.amount) || 0), 0);
                const outgoingTotal = outgoing.reduce((sum, tx) => sum + (Number(tx.amount) || 0), 0);
                state.currentBalance = incomingTotal - outgoingTotal;
                return state.currentBalance;
            },
            async processPayment(request) {
                const fee = request.amount * AppConstants.FEE_PERCENTAGE;
                const totalDebit = request.amount + fee;
                if (Date.now() > request.expiresAt) throw new Error("Payment request has expired.");
                if (state.currentBalance < totalDebit) throw new Error(`Insufficient funds. You need $${totalDebit.toFixed(2)}.`);
                if (await PinataLedger.hasBeenSpent(request.linkedTxHash)) throw new Error("This payment request has already been processed.");
                const sendTx = this.addToChain({ type: 'send', amount: request.amount, fee, from: state.wallet.address, to: request.receiverAddress, status: 'completed', linkedTxHash: request.linkedTxHash });
                const success = await PinataLedger.recordSpentIdentifier(request.linkedTxHash, 'transaction');
                if (!success) throw new Error("CRITICAL: Payment sent but failed to update public ledger.");
                const confirmation = { type: 'AURA_PAYMENT_CONFIRMATION', senderAddress: state.wallet.address, receiverAddress: request.receiverAddress, amount: request.amount, linkedTxHash: request.linkedTxHash };
                const { signedPayload, signature } = await SecurityManager.secureSignMessage(JSON.stringify(confirmation), state.wallet);
                await PinataLedger.pinConfirmation({ signedPayload, signature });
                const feeConfirmation = { type: 'AURA_FEE_CONFIRMATION', senderAddress: state.wallet.address, receiverAddress: AppConstants.TREASURY_ADDRESS, amount: fee, linkedTxHash: sendTx.hash + "-fee" };
                const { signedPayload: feeSignedPayload, signature: feeSignature } = await SecurityManager.secureSignMessage(JSON.stringify(feeConfirmation), state.wallet);
                await PinataLedger.pinConfirmation({ signedPayload: feeSignedPayload, signature: feeSignature });
                CacheManager.invalidate(state.wallet.address);
                return true;
            },
            async processDiscoveredTransaction(confirmation) {
                const { signedPayload, signature } = confirmation;
                if (!signedPayload || !signature) return false; // Skip non-standard txs
                const parsedPayload = JSON.parse(signedPayload.message);
                if (parsedPayload.receiverAddress !== state.wallet.address) return false;
                const txKey = parsedPayload.linkedTxHash || parsedPayload.hash;
                if (state.transactionIndex.has(txKey)) return false;
                await SecurityManager.verifySignedMessage(signedPayload, signature, parsedPayload.senderAddress);
                this.addToChain({ type: parsedPayload.type === 'AURA_BANKNOTE_CHARGE' ? 'charge' : 'receive', amount: parsedPayload.amount, from: parsedPayload.senderAddress, to: parsedPayload.receiverAddress, status: 'completed', linkedTxHash: parsedPayload.linkedTxHash, timestamp: signedPayload.timestamp });
                return true;
            }
        };

        // --- UI & APP LOGIC ---
        function setLoader(loaderId, isLoading) { document.getElementById(loaderId).classList.toggle('hidden', !isLoading); }
        function resetViewInputs(viewId) { const view = document.getElementById(viewId); if (view) { view.querySelectorAll('input, textarea').forEach(input => { if (input.type !== 'file') input.value = ''; }); const statusBox = view.querySelector('.status-box'); if (statusBox) statusBox.innerHTML = ''; } }
        async function updateBalanceAndRender() { try { const [incoming, outgoing] = await Promise.all([PinataLedger.findIncomingTxs(state.wallet.address), PinataLedger.findOutgoingTxs(state.wallet.address)]); const balance = WalletLogic.calculateBalanceFromTxs(incoming, outgoing); document.getElementById('balance-display').textContent = `$${balance.toFixed(2)}`; renderTransactionHistory(); } catch (error) { console.error("Update failed:", error); document.getElementById('balance-display').textContent = 'Error'; } }
        function generateQrCode(data, containerId) { const container = document.getElementById(containerId); container.innerHTML = ''; const qr = qrcode(0, 'L'); qr.addData(data); qr.make(); container.innerHTML = qr.createImgTag(6, 10); }
        function abbreviateAddress(address) { return address ? `${address.substring(0, 6)}...${address.substring(address.length - 4)}` : ''; }
        function stopScanner() { if (state.cameraStream) { state.cameraStream.getTracks().forEach(track => track.stop()); state.cameraStream = null; state.isScannerActive = false; } }
        
        async function showView(id) { 
            stopScanner();
            if (state.activePollingTimer) { clearInterval(state.activePollingTimer); state.activePollingTimer = null; } 
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            const viewElement = document.getElementById(id);
            if(viewElement) viewElement.classList.add('active'); 

            if (id === 'wallet-view') { 
                document.getElementById('balance-display').textContent = 'Loading...';
                if(state.wallet) document.getElementById('address-display').textContent = abbreviateAddress(state.wallet.address);
                await updateBalanceAndRender();
                BackgroundSync.start();
            }
            if (id === 'send-view') {
                // startScanner() logic will be here...
            }
            if (id === 'receive-view' && state.wallet) {
                document.getElementById('full-receive-address').textContent = state.wallet.address;
                generateQrCode(state.wallet.address, 'static-qr-code');
            }
        }
        
        function renderTransactionHistory() { /* ... function body remains the same ... */ }
        function showTransactionDetails(tx) { /* ... function body remains the same ... */ }

        async function initializeApp() {
            try {
                SecurityManager.setupAntiTampering();
                const lockTime = localStorage.getItem('security_lock');
                if (lockTime && Date.now() - parseInt(lockTime) < 300000) { // 5 min lock
                    throw new Error('Wallet is temporarily locked due to a prior security violation.');
                }
                localStorage.removeItem('security_lock');
                await SecurityManager.performSecurityChecks();
                state.falconApi = await pqcSignFalcon1024();
                
                setupEventListeners();
                if (localStorage.getItem(AppConstants.SECURE_STORAGE_KEY)) {
                    showView('login-view');
                } else {
                    showView('onboarding-view');
                }
            } catch (error) {
                console.error('CRITICAL ERROR:', error.message);
                document.getElementById('app-container').innerHTML = `<div class="card" style="border-color: var(--danger-color);"><h1>Security Error</h1><p>${error.message}</p><p>This application cannot run.</p></div>`;
            }
        }

        function setupEventListeners() {
            // All button event listeners go here.
            // They need to be updated to use the new async and secure functions.
            
            // Example for create wallet button
            document.getElementById('create-wallet-button').addEventListener('click', async () => {
                const statusEl = document.getElementById('create-status');
                const pass = document.getElementById('create-password-input').value;
                const confirmPass = document.getElementById('confirm-password-input').value;

                if (pass.length < 12) { statusEl.innerHTML = '<span class="error">Password must be at least 12 characters.</span>'; return; }
                if (pass !== confirmPass) { statusEl.innerHTML = '<span class="error">Passwords do not match.</span>'; return; }
                
                setLoader('create-loader', true);
                try {
                    const { mnemonic } = await WalletLogic.createWallet(pass);
                    const secureMnemonic = { value: mnemonic, destroy: () => this.value = null }; // Simple in-memory protection
                    document.getElementById('seed-phrase-display').textContent = secureMnemonic.value;
                    showView('seed-phrase-view');
                    // In a real app, you'd handle the destruction of secureMnemonic more carefully.
                } catch (err) {
                    statusEl.innerHTML = `<span class="error">Creation failed: ${err.message}</span>`;
                } finally {
                    setLoader('create-loader', false);
                }
            });
            
            // Example for login button
            document.getElementById('login-button').addEventListener('click', async () => {
                const statusEl = document.getElementById('login-status');
                if (SecurityManager.isRateLimited('login', 5, 60000)) {
                    statusEl.innerHTML = `<span class="error">Too many attempts. Please wait a minute.</span>`;
                    return;
                }
                const pass = document.getElementById('login-password-input').value;
                setLoader('login-loader', true);
                statusEl.innerHTML = '<span class="info">Decrypting wallet...</span>';
                
                const success = await WalletLogic.login(pass);
                
                if (success) {
                    await showView('wallet-view');
                    resetViewInputs('login-view');
                } else {
                    statusEl.innerHTML = `<span class="error">Invalid password.</span>`;
                }
                setLoader('login-loader', false);
            });
            
            // Other event listeners (restore, logout, send, etc.) should be similarly updated
            document.getElementById('logout-button').addEventListener('click', () => { WalletLogic.logout(); showView('login-view'); });
            document.getElementById('reset-app-button').addEventListener('click', () => { if (confirm('Are you sure? All wallet data will be erased from this browser.')) { localStorage.removeItem(AppConstants.SECURE_STORAGE_KEY); location.reload(); } });
            // ... and so on for all other interactive elements.
        }

        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>
