<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
    <meta charset="UTF-8">
    <title>Sadat Digital Banknote [Upgraded] (Falcon-512 + JAB Code)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <script src="jabcodeJSLib.min.js"></script>
    <script src="jszip.min.js"></script>
    <style>
        :root {
            --primary-font: 'Poppins', 'Segoe UI', sans-serif;
            --mono-font: 'Roboto Mono', monospace;
            --dark-bg: #10101a;
            --medium-bg: #1a1a2e;
            --light-bg: #2a2a3e;
            --accent-color-1: #e040fb;
            --accent-color-2: #7c4dff;
            --text-color: #e0e0e0;
            --text-muted: #a0a0c0;
            --success-color: #00e676;
            --error-color: #ff5252;
            --info-color: #40c4ff;
            --border-color: rgba(124, 77, 255, 0.2);
        }
        body { margin: 0; font-family: var(--primary-font); background-color: var(--dark-bg); background-image: radial-gradient(at 0% 0%, hsla(253, 100%, 15%, 0.3) 0px, transparent 50%), radial-gradient(at 100% 100%, hsla(263, 100%, 20%, 0.3) 0px, transparent 50%); color: var(--text-color); text-align: center; padding: 24px; }
        .container { max-width: 900px; margin: 0 auto; background: rgba(26, 26, 46, 0.7); backdrop-filter: blur(12px); padding: 24px; border-radius: 24px; border: 1px solid var(--border-color); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2); }
        .header { border-bottom: 1px solid var(--border-color); padding-bottom: 16px; margin-bottom: 24px; }
        h1 { font-size: 2.5rem; font-weight: 600; color: #fff; margin: 0 0 8px 0; letter-spacing: 1px; background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .header p { font-size: 1rem; color: var(--text-muted); margin: 0; }
        canvas { border-radius: 16px; margin-top: 24px; background: #050508; cursor: default; box-shadow: 0 0 50px rgba(124, 77, 255, 0.15); width: 100%; max-width: 900px; height: auto; border: 1px solid var(--border-color); }
        input, button, label { padding: 14px 22px; font-size: 16px; font-family: var(--primary-font); border-radius: 12px; margin: 8px 5px; border: 1px solid var(--border-color); background: var(--medium-bg); color: #fff; transition: all 0.3s ease; cursor: pointer; outline: none; display: inline-flex; align-items: center; justify-content: center; gap: 8px; }
        input[type="number"], input[type="text"] { font-family: var(--mono-font); font-weight: 700; text-align: center; width: 150px; }
        input:focus { border-color: var(--accent-color-2); box-shadow: 0 0 15px rgba(124, 77, 255, 0.5); }
        button:not([disabled]), label:not([disabled]) { font-weight: 600; background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); border: none; box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        button.sub-button, label.sub-button { background: var(--light-bg); border: 1px solid var(--border-color); }
        button[disabled], label[disabled] { cursor: not-allowed; opacity: 0.5; background: var(--light-bg); border: 1px solid var(--border-color); }
        button:hover:not([disabled]), label:hover:not([disabled]) { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(124, 77, 255, 0.4); }
        .section { background: rgba(16, 16, 26, 0.5); padding: 20px; margin-top: 30px; border-radius: 16px; border: 1px solid var(--border-color); }
        h2 { font-size: 1.5rem; color: var(--text-color); margin-top: 0; margin-bottom: 20px; font-weight: 600; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        .controls-grid { display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 16px; }
        #validation-result, #key-status { margin-top: 20px; font-size: 12px; font-weight: normal; min-height: 50px; line-height: 1.6; text-align: left; background: var(--dark-bg); padding: 15px 20px; border-radius: 12px; white-space: pre-wrap; font-family: var(--mono-font); border: 1px solid var(--border-color); transition: all 0.3s ease; }
        .valid { color: var(--success-color); }
        .invalid { color: var(--error-color); }
        .info { color: var(--info-color); }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>Sadat Digital Banknote</h1>
            <p>A secure, verifiable digital currency concept using Falcon-512 Signatures and **JAB Code** technology.</p>
        </div>

        <canvas id="noteCanvas" width="1350" height="750"></canvas>

        <div class="section">
            <h2>Banknote Controls</h2>
            <div class="controls-grid">
                <span class="input-label">Amount:</span>
                <input type="number" id="amount-input" value="50000">
                <button id="create-note-button" disabled>üé® Redesign Banknote</button>
                <button id="download-package-button" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                    Download Banknote Package
                </button>
            </div>
        </div>

        <div class="section">
            <h2>Bank Key Management</h2>
            <div class="controls-grid">
                <button id="generate-keys-button">üîë Generate & Export Keys</button>
                <label for="import-public-key" class="sub-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                    Import Public Key
                </label>
                <input type="file" id="import-public-key" accept=".json" style="display: none;">
                <label for="import-private-key" class="sub-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                    Import Private Key
                </label>
                <input type="file" id="import-private-key" accept=".json" style="display: none;">
            </div>
            <div id="key-status">Key pair status will be displayed here.</div>
        </div>

        <div class="section" id="validator-section">
            <h2>Validate Banknote</h2>
            <label for="validator-input">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
                Select Banknote Image for Validation
            </label>
            <input type="file" id="validator-input" accept="image/png" style="display: none;">
            <div id="validation-result">Validation result will be displayed here.</div>
        </div>
    </div>

    <script type="module">
        import pqcSignFalcon512 from './falcon.js';
        import { shake256 } from 'https://cdn.skypack.dev/js-sha3';
        
        // --- UTILITY FUNCTIONS ---
        const Utils = {
            arrayBufferToBase64: (buffer) => btoa(String.fromCharCode(...new Uint8Array(buffer))),
            base64ToUint8Array: (base64) => {
                const binary_string = window.atob(base64);
                const bytes = new Uint8Array(binary_string.length);
                for (let i = 0; i < binary_string.length; i++) {
                    bytes[i] = binary_string.charCodeAt(i);
                }
                return bytes;
            },
            hexToUint8Array: (hex) => new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16))),
            uint8ArrayToHex: (bytes) => Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join(''),
            H: (text, index, min, max) => min + (parseInt(text.substring(index, index + 2), 16) % (max - min + 1))
        };

        /**
         * ## UIManager Class
         * Manages all direct interactions with the DOM to keep logic separate from presentation.
         */
        class UIManager {
            constructor() {
                this.elements = {
                    keyStatus: document.getElementById('key-status'),
                    validationResult: document.getElementById('validation-result'),
                    createNoteBtn: document.getElementById('create-note-button'),
                    downloadBtn: document.getElementById('download-package-button')
                };
            }

            setStatus(element, type, message) {
                const el = this.elements[element];
                if (el) {
                    el.innerHTML = `<span class="${type}">${message}</span>`;
                }
            }

            updateControlsState(isEnabled) {
                this.elements.createNoteBtn.disabled = !isEnabled;
                this.elements.downloadBtn.disabled = !isEnabled;
            }

            setButtonLoading(buttonId, isLoading) {
                const button = document.getElementById(buttonId);
                if (!isLoading) {
                    if (button.dataset.originalHtml) {
                        button.innerHTML = button.dataset.originalHtml;
                    }
                    button.disabled = false;
                } else {
                    button.dataset.originalHtml = button.innerHTML;
                    button.innerHTML = `‚è≥ Working...`;
                    button.disabled = true;
                }
            }
        }

        /**
         * ## CryptoManager Class
         * Encapsulates all cryptographic operations including hashing, signing, and key management.
         */
        class CryptoManager {
            constructor() {
                this.falconApi = null;
                this.AES_ALGO = "AES-GCM";
                this.PBKDF2_ITERATIONS = 100000;
                this.PBKDF2_HASH_ALGO = "SHA-256";
                this.AES_KEY_LENGTH = 256;
            }

            async init() {
                this.falconApi = await pqcSignFalcon512();
            }

            hashMessage(message) {
                const hexHash = shake256(message, 1024);
                return Utils.hexToUint8Array(hexHash);
            }

            getStandardizedData(noteData) {
                const dataToSign = {
                    amount: noteData.amount,
                    serial: noteData.serial,
                    timestamp: noteData.timestamp,
                    verificationKey: noteData.verificationKey
                };
                return JSON.stringify(dataToSign, Object.keys(dataToSign).sort());
            }
            
            async generateNewKeyPair() {
                if (!this.falconApi) throw new Error("Falcon API not initialized.");
                return await this.falconApi.keypair();
            }

            async signData(data, privateKey) {
                const dataHash = this.hashMessage(data);
                const { signature } = await this.falconApi.sign(dataHash, privateKey);
                return signature;
            }

            async verifySignature(signature, data, publicKey) {
                const dataHash = this.hashMessage(data);
                return await this.falconApi.verify(signature, dataHash, publicKey);
            }
            
            async encryptPrivateKey(privateKeyBytes, password) {
                const passwordBuffer = new TextEncoder().encode(password);
                const salt = window.crypto.getRandomValues(new Uint8Array(16));
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                const keyMaterial = await window.crypto.subtle.importKey("raw", passwordBuffer, { name: "PBKDF2" }, false, ["deriveKey"]);
                const derivedKey = await window.crypto.subtle.deriveKey(
                    { name: "PBKDF2", salt, iterations: this.PBKDF2_ITERATIONS, hash: this.PBKDF2_HASH_ALGO },
                    keyMaterial, { name: this.AES_ALGO, length: this.AES_KEY_LENGTH }, true, ["encrypt", "decrypt"]
                );
                const keyObject = { keyData: Utils.arrayBufferToBase64(privateKeyBytes) };
                const encryptedKey = await window.crypto.subtle.encrypt({ name: this.AES_ALGO, iv }, derivedKey, new TextEncoder().encode(JSON.stringify(keyObject)));
                return {
                    cipherText: Utils.arrayBufferToBase64(encryptedKey),
                    salt: Utils.arrayBufferToBase64(salt),
                    iv: Utils.arrayBufferToBase64(iv)
                };
            }

            async decryptPrivateKey(encryptedData, password) {
                const passwordBuffer = new TextEncoder().encode(password);
                const salt = Utils.base64ToUint8Array(encryptedData.salt);
                const iv = Utils.base64ToUint8Array(encryptedData.iv);
                const cipherText = Utils.base64ToUint8Array(encryptedData.cipherText);
                const keyMaterial = await window.crypto.subtle.importKey("raw", passwordBuffer, { name: "PBKDF2" }, false, ["deriveKey"]);
                const derivedKey = await window.crypto.subtle.deriveKey(
                    { name: "PBKDF2", salt, iterations: this.PBKDF2_ITERATIONS, hash: this.PBKDF2_HASH_ALGO },
                    keyMaterial, { name: this.AES_ALGO, length: this.AES_KEY_LENGTH }, true, ["encrypt", "decrypt"]
                );
                const decryptedKeyBuffer = await window.crypto.subtle.decrypt({ name: this.AES_ALGO, iv }, derivedKey, cipherText);
                const keyObject = JSON.parse(new TextDecoder().decode(decryptedKeyBuffer));
                return Utils.base64ToUint8Array(keyObject.keyData);
            }
        }

        /**
         * ## BanknoteApp Class
         * The main application controller.
         */
        class BanknoteApp {
            constructor() {
                this.canvas = document.getElementById("noteCanvas");
                this.ctx = this.canvas.getContext("2d");
                this.ui = new UIManager();
                this.crypto = new CryptoManager();
                this.jabcode = new JabcodeJSInterface();

                this.state = {
                    currentNoteData: {},
                    activeKeys: { publicKey: null, privateKey: null }
                };
            }

            async init() {
                this.ui.updateControlsState(false);
                this.ui.setStatus('keyStatus', 'info', '‚è≥ Loading Falcon-512 Crypto Module...');
                try {
                    await this.crypto.init();
                    this.ui.setStatus('keyStatus', 'info', 'Ready. Please generate a new key pair or import existing keys to begin.');
                } catch (e) {
                    console.error("Failed to load Falcon module:", e);
                    this.ui.setStatus('keyStatus', 'invalid', `‚ùå Critical Error: Could not load Falcon-512 module. Check 'falcon.js' and console.`);
                    alert("Error: Failed to load cryptographic module.");
                    return;
                }
                this.attachEventListeners();
            }

            attachEventListeners() {
                document.getElementById('generate-keys-button').addEventListener('click', () => this.handleGenerateAndExportKeys());
                document.getElementById('create-note-button').addEventListener('click', () => this.handleCreateNewNote());
                document.getElementById('download-package-button').addEventListener('click', () => this.handleDownloadPackage(false));
                document.getElementById('import-public-key').addEventListener('change', (e) => this.handleImportKey(e, 'public'));
                document.getElementById('import-private-key').addEventListener('change', (e) => this.handleImportKey(e, 'private'));
                document.getElementById('validator-input').addEventListener('change', (e) => this.handleFileValidation(e));
            }

            async handleGenerateAndExportKeys() {
                const password = prompt("Create a strong password to encrypt the private key file for export:");
                if (!password) {
                    this.ui.setStatus('keyStatus', 'invalid', '‚ùå Key generation cancelled. A password is required.');
                    return;
                }
                await this.handleDownloadPackage(true, password);
            }

            async handleDownloadPackage(generateNewKeys = false, keyPassword = null) {
                const buttonId = generateNewKeys ? 'generate-keys-button' : 'download-package-button';
                this.ui.setButtonLoading(buttonId, true);
                try {
                    if (generateNewKeys) {
                        this.ui.setStatus('keyStatus', 'info', '‚è≥ Generating new Falcon-512 key pair...');
                        this.state.activeKeys = await this.crypto.generateNewKeyPair();
                    }
                    if (!this.state.activeKeys.privateKey) throw new Error("No active private key.");

                    const password = keyPassword || prompt("Enter a password to encrypt the private key for this download:");
                    if (!password) throw new Error("Download cancelled. A password is required.");
                    
                    this.ui.setStatus('keyStatus', 'info', 'üì¶ Creating banknote package files...');
                    
                    if (Object.keys(this.state.currentNoteData).length === 0) {
                        await this.handleCreateNewNote(false);
                    }

                    const banknoteBlob = await new Promise(resolve => this.canvas.toBlob(resolve, 'image/png'));
                    const noteSerial = this.state.currentNoteData.serial || 'banknote';

                    const files = [
                        { name: `${noteSerial}_banknote.png`, data: banknoteBlob },
                        { name: `${noteSerial}_data.json`, data: JSON.stringify(this.state.currentNoteData, null, 2) },
                        { name: `${noteSerial}_public_key.json`, data: JSON.stringify({ keyData: Utils.arrayBufferToBase64(this.state.activeKeys.publicKey) }, null, 2) },
                        { name: `${noteSerial}_private_key_encrypted.json`, data: JSON.stringify(await this.crypto.encryptPrivateKey(this.state.activeKeys.privateKey, password), null, 2) }
                    ];

                    if ('showDirectoryPicker' in window) {
                        const dirHandle = await window.showDirectoryPicker();
                        for (const file of files) {
                            const fileHandle = await dirHandle.getFileHandle(file.name, { create: true });
                            const writable = await fileHandle.createWritable();
                            await writable.write(file.data);
                            await writable.close();
                        }
                        this.ui.setStatus('keyStatus', 'valid', '‚úÖ Banknote package saved successfully to the chosen directory.');
                    } else {
                        const zip = new JSZip();
                        files.forEach(file => zip.file(file.name, file.data));
                        const zipBlob = await zip.generateAsync({ type: "blob" });
                        const a = document.createElement('a');
                        a.href = URL.createObjectURL(zipBlob);
                        a.download = `${noteSerial}_package.zip`;
                        a.click();
                        URL.revokeObjectURL(a.href);
                        this.ui.setStatus('keyStatus', 'valid', `‚úÖ Banknote package downloaded as ${noteSerial}_package.zip.`);
                    }
                    
                    if (generateNewKeys) {
                        this.ui.updateControlsState(true);
                        await this.handleCreateNewNote();
                    }
                } catch (e) {
                    if (e.name !== 'AbortError') this.ui.setStatus('keyStatus', 'invalid', `‚ùå Failed: ${e.message}`);
                    else this.ui.setStatus('keyStatus', 'info', 'Cancelled.');
                } finally {
                    this.ui.setButtonLoading(buttonId, false);
                }
            }
            
            async handleImportKey(event, keyType) {
                const file = event.target.files[0];
                if (!file) return;
                
                const processFile = async (fileContent) => {
                    try {
                        if (keyType === 'public') {
                            const data = JSON.parse(fileContent);
                            if (!data.keyData) throw new Error("Invalid public key file format.");
                            this.state.activeKeys.publicKey = Utils.base64ToUint8Array(data.keyData);
                            this.ui.setStatus('keyStatus', 'valid', '‚úÖ Public key imported. Ready for validation.');
                        } else {
                            const password = prompt("Enter password to decrypt private key:");
                            if (!password) throw new Error("Import cancelled. Password required.");
                            this.ui.setStatus('keyStatus', 'info', '‚è≥ Decrypting private key...');
                            const encryptedData = JSON.parse(fileContent);
                            this.state.activeKeys.privateKey = await this.crypto.decryptPrivateKey(encryptedData, password);
                            this.ui.setStatus('keyStatus', 'valid', '‚úÖ Private key imported. Ready for signing.');
                            this.ui.updateControlsState(true);
                        }
                    } catch (error) {
                         this.ui.setStatus('keyStatus', 'invalid', `‚ùå Import failed: ${error.message}`);
                    } finally {
                        event.target.value = '';
                    }
                };
                
                const reader = new FileReader();
                reader.onload = (e) => processFile(e.target.result);
                reader.readAsText(file);
            }

            async handleFileValidation(event) {
                 const file = event.target.files[0];
                 if (!file || !this.state.activeKeys.publicKey) {
                     alert("Error: A public key must be active for validation.");
                     return;
                 }
                 this.ui.setStatus('validationResult', 'info', '‚è≥ Reading banknote image...');

                 const img = new Image();
                 img.onload = async () => {
                     const tempCanvas = document.createElement('canvas');
                     tempCanvas.width = 1350; tempCanvas.height = 750;
                     tempCanvas.getContext('2d').drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);

                     this.ui.setStatus('validationResult', 'info', '1. Reading digital data from JAB Code...');
                     
                     const noteData = await this.readJabCodeFromCanvas(tempCanvas);
                     if (!noteData) {
                         this.ui.setStatus('validationResult', 'invalid', '‚ùå FATAL ERROR: JAB Code not found or unreadable.');
                         return;
                     }
                     
                     let resultHTML = `<span class="valid">‚úÖ 1. JAB Code data read successfully.</span>`;
                     resultHTML += `\n\n<span class="info">2. Verifying digital signature (Falcon-512)...</span>`;
                     this.ui.setStatus('validationResult', null, resultHTML);

                     const stringToVerify = this.crypto.getStandardizedData(noteData);
                     const signatureBytes = Utils.base64ToUint8Array(noteData.signature);
                     const isSignatureValid = await this.crypto.verifySignature(signatureBytes, stringToVerify, this.state.activeKeys.publicKey);

                     if (!isSignatureValid) {
                         resultHTML += `\n<span class="invalid">‚ùå FATAL ERROR: Digital signature is invalid. Forgery detected.</span>`;
                     } else {
                         resultHTML += `\n<span class="valid">‚úÖ 2. Digital signature confirmed. Authenticity verified.</span>`;
                     }
                     resultHTML += `\n<hr style="border-color: var(--border-color); border-style: dashed; margin: 15px 0 10px;">\n<span style="font-size: 14px; font-weight: 600;">${isSignatureValid ? '‚úÖ VERDICT: Banknote is authentic.' : '‚ùå VERDICT: Forgery detected.'}</span>`;
                     this.ui.setStatus('validationResult', null, resultHTML);
                 };
                 img.src = URL.createObjectURL(file);
                 event.target.value = '';
            }

            async readJabCodeFromCanvas(canvasToCheck) {
                try {
                    const imageDataUri = canvasToCheck.toDataURL('image/png');
                    const base64Compressed = await this.jabcode.decode_message(imageDataUri);
                    const compressedData = new Uint8Array(atob(base64Compressed).split("").map(char => char.charCodeAt(0)));
                    const jsonString = pako.inflate(compressedData, { to: 'string' });
                    return JSON.parse(jsonString);
                } catch (error) {
                    console.error("JAB Code decoding/decompression failed:", error);
                    return null;
                }
            }

            async handleCreateNewNote(updateStatus = true) {
                if (updateStatus) this.ui.setStatus('keyStatus', 'info', '‚è≥ Generating new banknote...');
                const amount = document.getElementById("amount-input").value;
                
                const now = Date.now();
                const noteData = {
                    amount: parseInt(amount) || 0,
                    verificationKey: "SVK-" + Math.random().toString(16).substring(2, 10).toUpperCase(),
                    serial: "SDT-" + now.toString().slice(-8),
                    timestamp: now
                };
                
                const stringToSign = this.crypto.getStandardizedData(noteData);
                const signatureBytes = await this.crypto.signData(stringToSign, this.state.activeKeys.privateKey);
                noteData.signature = Utils.arrayBufferToBase64(signatureBytes);
                noteData.visualHash = Utils.uint8ArrayToHex(this.crypto.hashMessage(noteData.signature));

                if (noteData) {
                    this.state.currentNoteData = noteData;
                    await this.drawNoteOnCanvas(noteData);
                    if (updateStatus) this.ui.setStatus('keyStatus', 'valid', '‚úÖ New banknote design is ready.');
                } else {
                    if (updateStatus) this.ui.setStatus('keyStatus', 'invalid', '‚ùå Failed to create a new banknote.');
                }
            }

            async drawNoteOnCanvas(noteData) {
                const { amount, verificationKey, serial, visualHash } = noteData;
                const w = this.canvas.width, h = this.canvas.height, scale = w / 1350;

                const bgGradient = this.ctx.createLinearGradient(0, 0, 0, h);
                const baseHue = Utils.H(visualHash, 0, 0, 360);
                bgGradient.addColorStop(0, `hsl(${baseHue}, 50%, 6%)`);
                bgGradient.addColorStop(1, `hsl(${baseHue}, 40%, 4%)`);
                this.ctx.fillStyle = bgGradient;
                this.ctx.fillRect(0, 0, w, h);
                
                // Redraw decorative elements
                this.drawWatermark(visualHash, w, h);
                this.drawKochGuilloche(visualHash, w, h);
                this.drawNoisePattern(visualHash, w, h);

                this.ctx.shadowColor = "rgba(0,0,0,0.7)"; this.ctx.shadowBlur = 8 * scale; this.ctx.shadowOffsetX = 2 * scale; this.ctx.shadowOffsetY = 2 * scale;
                this.ctx.fillStyle = "#EAEAEA"; this.ctx.font = `bold ${80*scale}px 'Roboto Mono'`; this.ctx.textAlign = 'left';
                this.ctx.fillText(serial.substring(4), 150 * scale, 160 * scale);
                this.ctx.fillText(verificationKey.substring(4), 150 * scale, 280 * scale);
                this.ctx.font = `bold ${150*scale}px 'Roboto Mono'`; this.ctx.textAlign = "right";
                this.ctx.shadowBlur = 12 * scale; this.ctx.shadowOffsetX = 4 * scale; this.ctx.shadowOffsetY = 4 * scale;
                this.ctx.fillText(amount.toString(), w - (120 * scale), 190 * scale);
                this.ctx.shadowColor = "transparent";

                // --- JAB Code Generation with Compression ---
                const jsonString = JSON.stringify(noteData);
                const compressedData = pako.deflate(jsonString);
                const base64Compressed = btoa(String.fromCharCode.apply(null, compressedData));
                const jabCodeDataUri = this.jabcode.encode_message(base64Compressed, null, 4); // Force 4-color version
                
                const jabCodeImg = new Image();
                return new Promise((resolve) => {
                    jabCodeImg.onload = () => {
                        const codeSize = 420 * scale;
                        const codeX = 800 * scale;
                        const codeY = 210 * scale;
                        this.ctx.fillStyle = 'white';
                        this.ctx.beginPath();
                        this.ctx.roundRect(codeX - (10 * scale), codeY - (10 * scale), codeSize + (20 * scale), codeSize + (20 * scale), [12 * scale]);
                        this.ctx.fill();
                        this.ctx.drawImage(jabCodeImg, codeX, codeY, codeSize, codeSize);

                        this.ctx.font = `${30*scale}px 'Roboto Mono'`;
                        this.ctx.fillStyle = "rgba(255,255,255,0.4)";
                        this.ctx.textAlign = "center";
                        this.ctx.fillText("Digitally Signed by Sadat Bank Authority (Falcon-512)", w / 2, h - 60 * scale);
                        resolve();
                    };
                    jabCodeImg.src = jabCodeDataUri;
                });
            }

            drawKochGuilloche(hash, w, h) { this.ctx.save(); this.ctx.translate(w / 2, h / 2); const s = w / 1350, it = Utils.H(hash, 2, 2, 4), sz = w * (Utils.H(hash, 4, 10, 20) / 100), aO = (Utils.H(hash, 6, 0, 360) / 360) * Math.PI * 2, nL = Utils.H(hash, 8, 3, 6), hO = Utils.H(hash, 10, 0, 360); const d = (x1, y1, x2, y2, l) => { if (l === 0) { this.ctx.lineTo(x2, y2); return } const dx = x2 - x1, dy = y2 - y1, di = Math.sqrt(dx * dx + dy * dy), ux = dx / di, uy = dy / di, p1x = x1 + ux * di / 3, p1y = y1 + uy * di / 3, p2x = x1 + ux * di * 2 / 3, p2y = y1 + uy * di * 2 / 3, p3x = p1x + ux * di / 6 - uy * di * Math.sqrt(3) / 6, p3y = p1y + uy * di / 6 + ux * di * Math.sqrt(3) / 6; d(x1, y1, p1x, p1y, l - 1); d(p1x, p1y, p3x, p3y, l - 1); d(p3x, p3y, p2x, p2y, l - 1); d(p2x, p2y, x2, y2, l - 1) }; this.ctx.lineWidth = 1 * s; this.ctx.lineJoin = 'bevel'; this.ctx.lineCap = 'round'; for (let i = 0; i < nL; i++) { const hu = (hO + i * (360 / nL)) % 360; this.ctx.strokeStyle = `hsla(${hu},70%,60%,0.15)`; const lA = (i / nL) * Math.PI * 2 + aO, x1 = Math.cos(lA) * sz, y1 = Math.sin(lA) * sz, x2 = Math.cos(lA + Math.PI) * sz, y2 = Math.sin(lA + Math.PI) * sz; this.ctx.beginPath(); this.ctx.moveTo(x1, y1); d(x1, y1, x2, y2, it); this.ctx.stroke() } this.ctx.restore() }
            drawWatermark(hash, w, h) { this.ctx.save(); this.ctx.translate(w / 2, h / 2); const s = w / 1350, nS = Utils.H(hash, 16, 3, 6), sR = w * (Utils.H(hash, 18, 10, 25) / 100) * s, hu = Utils.H(hash, 20, 0, 360); this.ctx.strokeStyle = `hsla(${hu},50%,80%,0.05)`; this.ctx.lineWidth = 4 * s; for (let i = 0; i < nS; i++) { this.ctx.beginPath(); const sA = (i / nS) * Math.PI * 2 + Utils.H(hash, 22, 0, 100) / 100, eA = sA + Utils.H(hash, 24, 6, 12) * Math.PI; for (let t = sA; t < eA; t += 0.05) { const r = sR * (t - sA) / (eA - sA), x = r * Math.cos(t), y = r * Math.sin(t); if (t === sA) this.ctx.moveTo(x, y); else this.ctx.lineTo(x, y) } this.ctx.stroke() } this.ctx.restore() }
            drawNoisePattern(hash, w, h) { this.ctx.save(); for (let i = 0; i < 20000; i++) { const x = Math.random() * w, y = Math.random() * h, o = Math.random() * 0.15, hue = Utils.H(hash, (i % 30) + 4, 0, 360); this.ctx.fillStyle = `hsla(${hue},50%,80%,${o})`; this.ctx.fillRect(x, y, 1, 1) } this.ctx.restore() }
        }

        // --- Start the application ---
        const app = new BanknoteApp();
        app.init();

    </script>
</body>
</html>
