<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>Ø§Ø³Ú©Ù†Ø§Ø³ Ø¯ÛŒØ¬ÛŒØªØ§Ù„ Ø³Ø§Ø¯Ø§Øª - Ø³ÛŒØ³ØªÙ… 3-JAB</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>

    <style>
        :root {
            --primary-font: 'Poppins', 'Segoe UI', sans-serif;
            --mono-font: 'Roboto Mono', monospace;
            --dark-bg: #10101a;
            --medium-bg: #1a1a2e;
            --light-bg: #2a2a3e;
            --accent-color-1: #e040fb;
            --accent-color-2: #7c4dff;
            --text-color: #e0e0e0;
            --text-muted: #a0a0c0;
            --success-color: #00e676;
            --error-color: #ff5252;
            --info-color: #40c4ff;
            --warning-color: #ffab40;
            --border-color: rgba(124, 77, 255, 0.2);
        }
        body { 
            margin: 0; 
            font-family: var(--primary-font); 
            background-color: var(--dark-bg); 
            background-image: radial-gradient(at 0% 0%, hsla(253, 100%, 15%, 0.3) 0px, transparent 50%), radial-gradient(at 100% 100%, hsla(263, 100%, 20%, 0.3) 0px, transparent 50%); 
            color: var(--text-color); 
            text-align: center; 
            padding: 24px; 
        }
        .container { max-width: 1200px; margin: 0 auto; background: rgba(26, 26, 46, 0.7); backdrop-filter: blur(12px); padding: 24px; border-radius: 24px; border: 1px solid var(--border-color); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2); }
        .header { border-bottom: 1px solid var(--border-color); padding-bottom: 16px; margin-bottom: 24px; text-align: right; }
        h1 { font-size: 2.5rem; font-weight: 600; color: #fff; margin: 0 0 8px 0; letter-spacing: 1px; background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .header p { font-size: 1rem; color: var(--text-muted); margin: 0; }
        canvas#noteCanvas { border-radius: 16px; margin-top: 24px; background: #050508; cursor: default; box-shadow: 0 0 50px rgba(124, 77, 255, 0.15); width: 100%; max-width: 1200px; height: auto; border: 1px solid var(--border-color); }
        input, button, label { padding: 14px 22px; font-size: 16px; font-family: var(--primary-font); border-radius: 12px; margin: 8px 5px; border: 1px solid var(--border-color); background: var(--medium-bg); color: #fff; transition: all 0.3s ease; cursor: pointer; outline: none; display: inline-flex; align-items: center; justify-content: center; gap: 8px; }
        input[type="number"], input[type="password"] { font-family: var(--mono-font); font-weight: 700; text-align: center; width: 150px; }
        input:focus { border-color: var(--accent-color-2); box-shadow: 0 0 15px rgba(124, 77, 255, 0.5); }
        button:not([disabled]), label.button:not([disabled]) { font-weight: 600; background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); border: none; box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        button.sub-button, label.button.sub-button { background: var(--light-bg); border: 1px solid var(--border-color); }
        button[disabled], label.button[disabled] { cursor: not-allowed; opacity: 0.5; background: var(--light-bg); border: 1px solid var(--border-color); }
        button:hover:not([disabled]), label.button:hover:not([disabled]) { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(124, 77, 255, 0.4); }
        .section { background: rgba(16, 16, 26, 0.5); padding: 20px; margin-top: 30px; border-radius: 16px; border: 1px solid var(--border-color); text-align: right; }
        h2 { font-size: 1.5rem; color: var(--text-color); margin-top: 0; margin-bottom: 20px; font-weight: 600; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        .controls-grid { display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 16px; }
        .status-box { margin-top: 20px; font-size: 13px; font-weight: normal; min-height: 50px; line-height: 1.6; text-align: left; background: var(--dark-bg); padding: 15px 20px; border-radius: 12px; white-space: pre-wrap; font-family: var(--mono-font); border: 1px solid var(--border-color); transition: all 0.3s ease; }
        .valid { color: var(--success-color); } .invalid { color: var(--error-color); } .info { color: var(--info-color); } .warning { color: var(--warning-color); }
        code { background: var(--medium-bg); padding: 2px 6px; border-radius: 4px; font-size: 1em; }
        .input-label { font-size: 0.9rem; color: var(--text-muted); margin-left: -10px; margin-right: 5px;}
        .modal { position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; text-align: right; }
        .modal-content { background-color: var(--medium-bg); padding: 30px; border: 1px solid var(--border-color); width: 80%; max-width: 500px; border-radius: 16px; text-align: center; }
        #jab-display { margin: 20px auto; background: white; padding: 15px; border-radius: 8px; width: fit-content; }
        #jab-display img { max-width: 100%; height: auto; }
        .pill { background-color: var(--border-color); color: var(--accent-color-1); padding: 5px 15px; border-radius: 20px; font-size: 14px; font-weight: 600; margin: 5px; display: inline-block; }
    </style>
</head>
<body>
<div class="container">
    <div class="header"><h1>Ø§Ø³Ú©Ù†Ø§Ø³ Ø¯ÛŒØ¬ÛŒØªØ§Ù„ Ø³Ø§Ø¯Ø§Øª</h1><p>ÛŒÚ© Ø³ÛŒØ³ØªÙ… Ø§Ø±Ø² Ø¯ÛŒØ¬ÛŒØªØ§Ù„ Ø¢ÙÙ„Ø§ÛŒÙ†ØŒ Ù…Ù‚Ø§ÙˆÙ… Ø¯Ø± Ø¨Ø±Ø§Ø¨Ø± Ù…Ø­Ø§Ø³Ø¨Ø§Øª Ú©ÙˆØ§Ù†ØªÙˆÙ…ÛŒØŒ Ø¨Ø§ Ø§Ù…Ø¶Ø§ÛŒ Ø¯ÙˆÚ¯Ø§Ù†Ù‡ Ùˆ <strong>Ú©Ø¯ Multi-JAB</strong>.</p></div>
    <div class="section"><h2><span class="pill">Ù…Ø±Ø­Ù„Ù‡ Û±</span> Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ù†Ú¯Ù‡Ø¨Ø§Ù†: Ø³Ø§Ø®Øª Ú©Ù„ÛŒØ¯Ù‡Ø§ÛŒ Ø§ØµÙ„ÛŒ</h2><div class="controls-grid"><button id="generate-keys-button">ğŸ”‘ Ø³Ø§Ø®Øª Ø¬ÙØª Ú©Ù„ÛŒØ¯ Ø§ØµÙ„ÛŒ</button><label for="import-public-key" class="button sub-button"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg> Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ú©Ù„ÛŒØ¯ Ø¹Ù…ÙˆÙ…ÛŒ</label><input type="file" id="import-public-key" accept=".json" style="display: none;"></div><div id="key-gen-status" class="status-box"><span class="info">â„¹ï¸ Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯ Ù†Ú¯Ù‡Ø¨Ø§Ù†. Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ Ø§Ú©ÙˆØ³ÛŒØ³ØªÙ… Ù…Ø§Ù„ÛŒ Ø®ÙˆØ¯ØŒ ÛŒÚ© Ø¬ÙØª Ú©Ù„ÛŒØ¯ Ø§ØµÙ„ÛŒ Ø¬Ø¯ÛŒØ¯ Ø¨Ø³Ø§Ø²ÛŒØ¯. Ø§ÛŒÙ† ÙØ±Ø¢ÛŒÙ†Ø¯ Ú©Ø§Ù…Ù„Ø§Ù‹ Ø¢ÙÙ„Ø§ÛŒÙ† Ùˆ Ø§Ù…Ù† Ø§Ø³Øª.</span></div></div>
    <div class="section"><h2><span class="pill">Ù…Ø±Ø­Ù„Ù‡ Û²</span> ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ø³ÛŒØ³ØªÙ…: Ø¨Ø§Ø²Ø³Ø§Ø²ÛŒ Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ</h2><p style="color: var(--text-muted); font-size: 0.9em; max-width: 700px; margin: -10px auto 20px auto;">Ø¨Ø±Ø§ÛŒ Ø³Ø§Ø®Øª Ø§Ø³Ú©Ù†Ø§Ø³ØŒ Ø¨Ø§ÛŒØ¯ Ù‡ÙˆÛŒØª Ø®ÙˆØ¯ Ø±Ø§ Ø¨Ø§ Ø­Ù„ "Ù¾Ø§Ø²Ù„ Ø³Ù‡â€ŒØªÚ©Ù‡" Ø§Ø«Ø¨Ø§Øª Ú©Ù†ÛŒØ¯. Ø§ÛŒÙ† Ú©Ø§Ø± Ø­Ø¯Ø§Ú©Ø«Ø± Ø§Ù…Ù†ÛŒØª Ø±Ø§ ØªØ¶Ù…ÛŒÙ† Ù…ÛŒâ€ŒÚ©Ù†Ø¯.</p><div class="controls-grid"><label for="file-key-input" class="button sub-button">Û±. Ø¢Ù¾Ù„ÙˆØ¯ Ú©Ù„ÛŒØ¯ ÙØ§ÛŒÙ„ÛŒ</label><input type="file" id="file-key-input" accept=".json" style="display:none;" /><input type="password" id="password-key-input" placeholder="Û². ÙˆØ±ÙˆØ¯ Ú©Ù„ÛŒØ¯ Ø±Ù…Ø²Ø¹Ø¨ÙˆØ±"><label for="visual-key-input" class="button sub-button">Û³. Ø¢Ù¾Ù„ÙˆØ¯ Ú©Ù„ÛŒØ¯ Ø¨ØµØ±ÛŒ (JAB)</label><input type="file" id="visual-key-input" accept="image/png, image/jpeg" style="display:none;" /></div><button id="reconstruct-key-button" disabled style="margin-top: 20px;">ğŸ”“ ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ Ø§ØµÙ„ÛŒ</button><div id="key-reconstruction-status" class="status-box"><span class="warning">âš ï¸ Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ Ø§ØµÙ„ÛŒ ØºÛŒØ±ÙØ¹Ø§Ù„ Ø§Ø³Øª. Ø¨Ø±Ø§ÛŒ ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ù¾Ø§Ø²Ù„ Ø±Ø§ Ø­Ù„ Ú©Ù†ÛŒØ¯.</span></div></div>
    <div class="section"><h2><span class="pill">Ù…Ø±Ø­Ù„Ù‡ Û³</span> Ø®Ù„Ù‚ Ø«Ø±ÙˆØª: ØªÙˆÙ„ÛŒØ¯ Ø§Ø³Ú©Ù†Ø§Ø³</h2><div class="controls-grid"><span class="input-label">Ù…Ø¨Ù„Øº:</span><input type="number" id="amount-input" value="50000"><span class="input-label">ØªØ¹Ø¯Ø§Ø¯:</span><input type="number" id="quantity-input" value="1" min="1" max="100"><button id="create-note-button" disabled>ğŸ¨ Ø³Ø§Ø®Øª Ùˆ Ù†Ù…Ø§ÛŒØ´ Ø§Ø³Ú©Ù†Ø§Ø³</button><button id="download-batch-button" disabled>ğŸ“¥ Ø¯Ø§Ù†Ù„ÙˆØ¯ Ø¯Ø³ØªÙ‡â€ŒØ§ÛŒ</button></div><div id="banknote-status" class="status-box">Ø§Ø² Ú©Ù†ØªØ±Ù„â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ù„Ø§ Ø¨Ø±Ø§ÛŒ Ø³Ø§Ø®Øª Ùˆ Ø§Ù…Ø¶Ø§ÛŒ Ø§Ø³Ú©Ù†Ø§Ø³â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯.</div><canvas id="noteCanvas" width="1200" height="533"></canvas></div>
    <div class="section" id="validator-section"><h2><span class="pill">Ù…Ø±Ø­Ù„Ù‡ Û´</span> ØªØ£ÛŒÛŒØ¯ Ø§Ø¹ØªØ¨Ø§Ø±</h2><p style="color: var(--text-muted); font-size: 0.9em; max-width: 700px; margin: -10px auto 20px auto;">Ø¨Ø±Ø§ÛŒ ØªØ£ÛŒÛŒØ¯ ÛŒÚ© Ø§Ø³Ú©Ù†Ø§Ø³ØŒ ØªØµÙˆÛŒØ± ÙˆØ§Ø¶Ø­ÛŒ Ø§Ø² <strong>Ú©Ù„ Ø§Ø³Ú©Ù†Ø§Ø³</strong> Ø±Ø§ Ø¢Ù¾Ù„ÙˆØ¯ Ú©Ù†ÛŒØ¯. Ø³ÛŒØ³ØªÙ… ØªÙ…Ø§Ù… Ú©Ø¯Ù‡Ø§ÛŒ Jab Ø±Ø§ Ù¾ÛŒØ¯Ø§ Ùˆ Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ø®ÙˆØ§Ù‡Ø¯ Ú©Ø±Ø¯.</p><label for="validator-input" class="button"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 15 17 10"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg> Ø§Ù†ØªØ®Ø§Ø¨ ØªØµÙˆÛŒØ± Ø§Ø³Ú©Ù†Ø§Ø³ Ø¨Ø±Ø§ÛŒ Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ</label><input type="file" id="validator-input" accept="image/png, image/jpeg" style="display: none;"><div id="validation-result" class="status-box">Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± Ø§Ø³Ú©Ù†Ø§Ø³ Ø¨Ø±Ø§ÛŒ Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ...</div></div>
</div>
<div id="jab-modal" class="modal"><div class="modal-content"><h2 id="jab-modal-title">Ú©Ù„ÛŒØ¯ Ø¨ØµØ±ÛŒ Ø´Ù…Ø§</h2><p>Ø§ÛŒÙ† Ú©Ø¯ Jab Ø±Ø§ Ú†Ø§Ù¾ Ú©Ø±Ø¯Ù‡ ÛŒØ§ ÙØ§ÛŒÙ„ ØªØµÙˆÛŒØ± Ø±Ø§ Ø¯Ø± Ù…Ú©Ø§Ù†ÛŒ ÙÛŒØ²ÛŒÚ©ÛŒ Ùˆ Ø§Ù…Ù† Ù†Ú¯Ù‡Ø¯Ø§Ø±ÛŒ Ú©Ù†ÛŒØ¯. Ø§ÛŒÙ† Ù‚Ø·Ø¹Ù‡ Ø³ÙˆÙ… Ù¾Ø§Ø²Ù„ Ú©Ù„ÛŒØ¯ Ø§ØµÙ„ÛŒ Ø´Ù…Ø§Ø³Øª.</p><div id="jab-display"></div><button id="download-jab-button" style="margin-top: 15px;">ğŸ’¾ Ø¯Ø§Ù†Ù„ÙˆØ¯ Ú©Ø¯ Jab</button><button onclick="document.getElementById('jab-modal').style.display='none'">Ø¨Ø³ØªÙ†</button></div></div>

<script type="module">
// --- DEPENDENCIES ---
import pqcSignFalcon1024 from './pqc-sign-falcon-1024.min.js';
import JabcodeJSInterface from './jabcodeJSLib.min.js';
import { shake256 } from 'https://cdn.skypack.dev/js-sha3';

// --- Global State ---
const state = {
    falconApi: null,
    jabInterface: null,
    masterPublicKey: null,
    masterPrivateKey: null,
    puzzlePieces: { fileKey: null, passwordKey: null, visualKey: null }
};

// --- CONSTANTS ---
const Constants = {
    FALCON_PUBKEY_SIZE: 1793,
    EPOCH: new Date('2024-01-01T00:00:00Z').getTime(),
    VALIDATION_PREFIX: "SADAT_V2_PART",
    NUM_JABS: 6, 
    MAX_IMAGE_DIMENSION: 2000
};

// --- DOM Elements ---
const DOMElements = {
    generateKeysButton: document.getElementById('generate-keys-button'),
    importPublicKey: document.getElementById('import-public-key'),
    keyGenStatus: document.getElementById('key-gen-status'),
    fileKeyInput: document.getElementById('file-key-input'),
    passwordKeyInput: document.getElementById('password-key-input'),
    visualKeyInput: document.getElementById('visual-key-input'),
    reconstructKeyButton: document.getElementById('reconstruct-key-button'),
    keyReconstructionStatus: document.getElementById('key-reconstruction-status'),
    amountInput: document.getElementById('amount-input'),
    quantityInput: document.getElementById('quantity-input'),
    createNoteButton: document.getElementById('create-note-button'),
    downloadBatchButton: document.getElementById('download-batch-button'),
    noteCanvas: document.getElementById('noteCanvas'),
    banknoteStatus: document.getElementById('banknote-status'),
    validatorInput: document.getElementById('validator-input'),
    validationResult: document.getElementById('validation-result'),
    jabModal: document.getElementById('jab-modal'),
    jabDisplay: document.getElementById('jab-display'),
    jabModalTitle: document.getElementById('jab-modal-title'),
    downloadJabButton: document.getElementById('download-jab-button')
};

// --- Utility Functions ---
const Utils = {
    arrayBufferToBase64: (buffer) => btoa(String.fromCharCode(...new Uint8Array(buffer))),
    base64ToUint8Array: (base64) => {
        const binaryString = atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i);
        return bytes;
    },
    hexToUint8Array: (hex) => new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16))),
    downloadFile: (data, filename, type) => {
        const blob = new Blob([data], { type });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = filename;
        document.body.appendChild(a); a.click();
        document.body.removeChild(a); URL.revokeObjectURL(url);
    },
    updateStatus: (element, message, type = 'info') => {
        element.innerHTML = `<span class="${type}">${message}</span>`;
    },
    log: (message, type = 'info') => {
        const icon = { info: 'â„¹ï¸', success: 'âœ…', warning: 'âš ï¸', error: 'âŒ' }[type];
        console.log(`[Sadat System] ${icon} ${message}`);
    },
    async resizeImage(file, maxSize) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            const reader = new FileReader();
            reader.onload = (e) => {
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    let { width, height } = img;
                    if (width > height) {
                        if (width > maxSize) {
                            height *= maxSize / width;
                            width = maxSize;
                        }
                    } else {
                        if (height > maxSize) {
                            width *= maxSize / height;
                            height = maxSize;
                        }
                    }
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    resolve(canvas.toDataURL('image/jpeg'));
                };
                img.src = e.target.result;
            };
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });
    },
    async createJabImage(payload, options = {}) {
        const dataUrl = state.jabInterface.encode_message(payload, options);
        const img = new Image();
        img.src = dataUrl;
        await new Promise((resolve, reject) => {
            img.onload = resolve;
            img.onerror = reject;
        });
        return img;
    },
    async decodeJabFromImage(file) {
      return new Promise((resolve, reject) => {
        if (!file) {
          return reject(new Error("No file provided for decoding."));
        }
        const reader = new FileReader();
        reader.onload = async (event) => {
          try {
            const dataUrl = event.target.result;
            const decodedText = await state.jabInterface.decode_message(dataUrl);
            resolve(decodedText);
          } catch (error) {
            reject(error);
          }
        };
        reader.onerror = () => {
          reject(new Error("FileReader failed to read the file."));
        };
        reader.readAsDataURL(file);
      });
    }
};

// --- CORE CRYPTO ENGINE (Unchanged) ---
const BankCrypto = (() => {
    const AES_ALGO = "AES-GCM";
    const PBKDF2_ITERATIONS = 100000;
    const PBKDF2_KEY_LENGTH = 32;
    async function pbkdf2DeriveKey(password, salt) {
        const passwordBuffer = new TextEncoder().encode(password);
        const importedKey = await crypto.subtle.importKey("raw", passwordBuffer, { name: "PBKDF2" }, false, ["deriveKey"]);
        return await crypto.subtle.deriveKey({ name: "PBKDF2", salt: salt, iterations: PBKDF2_ITERATIONS, hash: "SHA-256" }, importedKey, { name: AES_ALGO, length: 256 }, false, ["encrypt", "decrypt"]);
    }
    function hashMessageForSigning(message) { return Utils.hexToUint8Array(shake256(message, 1536)); }
    return {
        async generateNewKeyPair() {
            if (!state.falconApi) throw new Error("Falcon API not initialized.");
            return state.falconApi.keypair();
        },
        async signData(data, privateKey) {
            if (!privateKey || !state.falconApi) throw new Error("Signing prerequisites not met.");
            const dataHash = hashMessageForSigning(data);
            const { signature } = await state.falconApi.sign(dataHash, privateKey);
            return signature;
        },
        async verifySignature(signature, data, publicKey) {
            if (!publicKey || !state.falconApi) throw new Error("Verification prerequisites not met.");
            const dataHash = hashMessageForSigning(data);
            return state.falconApi.verify(signature, dataHash, publicKey);
        },
        async encryptMasterKey(masterPrivateKeyBytes, passwordKey, visualKeySecret) {
            const visualKeySalt = crypto.getRandomValues(new Uint8Array(16));
            const visualKeyIV = crypto.getRandomValues(new Uint8Array(12));
            const cryptoVisualKey = await pbkdf2DeriveKey(visualKeySecret, visualKeySalt);
            const encryptedWithVisual = await crypto.subtle.encrypt({ name: AES_ALGO, iv: visualKeyIV }, cryptoVisualKey, masterPrivateKeyBytes);
            const intermediatePayload = JSON.stringify({ encryptedKey: Utils.arrayBufferToBase64(encryptedWithVisual), salt: Utils.arrayBufferToBase64(visualKeySalt), iv: Utils.arrayBufferToBase64(visualKeyIV) });
            const passwordSalt = crypto.getRandomValues(new Uint8Array(16));
            const passwordIV = crypto.getRandomValues(new Uint8Array(12));
            const cryptoPasswordKey = await pbkdf2DeriveKey(passwordKey, passwordSalt);
            const finalEncryptedKey = await crypto.subtle.encrypt({ name: AES_ALGO, iv: passwordIV }, cryptoPasswordKey, new TextEncoder().encode(intermediatePayload));
            return { fileKey: { cipherText: Utils.arrayBufferToBase64(finalEncryptedKey), salt: Utils.arrayBufferToBase64(passwordSalt), iv: Utils.arrayBufferToBase64(passwordIV) } };
        },
        async reconstructMasterKey(fileKey, passwordKey, visualKeySecret) {
            const passwordSalt = Utils.base64ToUint8Array(fileKey.salt);
            const passwordIV = Utils.base64ToUint8Array(fileKey.iv);
            const passwordCipherText = Utils.base64ToUint8Array(fileKey.cipherText);
            const cryptoPasswordKey = await pbkdf2DeriveKey(passwordKey, passwordSalt);
            const decryptedIntermediateBuffer = await crypto.subtle.decrypt({ name: AES_ALGO, iv: passwordIV }, cryptoPasswordKey, passwordCipherText);
            const intermediatePayload = JSON.parse(new TextDecoder().decode(decryptedIntermediateBuffer));
            const visualKeySalt = Utils.base64ToUint8Array(intermediatePayload.salt);
            const visualKeyIV = Utils.base64ToUint8Array(intermediatePayload.iv);
            const visualCipherText = Utils.base64ToUint8Array(intermediatePayload.encryptedKey);
            const cryptoVisualKey = await pbkdf2DeriveKey(visualKeySecret, visualKeySalt);
            const masterPrivateKeyBytes = await crypto.subtle.decrypt({ name: AES_ALGO, iv: visualKeyIV }, cryptoVisualKey, visualCipherText);
            return new Uint8Array(masterPrivateKeyBytes);
        }
    };
})();

// --- UI EVENT HANDLERS ---
const UIHandlers = (() => {
    function updatePuzzleStatus() {
        const { fileKey, passwordKey, visualKey } = state.puzzlePieces;
        let statusHtml = '';
        statusHtml += fileKey ? '<span class="valid">âœ… Ú©Ù„ÛŒØ¯ ÙØ§ÛŒÙ„ÛŒ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯.</span>\n' : '<span class="invalid">âŒ Ú©Ù„ÛŒØ¯ ÙØ§ÛŒÙ„ÛŒ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù†Ø´Ø¯Ù‡.</span>\n';
        statusHtml += passwordKey ? '<span class="valid">âœ… Ú©Ù„ÛŒØ¯ Ø±Ù…Ø²Ø¹Ø¨ÙˆØ± ÙˆØ§Ø±Ø¯ Ø´Ø¯.</span>\n' : '<span class="invalid">âŒ Ú©Ù„ÛŒØ¯ Ø±Ù…Ø²Ø¹Ø¨ÙˆØ± ÙˆØ§Ø±Ø¯ Ù†Ø´Ø¯Ù‡.</span>\n';
        statusHtml += visualKey ? '<span class="valid">âœ… Ú©Ù„ÛŒØ¯ Ø¨ØµØ±ÛŒ Ø§Ø³Ú©Ù† Ø´Ø¯.</span>\n' : '<span class="invalid">âŒ Ú©Ù„ÛŒØ¯ Ø¨ØµØ±ÛŒ Ø§Ø³Ú©Ù† Ù†Ø´Ø¯Ù‡.</span>\n';
        DOMElements.keyReconstructionStatus.innerHTML = statusHtml;
        const allPiecesProvided = fileKey && passwordKey && visualKey;
        DOMElements.reconstructKeyButton.disabled = !allPiecesProvided;
        if (allPiecesProvided) {
            Utils.updateStatus(DOMElements.keyReconstructionStatus, "âš ï¸ ØªÙ…Ø§Ù… Ù‚Ø·Ø¹Ø§Øª Ù¾Ø§Ø²Ù„ ÙØ±Ø§Ù‡Ù… Ø´Ø¯Ù‡. Ø¨Ø±Ø§ÛŒ Ø¨Ø§Ø² Ú©Ø±Ø¯Ù† Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒØŒ Ø±ÙˆÛŒ 'ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ' Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯.", 'warning');
        }
    }
    
    return {
        handleGenerateAndExportKeys: async () => {
            const password = prompt("ÛŒÚ© Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ù‚ÙˆÛŒ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯. Ø§ÛŒÙ† 'Ú©Ù„ÛŒØ¯ Ø±Ù…Ø²Ø¹Ø¨ÙˆØ±' Ø´Ù…Ø§ Ø®ÙˆØ§Ù‡Ø¯ Ø¨ÙˆØ¯ (Ù‚Ø·Ø¹Ù‡ Û²/Û³).");
            if (!password) { Utils.updateStatus(DOMElements.keyGenStatus, 'âŒ Ø³Ø§Ø®Øª Ú©Ù„ÛŒØ¯ Ù„ØºÙˆ Ø´Ø¯. Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª.', 'error'); return; }
            Utils.updateStatus(DOMElements.keyGenStatus, 'â³ Ø¯Ø± Ø­Ø§Ù„ Ø³Ø§Ø®Øª Ø¬ÙØª Ú©Ù„ÛŒØ¯ Falcon-1024...', 'info');
            try {
                const keyPair = await BankCrypto.generateNewKeyPair();
                state.masterPublicKey = keyPair.publicKey;
                Utils.log("Ø¬ÙØª Ú©Ù„ÛŒØ¯ Ø§ØµÙ„ÛŒ Ø¬Ø¯ÛŒØ¯ Ø³Ø§Ø®ØªÙ‡ Ø´Ø¯.", 'success');
                Utils.updateStatus(DOMElements.keyGenStatus, 'â³ Ø¯Ø± Ø­Ø§Ù„ Ø³Ø§Ø®Øª Ù‚Ø·Ø¹Ø§Øª Ù¾Ø§Ø²Ù„ Ùˆ Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ...', 'info');
                const visualKeySecret = crypto.randomUUID();
                const { fileKey } = await BankCrypto.encryptMasterKey(keyPair.privateKey, password, visualKeySecret);
                const publicKeyB64 = Utils.arrayBufferToBase64(keyPair.publicKey);
                Utils.downloadFile(JSON.stringify({ masterPublicKey: publicKeyB64 }, null, 2), 'Sadat-MASTER-PUBLIC-KEY.json', 'application/json');
                Utils.downloadFile(JSON.stringify(fileKey, null, 2), 'Sadat-FILE-KEY.json', 'application/json');
                DOMElements.jabModalTitle.innerText = "Ú©Ù„ÛŒØ¯ Ø¨ØµØ±ÛŒ Ø´Ù…Ø§ (Ù‚Ø·Ø¹Ù‡ Û³/Û³)";
                DOMElements.jabDisplay.innerHTML = '';
                const jabOptions = { securityLevel: 1 };
                const jabImage = await Utils.createJabImage(visualKeySecret, jabOptions);
                DOMElements.jabDisplay.appendChild(jabImage);
                DOMElements.jabModal.style.display = 'flex';
                Utils.updateStatus(DOMElements.keyGenStatus, `âœ… Ø¬ÙØª Ú©Ù„ÛŒØ¯ Ø¬Ø¯ÛŒØ¯ Ø³Ø§Ø®ØªÙ‡ Ø´Ø¯!\n- MASTER-PUBLIC-KEY.json (Ø§ÛŒÙ† Ø±Ø§ Ø¨Ù‡ Ø§Ø´ØªØ±Ø§Ú© Ø¨Ú¯Ø°Ø§Ø±ÛŒØ¯)\n- FILE-KEY.json (Ø§ÛŒÙ† Ø±Ø§ Ø±ÙˆÛŒ USB Ù†Ú¯Ù‡ Ø¯Ø§Ø±ÛŒØ¯)\n- Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± (Ø§ÛŒÙ† Ø±Ø§ Ø¨Ù‡ Ø®Ø§Ø·Ø± Ø¨Ø³Ù¾Ø§Ø±ÛŒØ¯)\n- Ú©Ø¯ Ø¨ØµØ±ÛŒ Jab (Ø§ÛŒÙ† Ø±Ø§ Ú†Ø§Ù¾ Ùˆ Ø§Ù…Ù† Ú©Ù†ÛŒØ¯)\nÚ©Ù„ÛŒØ¯ Ø¹Ù…ÙˆÙ…ÛŒ Ø¬Ø¯ÛŒØ¯ Ø§Ú©Ù†ÙˆÙ† Ø¨Ø±Ø§ÛŒ Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ ÙØ¹Ø§Ù„ Ø§Ø³Øª.`, 'success');
            } catch (e) {
                Utils.log(`Ø³Ø§Ø®Øª Ú©Ù„ÛŒØ¯ Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯: ${e.message}`, 'error');
                Utils.updateStatus(DOMElements.keyGenStatus, `âŒ Ø®Ø·Ø§ Ø¯Ø± Ø³Ø§Ø®Øª Ú©Ù„ÛŒØ¯: ${e.message}`, 'error');
            }
        },
        handleImportPublicKey: async (event) => { const file = event.target.files[0]; if (!file) return; try { const data = JSON.parse(await file.text()); if (!data.masterPublicKey) throw new Error("ÙØ±Ù…Øª ÙØ§ÛŒÙ„ Ú©Ù„ÛŒØ¯ Ø¹Ù…ÙˆÙ…ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª."); state.masterPublicKey = Utils.base64ToUint8Array(data.masterPublicKey); Utils.updateStatus(DOMElements.keyGenStatus, 'âœ… Ú©Ù„ÛŒØ¯ Ø¹Ù…ÙˆÙ…ÛŒ ÙˆØ§Ø±Ø¯ Ø´Ø¯. Ø¢Ù…Ø§Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ø§Ø³Ú©Ù†Ø§Ø³.', 'success'); DOMElements.validatorInput.disabled = false; } catch (error) { Utils.updateStatus(DOMElements.keyGenStatus, `âŒ Ø®Ø·Ø§ Ø¯Ø± ÙˆØ±ÙˆØ¯ Ú©Ù„ÛŒØ¯ Ø¹Ù…ÙˆÙ…ÛŒ: ${error.message}`, 'error'); } event.target.value = ''; },
        handleFileKeyInput: async (event) => { const file = event.target.files[0]; if (!file) return; try { state.puzzlePieces.fileKey = JSON.parse(await file.text()); Utils.log("Ú©Ù„ÛŒØ¯ ÙØ§ÛŒÙ„ÛŒ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯.", 'success'); } catch(e) { state.puzzlePieces.fileKey = null; Utils.log(`Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ú©Ù„ÛŒØ¯ ÙØ§ÛŒÙ„ÛŒ: ${e.message}`, 'error'); } updatePuzzleStatus(); event.target.value = ''; },
        handlePasswordKeyInput: (event) => { state.puzzlePieces.passwordKey = event.target.value || null; updatePuzzleStatus(); },
        handleVisualKeyInput: async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            try {
                const decodedText = await Utils.decodeJabFromImage(file);
                state.puzzlePieces.visualKey = decodedText;
                Utils.log("Ú©Ù„ÛŒØ¯ Ø¨ØµØ±ÛŒ Ø§Ø² Ú©Ø¯ Jab Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯.", 'success');
            } catch (error) {
                state.puzzlePieces.visualKey = null;
                Utils.log(`Ø®Ø·Ø§ Ø¯Ø± Ø±Ù…Ø²Ú¯Ø´Ø§ÛŒÛŒ Ú©Ø¯ Jab: ${error.message}`, 'error');
            } finally {
                updatePuzzleStatus();
                event.target.value = '';
            }
        },
        handleReconstructKey: async () => {
            const { fileKey, passwordKey, visualKey } = state.puzzlePieces;
            if (!fileKey || !passwordKey || !visualKey) { Utils.updateStatus(DOMElements.keyReconstructionStatus, "âŒ Ù‡Ø± Ø³Ù‡ Ù‚Ø·Ø¹Ù‡ Ù¾Ø§Ø²Ù„ Ø§Ù„Ø²Ø§Ù…ÛŒ Ù‡Ø³ØªÙ†Ø¯.", 'error'); return; }
            Utils.updateStatus(DOMElements.keyReconstructionStatus, "â³ Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø²Ø³Ø§Ø²ÛŒ Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ Ø§ØµÙ„ÛŒ...", 'info');
            try {
                state.masterPrivateKey = await BankCrypto.reconstructMasterKey(fileKey, passwordKey, visualKey);
                const testData = new TextEncoder().encode("test");
                const testSig = await BankCrypto.signData(testData, state.masterPrivateKey);
                const isTestValid = await BankCrypto.verifySignature(testSig, testData, state.masterPublicKey);
                if (!isTestValid) throw new Error("Ø¨Ø§Ø²Ø³Ø§Ø²ÛŒ Ú©Ù„ÛŒØ¯ Ø¯Ø± Ø®ÙˆØ¯Ø¢Ø²Ù…Ø§ÛŒÛŒ Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯. Ù‚Ø·Ø¹Ø§Øª Ø§Ø±Ø§Ø¦Ù‡ Ø´Ø¯Ù‡ Ø¨Ø§ Ú©Ù„ÛŒØ¯ Ø¹Ù…ÙˆÙ…ÛŒ ÙØ¹Ø§Ù„ Ù…Ø·Ø§Ø¨Ù‚Øª Ù†Ø¯Ø§Ø±Ù†Ø¯.");
                Utils.updateStatus(DOMElements.keyReconstructionStatus, "âœ… Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ Ø§ØµÙ„ÛŒ ÙØ¹Ø§Ù„ Ø´Ø¯. Ø§Ú©Ù†ÙˆÙ† Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø§Ø³Ú©Ù†Ø§Ø³ Ø¨Ø³Ø§Ø²ÛŒØ¯.", 'success');
                DOMElements.createNoteButton.disabled = false; DOMElements.downloadBatchButton.disabled = false;
            } catch (error) {
                console.error(error); Utils.updateStatus(DOMElements.keyReconstructionStatus, `âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø²Ø³Ø§Ø²ÛŒ Ú©Ù„ÛŒØ¯. ${error.message}`, 'error');
                state.masterPrivateKey = null; DOMElements.createNoteButton.disabled = true; DOMElements.downloadBatchButton.disabled = true;
            }
        },
    };
})();

// --- BANKNOTE LOGIC ---
const BanknoteLogic = (() => {
    const getStandardizedDataForSigning = (noteData) => JSON.stringify({ timestamp: noteData.timestamp, serial: noteData.serial, }, ['timestamp', 'serial']);
    const getStandardizedDataForMasterSig = (noteData) => {
        const tempNoteData = { ephemeralPublicKey: Utils.arrayBufferToBase64(noteData.ephemeralPublicKey), signatureOne: Utils.arrayBufferToBase64(noteData.signatureOne) };
        return JSON.stringify(tempNoteData, Object.keys(tempNoteData).sort());
    };
    const createNoteData = async (amount) => {
        if (!state.masterPrivateKey) throw new Error("Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ Ø§ØµÙ„ÛŒ ÙØ¹Ø§Ù„ Ù†ÛŒØ³Øª.");
        const ephemeralKeyPair = await BankCrypto.generateNewKeyPair();
        const noteData = { amount: parseInt(amount) || 0, serial: Math.random().toString(36).substring(2, 10).toUpperCase(), timestamp: Math.floor((Date.now() - Constants.EPOCH) / 1000), ephemeralPublicKey: ephemeralKeyPair.publicKey, signatureOne: null, signatureTwo: null };
        const dataForSigOne = getStandardizedDataForSigning(noteData);
        noteData.signatureOne = await BankCrypto.signData(dataForSigOne, ephemeralKeyPair.privateKey);
        const dataForSigTwo = getStandardizedDataForMasterSig(noteData);
        noteData.signatureTwo = await BankCrypto.signData(dataForSigTwo, state.masterPrivateKey);
        return noteData;
    };
    
    const createUnifiedVerificationPayload = (noteData) => {
        const payload = { a: noteData.amount, s: noteData.serial, t: noteData.timestamp, epk: Utils.arrayBufferToBase64(noteData.ephemeralPublicKey), s1: Utils.arrayBufferToBase64(noteData.signatureOne), s2: Utils.arrayBufferToBase64(noteData.signatureTwo) };
        const jsonString = JSON.stringify(payload);
        const compressedData = pako.deflate(jsonString);
        return Utils.arrayBufferToBase64(compressedData);
    };

    const parseUnifiedVerificationPayload = (base64CompressedString) => {
        const compressedData = Utils.base64ToUint8Array(base64CompressedString);
        const jsonString = pako.inflate(compressedData, { to: 'string' });
        const p = JSON.parse(jsonString);
        return { amount: p.a, serial: p.s, timestamp: p.t, ephemeralPublicKey: Utils.base64ToUint8Array(p.epk), signatureOne: Utils.base64ToUint8Array(p.s1), signatureTwo: Utils.base64ToUint8Array(p.s2) };
    };
    
    const handleCreateAndSignNotes = async () => {
        if (!state.masterPrivateKey) { alert("Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ Ø§ØµÙ„ÛŒ ÙØ¹Ø§Ù„ Ù†ÛŒØ³Øª. Ù„Ø·ÙØ§Ù‹ Ø¢Ù† Ø±Ø§ Ø¯Ø± Ù…Ø±Ø­Ù„Ù‡ Û² ÙØ¹Ø§Ù„ Ú©Ù†ÛŒØ¯."); return; }
        Utils.updateStatus(DOMElements.banknoteStatus, `â³ Ø¯Ø± Ø­Ø§Ù„ Ø³Ø§Ø®Øª Ùˆ Ù†Ù…Ø§ÛŒØ´ Ø§Ø³Ú©Ù†Ø§Ø³...`, 'info');
        try {
            const noteData = await createNoteData(DOMElements.amountInput.value);
            const fullPayload = createUnifiedVerificationPayload(noteData);
            await BanknoteDrawer.drawNoteOnCanvas(DOMElements.noteCanvas, noteData, fullPayload, 1200, 533);
            Utils.updateStatus(DOMElements.banknoteStatus, `âœ… Ø§Ø³Ú©Ù†Ø§Ø³ Ø¬Ø¯ÛŒØ¯ Ø·Ø±Ø§Ø­ÛŒ Ø´Ø¯. Ø¨Ø±Ø§ÛŒ Ø§Ù…Ù†ÛŒØªØŒ Ú©Ù„ÛŒØ¯ Ø§Ø² Ø­Ø§ÙØ¸Ù‡ Ù¾Ø§Ú© Ø´Ø¯. Ø¨Ø±Ø§ÛŒ Ø³Ø§Ø®Øª Ø§Ø³Ú©Ù†Ø§Ø³â€ŒÙ‡Ø§ÛŒ Ø¨ÛŒØ´ØªØ±ØŒ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ú©Ù†ÛŒØ¯.`, 'success');
        } catch (error) {
            Utils.updateStatus(DOMElements.banknoteStatus, `âŒ Ø®Ø·Ø§: ${error.message}`, 'error');
            console.error(error);
        } finally {
            if (state.masterPrivateKey) {
                state.masterPrivateKey = null;
                DOMElements.createNoteButton.disabled = true;
                DOMElements.downloadBatchButton.disabled = true;
                UIHandlers.handlePasswordKeyInput({ target: { value: null } });
                DOMElements.passwordKeyInput.value = '';
                Utils.updateStatus(DOMElements.keyReconstructionStatus, "âš ï¸ Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ Ø§ØµÙ„ÛŒ ØºÛŒØ±ÙØ¹Ø§Ù„ Ø§Ø³Øª. Ø¨Ø±Ø§ÛŒ Ø§Ù…Ù†ÛŒØªØŒ Ø§Ø² Ø­Ø§ÙØ¸Ù‡ Ù¾Ø§Ú© Ø´Ø¯. Ø¨Ø±Ø§ÛŒ ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ù…Ø¬Ø¯Ø¯ØŒ Ù¾Ø§Ø²Ù„ Ø±Ø§ Ø­Ù„ Ú©Ù†ÛŒØ¯.", 'warning');
                Utils.log("Ú©Ù„ÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ø§Ù…Ù†ÛŒØª Ù¾Ø³ Ø§Ø² Ø³Ø§Ø®Øª ÛŒÚ© Ø§Ø³Ú©Ù†Ø§Ø³ Ù¾Ø§Ú© Ø´Ø¯.", 'warning');
            }
        }
    };
    const handleDownloadBatch = async () => {
        if (!state.masterPrivateKey) { alert("Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ Ø§ØµÙ„ÛŒ ÙØ¹Ø§Ù„ Ù†ÛŒØ³Øª. Ù„Ø·ÙØ§Ù‹ Ø¢Ù† Ø±Ø§ Ø¯Ø± Ù…Ø±Ø­Ù„Ù‡ Û² ÙØ¹Ø§Ù„ Ú©Ù†ÛŒØ¯."); return; }
        const quantity = parseInt(DOMElements.quantityInput.value) || 1;
        Utils.updateStatus(DOMElements.banknoteStatus, `â³ Ø¯Ø± Ø­Ø§Ù„ Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø±Ø§ÛŒ Ø³Ø§Ø®Øª ${quantity} Ø§Ø³Ú©Ù†Ø§Ø³...`, 'info');
        if (quantity > 1 && !window.showDirectoryPicker) {
            Utils.log("Directory Picker API Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª. Ø¨Ù‡ Ø¯Ø§Ù†Ù„ÙˆØ¯ ØªÚ©ÛŒ Ø¨Ø§Ø²Ú¯Ø´Øª Ù…ÛŒâ€ŒØ´ÙˆØ¯.", 'warning');
            alert("Ù…Ø±ÙˆØ±Ú¯Ø± ÛŒØ§ Ø²Ù…ÛŒÙ†Ù‡ Ø§Ù…Ù†ÛŒØªÛŒ Ø´Ù…Ø§ Ø§Ø² Ø§Ù†ØªØ®Ø§Ø¨ Ù¾ÙˆØ´Ù‡ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ù†Ù…ÛŒâ€ŒÚ©Ù†Ø¯.\n\nØ§Ø³Ú©Ù†Ø§Ø³â€ŒÙ‡Ø§ Ø¨Ù‡ ØµÙˆØ±Øª ØªÚ©ÛŒ Ø¯Ø± Ù¾ÙˆØ´Ù‡ 'Downloads' Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ø´Ù…Ø§ Ø¯Ø§Ù†Ù„ÙˆØ¯ Ø®ÙˆØ§Ù‡Ù†Ø¯ Ø´Ø¯.");
        }
        try {
            const offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = 1200; offscreenCanvas.height = 533;
            const notesToDownload = [];
            Utils.updateStatus(DOMElements.banknoteStatus, `â³ Ø¯Ø± Ø­Ø§Ù„ ØªÙˆÙ„ÛŒØ¯ ${quantity} Ø§Ø³Ú©Ù†Ø§Ø³ Ø¯Ø± Ø­Ø§ÙØ¸Ù‡...`, 'info');
            for (let i = 0; i < quantity; i++) {
                const noteData = await createNoteData(DOMElements.amountInput.value);
                const fullPayload = createUnifiedVerificationPayload(noteData);
                await BanknoteDrawer.drawNoteOnCanvas(offscreenCanvas, noteData, fullPayload, 1200, 533);
                const blob = await new Promise(resolve => offscreenCanvas.toBlob(resolve, 'image/png'));
                notesToDownload.push({ blob, filename: `SADAT-NOTE-${noteData.serial}.png` });
                if (i === quantity - 1) {
                    await BanknoteDrawer.drawNoteOnCanvas(DOMElements.noteCanvas, noteData, fullPayload, 1200, 533);
                }
            }
            if (window.showDirectoryPicker && quantity > 1) {
                Utils.updateStatus(DOMElements.banknoteStatus, `â„¹ï¸ Ù„Ø·ÙØ§Ù‹ Ù¾ÙˆØ´Ù‡â€ŒØ§ÛŒ Ø¨Ø±Ø§ÛŒ Ø°Ø®ÛŒØ±Ù‡ Ø§Ø³Ú©Ù†Ø§Ø³â€ŒÙ‡Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.`, 'info');
                const dirHandle = await window.showDirectoryPicker();
                Utils.updateStatus(DOMElements.banknoteStatus, `â³ Ø¯Ø± Ø­Ø§Ù„ Ø°Ø®ÛŒØ±Ù‡ ${quantity} Ø§Ø³Ú©Ù†Ø§Ø³ Ø¯Ø± Ù¾ÙˆØ´Ù‡ Ø§Ù†ØªØ®Ø§Ø¨ÛŒ Ø´Ù…Ø§...`, 'info');
                for (const note of notesToDownload) {
                    const fileHandle = await dirHandle.getFileHandle(note.filename, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(note.blob);
                    await writable.close();
                }
                Utils.updateStatus(DOMElements.banknoteStatus, `âœ… ${quantity} Ø§Ø³Ú©Ù†Ø§Ø³ Ø¯Ø± Ù¾ÙˆØ´Ù‡ Ø§Ù†ØªØ®Ø§Ø¨ÛŒ Ø´Ù…Ø§ Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯.`, 'success');
            } else {
                Utils.updateStatus(DOMElements.banknoteStatus, `â³ Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø§Ù†Ù„ÙˆØ¯ ${quantity} Ø§Ø³Ú©Ù†Ø§Ø³ Ø¨Ù‡ ØµÙˆØ±Øª ØªÚ©ÛŒ...`, 'info');
                notesToDownload.forEach(note => Utils.downloadFile(note.blob, note.filename, 'image/png'));
                Utils.updateStatus(DOMElements.banknoteStatus, `âœ… ${quantity} Ø§Ø³Ú©Ù†Ø§Ø³ Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯. Ù¾ÙˆØ´Ù‡ Ø¯Ø§Ù†Ù„ÙˆØ¯Ù‡Ø§ÛŒ Ø®ÙˆØ¯ Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯.`, 'success');
            }
        } catch (error) {
            Utils.updateStatus(DOMElements.banknoteStatus, `âŒ Ø¹Ù…Ù„ÛŒØ§Øª Ù„ØºÙˆ Ø´Ø¯ ÛŒØ§ Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯: ${error.message}`, 'error');
            console.error(error);
        } finally {
            state.masterPrivateKey = null;
            DOMElements.createNoteButton.disabled = true;
            DOMElements.downloadBatchButton.disabled = true;
            UIHandlers.handlePasswordKeyInput({ target: { value: null } });
            DOMElements.passwordKeyInput.value = '';
            Utils.updateStatus(DOMElements.keyReconstructionStatus, "âš ï¸ Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ Ø§ØµÙ„ÛŒ ØºÛŒØ±ÙØ¹Ø§Ù„ Ø§Ø³Øª. Ø¨Ø±Ø§ÛŒ Ø§Ù…Ù†ÛŒØªØŒ Ø§Ø² Ø­Ø§ÙØ¸Ù‡ Ù¾Ø§Ú© Ø´Ø¯. Ø¨Ø±Ø§ÛŒ ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ù…Ø¬Ø¯Ø¯ØŒ Ù¾Ø§Ø²Ù„ Ø±Ø§ Ø­Ù„ Ú©Ù†ÛŒØ¯.", 'warning');
            Utils.log("Ú©Ù„ÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ø§Ù…Ù†ÛŒØª Ù¾Ø³ Ø§Ø² Ø¹Ù…Ù„ÛŒØ§Øª Ø¯Ø³ØªÙ‡â€ŒØ§ÛŒ Ù¾Ø§Ú© Ø´Ø¯.", 'warning');
        }
    };
    
    async function decodeAllJabsFromImage(file) {
        const resizedDataUrl = await Utils.resizeImage(file, Constants.MAX_IMAGE_DIMENSION);
        
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = async () => {
                let allDecoded = [];
                try {
                    allDecoded = await state.jabInterface.decode_message(resizedDataUrl, { findAll: true });
                } catch(e) {
                    console.warn("Ø±Ù…Ø²Ú¯Ø´Ø§ÛŒÛŒ Ú©Ø¯ Jab Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯.", e);
                }

                if (allDecoded.length > 0) {
                     resolve(allDecoded);
                } else {
                    reject(new Error("Ù‡ÛŒÚ† Ú©Ø¯ Jab ÛŒØ§ÙØª Ù†Ø´Ø¯. Ù„Ø·ÙØ§Ù‹ Ø§Ø² ÛŒÚ© ØªØµÙˆÛŒØ± ÙˆØ§Ø¶Ø­ Ùˆ Ú©Ø§Ù…Ù„ Ø§Ø² Ø§Ø³Ú©Ù†Ø§Ø³ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯."));
                }
            };
            img.onerror = () => reject(new Error("Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù† ÙØ§ÛŒÙ„ ØªØµÙˆÛŒØ± Ø§Ø³Ú©Ù†Ø§Ø³ Ø±Ø§ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ú©Ø±Ø¯."));
            img.src = resizedDataUrl;
        });
    }

    return {
        handleCreateAndSignNotes,
        handleDownloadBatch,
        handleFileSelectForValidation: async (event) => {
            const file = event.target.files[0];
            if (!file || !state.masterPublicKey) { Utils.updateStatus(DOMElements.validationResult, 'âŒ Ù‚Ø¨Ù„ Ø§Ø² Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒØŒ Ú©Ù„ÛŒØ¯ Ø¹Ù…ÙˆÙ…ÛŒ Ø§ØµÙ„ÛŒ Ø±Ø§ Ø¯Ø± Ù…Ø±Ø­Ù„Ù‡ Û± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ú©Ù†ÛŒØ¯.', 'error'); return; }
            const resultDiv = DOMElements.validationResult;
            Utils.updateStatus(resultDiv, 'â³ Ø¯Ø± Ø­Ø§Ù„ ØªØºÛŒÛŒØ± Ø§Ù†Ø¯Ø§Ø²Ù‡ Ùˆ Ø®ÙˆØ§Ù†Ø¯Ù† ØªØµÙˆÛŒØ± Ø§Ø³Ú©Ù†Ø§Ø³... Ù„Ø·ÙØ§Ù‹ ØµØ¨Ø± Ú©Ù†ÛŒØ¯.', 'info');
            try {
                const decodedCodes = await decodeAllJabsFromImage(file);
                let resultHTML = `ØªØ¹Ø¯Ø§Ø¯ ${decodedCodes.length} Ú©Ø¯ Jab Ø±ÙˆÛŒ ØªØµÙˆÛŒØ± ÛŒØ§ÙØª Ø´Ø¯. Ø¯Ø± Ø­Ø§Ù„ Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ Ù¾ÛŒÙ„ÙˆØ¯...\n`;
                resultDiv.innerHTML = `<span class="info">${resultHTML}</span>`;

                let expectedTotalParts = 0;
                const receivedParts = {};
                
                for (const code of decodedCodes) {
                    if (code.data.startsWith(Constants.VALIDATION_PREFIX)) {
                        const payload = code.data.substring(Constants.VALIDATION_PREFIX.length);
                        const match = payload.match(/^(\d+)\/(\d+):(.*)$/s);
                        if (match) {
                            const partNum = parseInt(match[1], 10);
                            const totalParts = parseInt(match[2], 10);
                            if (!expectedTotalParts) expectedTotalParts = totalParts;
                            receivedParts[partNum] = match[3];
                        }
                    }
                }
                
                if (Object.keys(receivedParts).length < expectedTotalParts) {
                    Utils.updateStatus(resultDiv, `âŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø§Ø³Ú©Ù†Ø§Ø³ Ù†Ø§Ù‚Øµ Ø§Ø³Øª. ØªØ¹Ø¯Ø§Ø¯ ${Object.keys(receivedParts).length}/${expectedTotalParts} Ú©Ø¯ Jab Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² ÛŒØ§ÙØª Ø´Ø¯. Ø§Ø³Ú©Ù†Ø§Ø³ Ù…Ù…Ú©Ù† Ø§Ø³Øª Ø¢Ø³ÛŒØ¨ Ø¯ÛŒØ¯Ù‡ ÛŒØ§ Ø¬Ø¹Ù„ÛŒ Ø¨Ø§Ø´Ø¯.`, 'error');
                    return;
                }

                let fullPayloadString = '';
                for (let i = 1; i <= expectedTotalParts; i++) {
                    if (!receivedParts[i]) {
                         Utils.updateStatus(resultDiv, `âŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø§Ø³Ú©Ù†Ø§Ø³ Ù†Ø§Ù‚Øµ Ø§Ø³Øª. Ù‚Ø·Ø¹Ù‡ ${i}/${expectedTotalParts} ÛŒØ§ÙØª Ù†Ø´Ø¯.`, 'error');
                         return;
                    }
                    fullPayloadString += receivedParts[i];
                }

                resultHTML += `<span class="valid">âœ… ØªÙ…Ø§Ù… ${expectedTotalParts} Ù‚Ø·Ø¹Ù‡ ÛŒØ§ÙØª Ø´Ø¯. Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø²Ø³Ø§Ø²ÛŒ Ù¾ÛŒÙ„ÙˆØ¯...</span>\n`;
                resultDiv.innerHTML = resultHTML;
                
                const parsedData = parseUnifiedVerificationPayload(fullPayloadString);
                resultHTML += `<span class="info">â„¹ï¸ Ø¯Ø± Ø­Ø§Ù„ ØªØ£ÛŒÛŒØ¯ Ø§Ù…Ø¶Ø§ÛŒ Ù…ÙˆÙ‚Øª (Ø§Ù…Ø¶Ø§ÛŒ Û±)...</span>\n`;
                resultDiv.innerHTML = resultHTML;
                const dataForSigOne = getStandardizedDataForSigning(parsedData);
                const isSigOneValid = await BankCrypto.verifySignature(parsedData.signatureOne, dataForSigOne, parsedData.ephemeralPublicKey);
                if (!isSigOneValid) { resultDiv.innerHTML += '<span class="invalid">âŒ Ø§Ù…Ø¶Ø§ÛŒ Ù…ÙˆÙ‚Øª (Ø§Ù…Ø¶Ø§ÛŒ Û±) Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª.</span>\n<hr><span>âŒ Ù†ØªÛŒØ¬Ù‡: Ø¬Ø¹Ù„ÛŒ</span>'; return; }
                resultHTML += '<span class="valid">âœ… Ø§Ù…Ø¶Ø§ÛŒ Ù…ÙˆÙ‚Øª (Ø§Ù…Ø¶Ø§ÛŒ Û±) ØµØ­ÛŒØ­ Ø§Ø³Øª.</span>\n';
                resultHTML += `<span class="info">â„¹ï¸ Ø¯Ø± Ø­Ø§Ù„ ØªØ£ÛŒÛŒØ¯ Ø§Ù…Ø¶Ø§ÛŒ Ø§ØµÙ„ÛŒ (Ø§Ù…Ø¶Ø§ÛŒ Û²)...</span>\n`;
                resultDiv.innerHTML = resultHTML;
                const dataForSigTwo = getStandardizedDataForMasterSig(parsedData);
                const isSigTwoValid = await BankCrypto.verifySignature(parsedData.signatureTwo, dataForSigTwo, state.masterPublicKey);
                if (!isSigTwoValid) { resultDiv.innerHTML += '<span class="invalid">âŒ Ø§Ù…Ø¶Ø§ÛŒ Ø§ØµÙ„ÛŒ (Ø§Ù…Ø¶Ø§ÛŒ Û²) Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª.</span>\n<hr><span>âŒ Ù†ØªÛŒØ¬Ù‡: Ø¬Ø¹Ù„ÛŒ (ØªÙˆØ³Ø· Ø§ÛŒÙ† Ù†Ú¯Ù‡Ø¨Ø§Ù† ØµØ§Ø¯Ø± Ù†Ø´Ø¯Ù‡)</span>'; return; }
                resultHTML += '<span class="valid">âœ… Ø§Ù…Ø¶Ø§ÛŒ Ø§ØµÙ„ÛŒ (Ø§Ù…Ø¶Ø§ÛŒ Û²) ØµØ­ÛŒØ­ Ø§Ø³Øª.</span>\n<hr><span style="font-size:14px;font-weight:600;">âœ… Ù†ØªÛŒØ¬Ù‡: Ø§Ø³Ú©Ù†Ø§Ø³ Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª</span>';
                resultDiv.innerHTML = resultHTML;
            } catch (e) {
                if (e.message.includes("incorrect header check") || e.message.includes("invalid block type")) {
                     Utils.updateStatus(resultDiv, `âŒ Ø®Ø·Ø§ÛŒ Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ: ÙØ´Ø±Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯. Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ø¯ Jab Ø®Ø±Ø§Ø¨ ÛŒØ§ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª.`, 'error');
                } else {
                     Utils.updateStatus(resultDiv, `âŒ Ø®Ø·Ø§ÛŒ Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ: ${e.message}.`, 'error');
                }
                console.error(e);
            } finally {
                event.target.value = '';
            }
        }
    };
})();

// ===================================================================================
// BANKNOTE DRAWER -- THIS SECTION CONTAINS THE LAYOUT FIX
// ===================================================================================
const BanknoteDrawer = (() => {
    function roundRect(ctx, x, y, width, height, radius) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
    }
    
    return {
        drawNoteOnCanvas: async (targetCanvas, noteData, fullPayload, width, height) => {
            const ctx = targetCanvas.getContext("2d");
            const { amount, serial } = noteData;
            const scale = width / 1200; 

            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, width, height);
            
            const partLength = Math.ceil(fullPayload.length / Constants.NUM_JABS);
            const jabPayloads = [];
            for (let i = 0; i < Constants.NUM_JABS; i++) {
                const partData = fullPayload.substring(i * partLength, (i + 1) * partLength);
                jabPayloads.push(`${Constants.VALIDATION_PREFIX}${i + 1}/${Constants.NUM_JABS}:${partData}`);
            }

            const jabOptions = { securityLevel: 1 };
            const jabImages = await Promise.all(jabPayloads.map(payload => Utils.createJabImage(payload, jabOptions)));

            ctx.shadowColor = "rgba(0,0,0,0.3)";
            ctx.shadowBlur = 8 * scale;
            ctx.shadowOffsetX = 2 * scale;
            ctx.shadowOffsetY = 2 * scale;
            
            ctx.font = `bold ${24 * scale}px 'Roboto Mono'`;
            ctx.fillStyle = `#000000`;
            ctx.textAlign = 'right';
            ctx.fillText(serial, width - (40 * scale), 50 * scale);
            
            ctx.font = `bold ${48 * scale}px 'Roboto Mono'`;
            ctx.textAlign = 'left';
            ctx.fillText(amount.toLocaleString('fa-IR'), 40 * scale, 65 * scale);
            ctx.shadowColor = "transparent";
            
            // CORRECTED: Sizing and positioning for a visually merged 3x2 grid
            const jabSize = 160 * scale;
            const xSpacing = 0; // No horizontal space
            const ySpacing = 0; // No vertical space
            const totalGridWidth = jabSize * 3;
            const totalGridHeight = jabSize * 2;
            
            const startX = (width - totalGridWidth) / 2;
            
            const topTextAreaHeight = 85 * scale;
            const startY = topTextAreaHeight + ((height - topTextAreaHeight - totalGridHeight) / 2);

            const padding = 20 * scale;
            ctx.fillStyle = '#FFFFFF';
            ctx.shadowColor = "rgba(0,0,0,0.2)";
            ctx.shadowBlur = 15 * scale;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 5 * scale;
            roundRect(ctx, startX - padding, startY - padding, totalGridWidth + padding*2, totalGridHeight + padding*2, 15*scale);
            ctx.fill();
            ctx.shadowColor = "transparent";

            jabImages.forEach((img, index) => {
                const row = Math.floor(index / 3);
                const col = index % 3;
                const x = startX + col * jabSize;
                const y = startY + row * jabSize;
                ctx.drawImage(img, x, y, jabSize, jabSize);
            });
        }
    };
})();

// ===================================================================================
// APPLICATION INITIALIZATION
// ===================================================================================
async function main() {
    Utils.updateStatus(DOMElements.keyGenStatus, 'â³ Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§ÛŒ Falcon-1024 Ùˆ JAB Code...', 'info');
    try {
        state.falconApi = await pqcSignFalcon1024();
        state.jabInterface = new JabcodeJSInterface();
        Utils.updateStatus(DOMElements.keyGenStatus, 'âœ… Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯Ù†Ø¯. Ù„Ø·ÙØ§Ù‹ Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ Ú©Ù„ÛŒØ¯Ù‡Ø§ Ø±Ø§ Ø¨Ø³Ø§Ø²ÛŒØ¯ ÛŒØ§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.', 'success');
        Utils.log("ØªÙ…Ø§Ù… Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§ÛŒ Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ Ùˆ Ú©Ø¯ Jab Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø´Ø¯Ù†Ø¯.", 'success');
    } catch (e) {
        Utils.log(`Ø®Ø·Ø§ÛŒ Ø¨Ø­Ø±Ø§Ù†ÛŒ: Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø±Ø§ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ú©Ø±Ø¯: ${e.message}`, 'error');
        Utils.updateStatus(DOMElements.keyGenStatus, `âŒ Ø®Ø·Ø§ÛŒ Ø¨Ø­Ø±Ø§Ù†ÛŒ: Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§ Ø±Ø§ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ú©Ø±Ø¯. Ø¬Ø²Ø¦ÛŒØ§Øª Ø±Ø§ Ø¯Ø± Ú©Ù†Ø³ÙˆÙ„ Ø¨Ø¨ÛŒÙ†ÛŒØ¯.`, 'error');
        alert("Ø®Ø·Ø§: Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ÛŒÚ© Ù…Ø§Ú˜ÙˆÙ„ Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯. Ø¨Ø±Ù†Ø§Ù…Ù‡ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø§Ø¬Ø±Ø§ Ø´ÙˆØ¯.");
        return;
    }
    
    DOMElements.generateKeysButton.addEventListener('click', UIHandlers.handleGenerateAndExportKeys);
    DOMElements.importPublicKey.addEventListener('change', UIHandlers.handleImportPublicKey);
    DOMElements.fileKeyInput.addEventListener('change', UIHandlers.handleFileKeyInput);
    DOMElements.passwordKeyInput.addEventListener('input', UIHandlers.handlePasswordKeyInput);
    DOMElements.visualKeyInput.addEventListener('change', UIHandlers.handleVisualKeyInput);
    DOMElements.reconstructKeyButton.addEventListener('click', UIHandlers.handleReconstructKey);
    DOMElements.createNoteButton.addEventListener('click', BanknoteLogic.handleCreateAndSignNotes);
    DOMElements.downloadBatchButton.addEventListener('click', BanknoteLogic.handleDownloadBatch);
    DOMElements.validatorInput.addEventListener('change', BanknoteLogic.handleFileSelectForValidation);
    
    DOMElements.downloadJabButton.addEventListener('click', () => {
        const img = DOMElements.jabDisplay.querySelector('img');
        if (img) {
            const a = document.createElement('a');
            a.href = img.src;
            a.download = 'Sadat-VISUAL-KEY.png';
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
        }
    });

    const canvas = DOMElements.noteCanvas;
    const ctx = canvas.getContext('2d');
    const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    bgGradient.addColorStop(0, `hsl(250, 50%, 6%)`);
    bgGradient.addColorStop(1, `hsl(260, 40%, 4%)`);
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.font = `bold 30px 'Poppins'`;
    ctx.textAlign = 'center';
    ctx.fillStyle = "rgba(255,255,255,0.4)";
    ctx.fillText("Ø·Ø±Ø­ Ø§Ø³Ú©Ù†Ø§Ø³ Ù¾Ø³ Ø§Ø² Ø³Ø§Ø®Øª Ø¯Ø± Ø§ÛŒÙ†Ø¬Ø§ Ø¸Ø§Ù‡Ø± Ù…ÛŒâ€ŒØ´ÙˆØ¯", canvas.width/2, canvas.height/2);
}

main();
</script>
</body>
</html>
