<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
Â  Â  <meta charset="UTF-8">
Â  Â  <title>Sadat Digital Banknote [Dual Code - Inefficient]</title>
Â  Â  <link rel="preconnect" href="https://fonts.googleapis.com">
Â  Â  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
Â  Â  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&family=Poppins:wght@400;600&display=swap" rel="stylesheet">
Â  Â Â 
Â  Â  <style>
Â  Â  Â  Â  :root {
Â  Â  Â  Â  Â  Â  --primary-font: 'Poppins', 'Segoe UI', sans-serif;
Â  Â  Â  Â  Â  Â  --mono-font: 'Roboto Mono', monospace;
Â  Â  Â  Â  Â  Â  --dark-bg: #10101a;
Â  Â  Â  Â  Â  Â  --medium-bg: #1a1a2e;
Â  Â  Â  Â  Â  Â  --light-bg: #2a2a3e;
Â  Â  Â  Â  Â  Â  --accent-color-1: #e040fb;
Â  Â  Â  Â  Â  Â  --accent-color-2: #7c4dff;
Â  Â  Â  Â  Â  Â  --text-color: #e0e0e0;
Â  Â  Â  Â  Â  Â  --text-muted: #a0a0c0;
Â  Â  Â  Â  Â  Â  --success-color: #00e676;
Â  Â  Â  Â  Â  Â  --error-color: #ff5252;
Â  Â  Â  Â  Â  Â  --info-color: #40c4ff;
Â  Â  Â  Â  Â  Â  --warning-color: #ffab40;
Â  Â  Â  Â  Â  Â  --border-color: rgba(124, 77, 255, 0.2);
Â  Â  Â  Â  }
Â  Â  Â  Â  body { margin: 0; font-family: var(--primary-font); background-color: var(--dark-bg); background-image: radial-gradient(at 0% 0%, hsla(253, 100%, 15%, 0.3) 0px, transparent 50%), radial-gradient(at 100% 100%, hsla(263, 100%, 20%, 0.3) 0px, transparent 50%); color: var(--text-color); text-align: center; padding: 24px; }
Â  Â  Â  Â  .container { max-width: 1000px; margin: 0 auto; background: rgba(26, 26, 46, 0.7); backdrop-filter: blur(12px); padding: 24px; border-radius: 24px; border: 1px solid var(--border-color); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2); }
Â  Â  Â  Â  .header { border-bottom: 1px solid var(--border-color); padding-bottom: 16px; margin-bottom: 24px; }
Â  Â  Â  Â  h1 { font-size: 2.5rem; font-weight: 600; color: #fff; margin: 0 0 8px 0; letter-spacing: 1px; background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
Â  Â  Â  Â  .header p { font-size: 1rem; color: var(--text-muted); margin: 0; }
Â  Â  Â  Â  canvas#noteCanvas { border-radius: 16px; margin-top: 24px; background: #050508; cursor: default; box-shadow: 0 0 50px rgba(124, 77, 255, 0.15); width: 100%; max-width: 1000px; height: auto; border: 1px solid var(--border-color); }
Â  Â  Â  Â  input, button, label { padding: 14px 22px; font-size: 16px; font-family: var(--primary-font); border-radius: 12px; margin: 8px 5px; border: 1px solid var(--border-color); background: var(--medium-bg); color: #fff; transition: all 0.3s ease; cursor: pointer; outline: none; display: inline-flex; align-items: center; justify-content: center; gap: 8px; }
Â  Â  Â  Â  input[type="number"], input[type="password"] { font-family: var(--mono-font); font-weight: 700; text-align: center; width: 150px; }
Â  Â  Â  Â  input:focus { border-color: var(--accent-color-2); box-shadow: 0 0 15px rgba(124, 77, 255, 0.5); }
Â  Â  Â  Â  button:not([disabled]), label.button:not([disabled]) { font-weight: 600; background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); border: none; box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
Â  Â  Â  Â  button.sub-button, label.button.sub-button { background: var(--light-bg); border: 1px solid var(--border-color); }
Â  Â  Â  Â  button[disabled], label.button[disabled] { cursor: not-allowed; opacity: 0.5; background: var(--light-bg); border: 1px solid var(--border-color); }
Â  Â  Â  Â  button:hover:not([disabled]), label.button:hover:not([disabled]) { transform: translateY(-2px); box-shadow: 6px 20px rgba(124, 77, 255, 0.4); }
Â  Â  Â  Â  .section { background: rgba(16, 16, 26, 0.5); padding: 20px; margin-top: 30px; border-radius: 16px; border: 1px solid var(--border-color); }
Â  Â  Â  Â  h2 { font-size: 1.5rem; color: var(--text-color); margin-top: 0; margin-bottom: 20px; font-weight: 600; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
Â  Â  Â  Â  .controls-grid { display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 16px; }
Â  Â  Â  Â  .status-box { margin-top: 20px; font-size: 13px; font-weight: normal; min-height: 50px; line-height: 1.6; text-align: left; background: var(--dark-bg); padding: 15px 20px; border-radius: 12px; white-space: pre-wrap; font-family: var(--mono-font); border: 1px solid var(--border-color); transition: all 0.3s ease; }
Â  Â  Â  Â  .valid { color: var(--success-color); } .invalid { color: var(--error-color); } .info { color: var(--info-color); } .warning { color: var(--warning-color); }
Â  Â  Â  Â  code { background: var(--medium-bg); padding: 2px 6px; border-radius: 4px; font-size: 1em; }
Â  Â  Â  Â  .input-label { font-size: 0.9rem; color: var(--text-muted); margin-right: -10px; }
Â  Â  Â  Â  .modal { position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; }
Â  Â  Â  Â  .modal-content { background-color: var(--medium-bg); padding: 30px; border: 1px solid var(--border-color); width: 80%; max-width: 500px; border-radius: 16px; text-align: center; }
Â  Â  Â  Â  #qr-display { margin: 20px auto; background: white; padding: 15px; border-radius: 8px; width: fit-content; }
Â  Â  Â  Â  #qr-display img { max-width: 100%; height: auto; }
Â  Â  Â  Â  .pill { background-color: var(--border-color); color: var(--accent-color-1); padding: 5px 15px; border-radius: 20px; font-size: 14px; font-weight: 600; margin: 5px; display: inline-block; }
Â  Â  </style>
</head>
<body>
<div class="container">
Â  Â  <div class="header">
Â  Â  Â  Â  <h1>Sadat Digital Banknote</h1>
Â  Â  Â  Â  <p>A Quantum-Resistant, Offline, Dual-Signature Digital Currency System.</p>
Â  Â  </div>

Â  Â  <div class="section">
Â  Â  Â  Â  <h2><span class="pill">Step 1</span> Guardian Setup: Create Master Keys</h2>
Â  Â  Â  Â  <div class="controls-grid">
Â  Â  Â  Â  Â  Â  <button id="generate-keys-button">ğŸ”‘ Generate Master Key Pair</button>
Â  Â  Â  Â  Â  Â  <label for="import-public-key" class="button sub-button">
Â  Â  Â  Â  Â  Â  Â  Â  <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
Â  Â  Â  Â  Â  Â  Â  Â  Load Public Key
Â  Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  Â  <input type="file" id="import-public-key" accept=".json" style="display: none;">
Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â <div id="key-gen-status" class="status-box"><span class="info">â„¹ï¸ Welcome, Guardian. Generate a new Master Key Pair to begin your financial ecosystem. This process is fully offline and secure.</span></div>
Â  Â  </div>

Â  Â  <div class="section">
Â  Â  Â  Â  <h2><span class="pill">Step 2</span> Activate System: Reconstruct Private Key</h2>
Â  Â  Â  Â  <p style="color: var(--text-muted); font-size: 0.9em; max-width: 700px; margin: -10px auto 20px auto;">To create banknotes, you must prove your identity by solving the "Three-Piece Puzzle". This ensures maximum security.</p>
Â  Â  Â  Â  <div class="controls-grid">
Â  Â  Â  Â  Â  Â  Â <label for="file-key-input" class="button sub-button">1. Upload File Key</label>
Â  Â  Â  Â  Â  Â  Â <input type="file" id="file-key-input" accept=".json" style="display:none;" />
Â  Â  Â  Â  Â  Â  Â <input type="password" id="password-key-input" placeholder="2. Enter Password Key">
Â  Â  Â  Â  Â  Â  Â <label for="visual-key-input" class="button sub-button">3. Upload Visual Key (JAB)</label>
Â  Â  Â  Â  Â  Â  Â <input type="file" id="visual-key-input" accept="image/png, image/jpeg, image/svg+xml" style="display:none;" />
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <button id="reconstruct-key-button" disabled style="margin-top: 20px;">ğŸ”“ Activate Master Private Key</button>
Â  Â  Â  Â  <div id="key-reconstruction-status" class="status-box"><span class="warning">âš ï¸ Master Private Key is INACTIVE. Solve the puzzle to activate.</span></div>
Â  Â  </div>

Â  Â  <div class="section">
Â  Â  Â  Â  <h2><span class="pill">Step 3</span> Create Wealth: Generate Banknotes</h2>
Â  Â  Â  Â  <div class="controls-grid">
Â  Â  Â  Â  Â  Â  <span class="input-label">Amount:</span>
Â  Â  Â  Â  Â  Â  <input type="number" id="amount-input" value="50000">
Â  Â  Â  Â  Â  Â  <span class="input-label">Quantity:</span>
Â  Â  Â  Â  Â  Â  <input type="number" id="quantity-input" value="1" min="1" max="100">
Â  Â  Â  Â  Â  Â  <button id="create-note-button" disabled>ğŸ¨ Redesign Banknote</button>
Â  Â  Â  Â  Â  Â  <button id="download-batch-button" disabled>ğŸ“¥ Download Batch</button>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div id="banknote-status" class="status-box">Use the controls above to create and sign new banknotes.</div>
Â  Â  Â  Â  <canvas id="noteCanvas" width="1350" height="750"></canvas>
Â  Â  </div>

Â  Â  <div class="section" id="validator-section">
Â  Â  Â  Â  <h2><span class="pill">Step 4</span> Verify Authenticity</h2>
Â  Â  Â  Â  <div class="controls-grid">
Â  Â  Â  Â  Â  Â  <label for="validator-input" class="button">
Â  Â  Â  Â  Â  Â  Â  Â  <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 15 17 10"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
Â  Â  Â  Â  Â  Â  Â  Â  Select Banknote Image for Validation
Â  Â  Â  Â  Â  Â  </label>
Â  Â  Â  Â  Â  Â  <input type="file" id="validator-input" accept="image/png" style="display: none;">
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div id="validation-result" class="status-box">Awaiting banknote for validation...</div>
Â  Â  </div>
</div>

<div id="qr-modal" class="modal">
Â  <div class="modal-content">
Â  Â  <h2 id="qr-modal-title">Your Visual Key</h2>
Â  Â  <p>Print this JAB Code or save the image file and store it in a secure physical location. It is the third piece of your Master Key puzzle.</p>
Â  Â  <div id="qr-display"></div>
Â  Â  <button id="download-qr-button" style="margin-top: 15px;">ğŸ’¾ Download JAB Code</button>
Â  Â  <button onclick="document.getElementById('qr-modal').style.display='none'">Close</button>
Â  </div>
</div>

<script type="module">
import JabcodeJSInterface from './jabcodeJSLib.min.js';
import pqcSignFalcon1024 from './pqc-sign-falcon-1024.min.js';
import { shake256 } from 'https://cdn.skypack.dev/js-sha3';
import QRCode from 'https://cdn.skypack.dev/qrcode';
import jsQR from 'https://cdn.skypack.dev/jsqr';

const jabcode = new JabcodeJSInterface();

const state = {
Â  Â  falconApi: null,
Â  Â  masterPublicKey: null,
Â  Â  masterPrivateKey: null,
Â  Â  puzzlePieces: {
Â  Â  Â  Â  fileKey: null,
Â  Â  Â  Â  passwordKey: null,
Â  Â  Â  Â  visualKey: null
Â  Â  }
};

const Constants = {
Â  Â  FALCON_PUBKEY_SIZE: 1793,
Â  Â  EPOCH: new Date('2024-01-01T00:00:00Z').getTime()
};

const DOMElements = {
Â  Â  generateKeysButton: document.getElementById('generate-keys-button'),
Â  Â  importPublicKey: document.getElementById('import-public-key'),
Â  Â  keyGenStatus: document.getElementById('key-gen-status'),
Â  Â  fileKeyInput: document.getElementById('file-key-input'),
Â  Â  passwordKeyInput: document.getElementById('password-key-input'),
Â  Â  visualKeyInput: document.getElementById('visual-key-input'),
Â  Â  reconstructKeyButton: document.getElementById('reconstruct-key-button'),
Â  Â  keyReconstructionStatus: document.getElementById('key-reconstruction-status'),
Â  Â  amountInput: document.getElementById('amount-input'),
Â  Â  quantityInput: document.getElementById('quantity-input'),
Â  Â  createNoteButton: document.getElementById('create-note-button'),
Â  Â  downloadBatchButton: document.getElementById('download-batch-button'),
Â  Â  noteCanvas: document.getElementById('noteCanvas'),
Â  Â  banknoteStatus: document.getElementById('banknote-status'),
Â  Â  validatorInput: document.getElementById('validator-input'),
Â  Â  validationResult: document.getElementById('validation-result'),
Â  Â  qrModal: document.getElementById('qr-modal'),
Â  Â  qrDisplay: document.getElementById('qr-display'),
Â  Â  qrModalTitle: document.getElementById('qr-modal-title'),
Â  Â  downloadQrButton: document.getElementById('download-qr-button')
};

const Utils = {
Â  Â  arrayBufferToBase64: (buffer) => btoa(String.fromCharCode(...new Uint8Array(buffer))),
Â  Â  base64ToUint8Array: (base64) => {
Â  Â  Â  Â  const binaryString = atob(base64);
Â  Â  Â  Â  const len = binaryString.length;
Â  Â  Â  Â  const bytes = new Uint8Array(len);
Â  Â  Â  Â  for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i);
Â  Â  Â  Â  return bytes;
Â  Â  },
Â  Â  hexToUint8Array: (hex) => new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16))),
Â  Â  downloadFile: (data, filename, type) => {
Â  Â  Â  Â  const blob = new Blob([data], { type });
Â  Â  Â  Â  const url = URL.createObjectURL(blob);
Â  Â  Â  Â  const a = document.createElement('a');
Â  Â  Â  Â  a.href = url; a.download = filename;
Â  Â  Â  Â  document.body.appendChild(a); a.click();
Â  Â  Â  Â  document.body.removeChild(a); URL.revokeObjectURL(url);
Â  Â  },
Â  Â  updateStatus: (element, message, type = 'info') => {
Â  Â  Â  Â  element.innerHTML = `<span class="${type}">${message}</span>`;
Â  Â  },
Â  Â  log: (message, type = 'info') => {
Â  Â  Â  Â  const icon = { info: 'â„¹ï¸', success: 'âœ…', warning: 'âš ï¸', error: 'âŒ' }[type];
Â  Â  Â  Â  console.log(`[Sadat System] ${icon} ${message}`);
Â  Â  },
Â  Â  binaryToString: (binaryPayload) => {
Â  Â  Â  Â  let str = '';
Â  Â  Â  Â  binaryPayload.forEach(b => { str += String.fromCharCode(b); });
Â  Â  Â  Â  return str;
Â  Â  },
Â  Â  stringToBinary: (str) => {
Â  Â  Â  Â  const binaryPayload = new Uint8Array(str.length);
Â  Â  Â  Â  for (let i = 0; i < str.length; i++) {
Â  Â  Â  Â  Â  Â  binaryPayload[i] = str.charCodeAt(i);
Â  Â  Â  Â  }
Â  Â  Â  Â  return binaryPayload;
Â  Â  }
};

// ===================================================================================
// CORE CRYPTO ENGINE
// ===================================================================================
const BankCrypto = (() => {
Â  Â  const AES_ALGO = "AES-GCM";
Â  Â  const PBKDF2_ITERATIONS = 100000;
Â  Â  const PBKDF2_KEY_LENGTH = 32;
Â  Â  const AES_KEY_LENGTH = 256;

Â  Â  async function pbkdf2DeriveKey(password, salt) {
Â  Â  Â  Â  const passwordBuffer = new TextEncoder().encode(password);
Â  Â  Â  Â  const importedKey = await crypto.subtle.importKey("raw", passwordBuffer, { name: "PBKDF2" }, false, ["deriveKey"]);
Â  Â  Â  Â  return await crypto.subtle.deriveKey({ name: "PBKDF2", salt: salt, iterations: PBKDF2_ITERATIONS, hash: "SHA-256" }, importedKey, { name: AES_ALGO, length: PBKDF2_KEY_LENGTH * 8 }, false, ["encrypt", "decrypt"]);
Â  Â  }
Â  Â Â 
Â  Â  function hashMessageForSigning(message) { return Utils.hexToUint8Array(shake256(message, 1536)); }

Â  Â  async function deriveAESKeyFromPublicKey(publicKey) {
Â  Â  Â  Â  const publicKeyHash = shake256(Utils.arrayBufferToBase64(publicKey), AES_KEY_LENGTH);
Â  Â  Â  Â  const keyData = Utils.hexToUint8Array(publicKeyHash);
Â  Â  Â  Â  return await crypto.subtle.importKey("raw", keyData, { name: AES_ALGO, length: AES_KEY_LENGTH }, false, ["encrypt", "decrypt"]);
Â  Â  }

Â  Â  async function encryptPayload(payload, publicKey) {
Â  Â  Â  Â  const key = await deriveAESKeyFromPublicKey(publicKey);
Â  Â  Â  Â  const iv = crypto.getRandomValues(new Uint8Array(12));
Â  Â  Â  Â  const encrypted = await crypto.subtle.encrypt({ name: AES_ALGO, iv: iv }, key, new TextEncoder().encode(JSON.stringify(payload)));
Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  Â  iv: Utils.arrayBufferToBase64(iv),
Â  Â  Â  Â  Â  Â  cipherText: Utils.arrayBufferToBase64(encrypted)
Â  Â  Â  Â  };
Â  Â  }

Â  Â  async function decryptPayload(encryptedPayload, publicKey) {
Â  Â  Â  Â  const key = await deriveAESKeyFromPublicKey(publicKey);
Â  Â  Â  Â  const iv = Utils.base64ToUint8Array(encryptedPayload.iv);
Â  Â  Â  Â  const cipherText = Utils.base64ToUint8Array(encryptedPayload.cipherText);
Â  Â  Â  Â  const decrypted = await crypto.subtle.decrypt({ name: AES_ALGO, iv: iv }, key, cipherText);
Â  Â  Â  Â  return JSON.parse(new TextDecoder().decode(decrypted));
Â  Â  }

Â  Â  return {
Â  Â  Â  Â  async generateNewKeyPair() {
Â  Â  Â  Â  Â  Â  if (!state.falconApi) throw new Error("Falcon API not initialized.");
Â  Â  Â  Â  Â  Â  return state.falconApi.keypair();
Â  Â  Â  Â  },
Â  Â  Â  Â  async signData(data, privateKey) {
Â  Â  Â  Â  Â  Â  if (!privateKey || !state.falconApi) throw new Error("Signing prerequisites not met.");
Â  Â  Â  Â  Â  Â  const dataHash = hashMessageForSigning(data);
Â  Â  Â  Â  Â  Â  const { signature } = await state.falconApi.sign(dataHash, privateKey);
Â  Â  Â  Â  Â  Â  return signature;
Â  Â  Â  Â  },
Â  Â  Â  Â  async verifySignature(signature, data, publicKey) {
Â  Â  Â  Â  Â  Â  if (!publicKey || !state.falconApi) throw new Error("Verification prerequisites not met.");
Â  Â  Â  Â  Â  Â  const dataHash = hashMessageForSigning(data);
Â  Â  Â  Â  Â  Â  return state.falconApi.verify(signature, dataHash, publicKey);
Â  Â  Â  Â  },
Â  Â  Â  Â  async encryptMasterKey(masterPrivateKeyBytes, passwordKey, visualKeySecret) {
Â  Â  Â  Â  Â  Â  const visualKeySalt = crypto.getRandomValues(new Uint8Array(16));
Â  Â  Â  Â  Â  Â  const visualKeyIV = crypto.getRandomValues(new Uint8Array(12));
Â  Â  Â  Â  Â  Â  const cryptoVisualKey = await pbkdf2DeriveKey(visualKeySecret, visualKeySalt);
Â  Â  Â  Â  Â  Â  const encryptedWithVisual = await crypto.subtle.encrypt({ name: AES_ALGO, iv: visualKeyIV }, cryptoVisualKey, masterPrivateKeyBytes);

Â  Â  Â  Â  Â  Â  const intermediatePayload = JSON.stringify({
Â  Â  Â  Â  Â  Â  Â  Â  encryptedKey: Utils.arrayBufferToBase64(encryptedWithVisual),
Â  Â  Â  Â  Â  Â  Â  Â  salt: Utils.arrayBufferToBase64(visualKeySalt),
Â  Â  Â  Â  Â  Â  Â  Â  iv: Utils.arrayBufferToBase64(visualKeyIV)
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  const passwordSalt = crypto.getRandomValues(new Uint8Array(16));
Â  Â  Â  Â  Â  Â  const passwordIV = crypto.getRandomValues(new Uint8Array(12));
Â  Â  Â  Â  Â  Â  const cryptoPasswordKey = await pbkdf2DeriveKey(passwordKey, passwordSalt);
Â  Â  Â  Â  Â  Â  const finalEncryptedKey = await crypto.subtle.encrypt({ name: AES_ALGO, iv: passwordIV }, cryptoPasswordKey, new TextEncoder().encode(intermediatePayload));
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  Â  Â  Â  fileKey: {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cipherText: Utils.arrayBufferToBase64(finalEncryptedKey),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  salt: Utils.arrayBufferToBase64(passwordSalt),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  iv: Utils.arrayBufferToBase64(passwordIV)
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  },
Â  Â  Â  Â  async reconstructMasterKey(fileKey, passwordKey, visualKeySecret) {
Â  Â  Â  Â  Â  Â  const passwordSalt = Utils.base64ToUint8Array(fileKey.salt);
Â  Â  Â  Â  Â  Â  const passwordIV = Utils.base64ToUint8Array(fileKey.iv);
Â  Â  Â  Â  Â  Â  const passwordCipherText = Utils.base64ToUint8Array(fileKey.cipherText);
Â  Â  Â  Â  Â  Â  const cryptoPasswordKey = await pbkdf2DeriveKey(passwordKey, passwordSalt);
Â  Â  Â  Â  Â  Â  const decryptedIntermediateBuffer = await crypto.subtle.decrypt({ name: AES_ALGO, iv: passwordIV }, cryptoPasswordKey, passwordCipherText);
Â  Â  Â  Â  Â  Â  const intermediatePayload = JSON.parse(new TextDecoder().decode(decryptedIntermediateBuffer));
Â  Â  Â  Â  Â  Â  const visualKeySalt = Utils.base64ToUint8Array(intermediatePayload.salt);
Â  Â  Â  Â  Â  Â  const visualKeyIV = Utils.base64ToUint8Array(intermediatePayload.iv);
Â  Â  Â  Â  Â  Â  const visualCipherText = Utils.base64ToUint8Array(intermediatePayload.encryptedKey);
Â  Â  Â  Â  Â  Â  const cryptoVisualKey = await pbkdf2DeriveKey(visualKeySecret, visualKeySalt);
Â  Â  Â  Â  Â  Â  const masterPrivateKeyBytes = await crypto.subtle.decrypt({ name: AES_ALGO, iv: visualKeyIV }, cryptoVisualKey, visualCipherText);
Â  Â  Â  Â  Â  Â  return new Uint8Array(masterPrivateKeyBytes);
Â  Â  Â  Â  },
Â  Â  Â  Â  deriveAESKeyFromPublicKey,
Â  Â  Â  Â  encryptPayload,
Â  Â  Â  Â  decryptPayload
Â  Â  };
})();

// ===================================================================================
// UI EVENT HANDLERS
// ===================================================================================
const UIHandlers = (() => {
Â  Â  function updatePuzzleStatus() {
Â  Â  Â  Â  const { fileKey, passwordKey, visualKey } = state.puzzlePieces;
Â  Â  Â  Â  let statusHtml = '';
Â  Â  Â  Â  statusHtml += fileKey ? '<span class="valid">âœ… File Key loaded.</span>\n' : '<span class="invalid">âŒ File Key NOT loaded.</span>\n';
Â  Â  Â  Â  statusHtml += passwordKey ? '<span class="valid">âœ… Password Key entered.</span>\n' : '<span class="invalid">âŒ Password Key NOT entered.</span>\n';
Â  Â  Â  Â  statusHtml += visualKey ? '<span class="valid">âœ… Visual Key scanned.</span>\n' : '<span class="invalid">âŒ Visual Key NOT scanned.</span>\n';
Â  Â  Â  Â  DOMElements.keyReconstructionStatus.innerHTML = statusHtml;
Â  Â  Â  Â  const allPiecesProvided = fileKey && passwordKey && visualKey;
Â  Â  Â  Â  DOMElements.reconstructKeyButton.disabled = !allPiecesProvided;
Â  Â  Â  Â  if (allPiecesProvided) {
Â  Â  Â  Â  Â  Â  Â Utils.updateStatus(DOMElements.keyReconstructionStatus, "âš ï¸ All puzzle pieces provided. Click 'Activate' to unlock your private key.", 'warning');
Â  Â  Â  Â  }
Â  Â  }
Â  Â Â 
Â  Â  return {
Â  Â  Â  Â  async handleGenerateAndExportKeys() {
Â  Â  Â  Â  Â  Â  const password = prompt("Enter a strong password. This will be your 'Password Key' (Piece 2/3).");
Â  Â  Â  Â  Â  Â  if (!password) {
Â  Â  Â  Â  Â  Â  Â  Â  Utils.updateStatus(DOMElements.keyGenStatus, 'âŒ Key generation cancelled. Password is required.', 'error');
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Utils.updateStatus(DOMElements.keyGenStatus, 'â³ Generating new Falcon-1024 key pair...', 'info');
Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  const keyPair = await BankCrypto.generateNewKeyPair();
Â  Â  Â  Â  Â  Â  Â  Â  state.masterPublicKey = keyPair.publicKey;
Â  Â  Â  Â  Â  Â  Â  Â  Utils.log("New Master Key Pair generated.", 'success');
Â  Â  Â  Â  Â  Â  Â  Â  Utils.updateStatus(DOMElements.keyGenStatus, 'â³ Creating puzzle pieces and encrypting private key...', 'info');
Â  Â  Â  Â  Â  Â  Â  Â  const visualKeySecret = crypto.randomUUID();
Â  Â  Â  Â  Â  Â  Â  Â  const { fileKey } = await BankCrypto.encryptMasterKey(keyPair.privateKey, password, visualKeySecret);
Â  Â  Â  Â  Â  Â  Â  Â  const publicKeyB64 = Utils.arrayBufferToBase64(keyPair.publicKey);
Â  Â  Â  Â  Â  Â  Â  Â  Utils.downloadFile(JSON.stringify({ masterPublicKey: publicKeyB64 }, null, 2), 'Sadat-MASTER-PUBLIC-KEY.json', 'application/json');
Â  Â  Â  Â  Â  Â  Â  Â  Utils.downloadFile(JSON.stringify(fileKey, null, 2), 'Sadat-FILE-KEY.json', 'application/json');
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  DOMElements.qrModalTitle.innerText = "Your Visual Key (Piece 3/3)";
Â  Â  Â  Â  Â  Â  Â  Â  DOMElements.qrDisplay.innerHTML = '';
Â  Â  Â  Â  Â  Â  Â  Â  const jabCodeBase64 = jabcode.encode_message(visualKeySecret);
Â  Â  Â  Â  Â  Â  Â  Â  const img = new Image();
Â  Â  Â  Â  Â  Â  Â  Â  img.src = jabCodeBase64;Â 
Â  Â  Â  Â  Â  Â  Â  Â  DOMElements.qrDisplay.appendChild(img);
Â  Â  Â  Â  Â  Â  Â  Â  DOMElements.qrModal.style.display = 'flex';

Â  Â  Â  Â  Â  Â  Â  Â  Utils.updateStatus(DOMElements.keyGenStatus, `âœ… New key pair generated!\n- MASTER-PUBLIC-KEY.json (share this)\n- FILE-KEY.json (keep this on a USB)\n- Password (memorize this)\n- Visual Key JAB Code (print and secure this)\nThe new Public Key is now active for validation.`, 'success');

Â  Â  Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  Â  Â  Utils.log(`Key generation failed: ${e.message}`, 'error');
Â  Â  Â  Â  Â  Â  Â  Â  Utils.updateStatus(DOMElements.keyGenStatus, `âŒ Failed to generate keys: ${e.message}`, 'error');
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  },
Â  Â  Â  Â  handleImportPublicKey: async (event) => { const file = event.target.files[0]; if (!file) return; try { const data = JSON.parse(await file.text()); if (!data.masterPublicKey) throw new Error("Invalid public key file format."); state.masterPublicKey = Utils.base64ToUint8Array(data.masterPublicKey); Utils.updateStatus(DOMElements.keyGenStatus, 'âœ… Public key imported. Ready to validate banknotes.', 'success'); DOMElements.validatorInput.disabled = false; } catch (error) { Utils.updateStatus(DOMElements.keyGenStatus, `âŒ Error importing public key: ${error.message}`, 'error'); } event.target.value = ''; },
Â  Â  Â  Â  handleFileKeyInput: async (event) => { const file = event.target.files[0]; if (!file) return; try { state.puzzlePieces.fileKey = JSON.parse(await file.text()); Utils.log("File Key loaded.", 'success'); } catch(e) { state.puzzlePieces.fileKey = null; Utils.log(`Failed to load File Key: ${e.message}`, 'error'); } updatePuzzleStatus(); event.target.value = ''; },
Â  Â  Â  Â  handlePasswordKeyInput: (event) => { state.puzzlePieces.passwordKey = event.target.value || null; updatePuzzleStatus(); },
Â  Â  Â  Â Â 
Â  Â  Â  Â  handleVisualKeyInput: (event) => {
Â  Â  Â  Â  Â  Â  const file = event.target.files[0];
Â  Â  Â  Â  Â  Â  if (!file) return;

Â  Â  Â  Â  Â  Â  const reader = new FileReader();
Â  Â  Â  Â  Â  Â  reader.onload = async (e) => {
Â  Â  Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const dataUrl = e.target.result;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const decodedText = await jabcode.decode_message(dataUrl);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (decodedText) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  state.puzzlePieces.visualKey = decodedText;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Utils.log("Visual Key loaded from file.", 'success');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â state.puzzlePieces.visualKey = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Utils.log("Failed to find a JAB code in the image.", 'error');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  } catch (error) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  state.puzzlePieces.visualKey = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Utils.log(`Error decoding JAB Code: ${error.message}`, 'error');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.error(error);
Â  Â  Â  Â  Â  Â  Â  Â  } finally {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updatePuzzleStatus();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  reader.onerror = () => {
Â  Â  Â  Â  Â  Â  Â  Â  Â state.puzzlePieces.visualKey = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â Utils.log("Failed to read the image file.", 'error');
Â  Â  Â  Â  Â  Â  Â  Â  Â updatePuzzleStatus();
Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  reader.readAsDataURL(file);
Â  Â  Â  Â  },

Â  Â  Â  Â  handleReconstructKey: async () => {Â 
Â  Â  Â  Â  Â  Â  const { fileKey, passwordKey, visualKey } = state.puzzlePieces;
Â  Â  Â  Â  Â  Â  if (!fileKey || !passwordKey || !visualKey) { Utils.updateStatus(DOMElements.keyReconstructionStatus, "âŒ All three puzzle pieces are required.", 'error'); return; }
Â  Â  Â  Â  Â  Â  Utils.updateStatus(DOMElements.keyReconstructionStatus, "â³ Reconstructing Master Private Key...", 'info');
Â  Â  Â  Â  Â   DOMElements.keyReconstructionStatus.innerHTML = statusHtml;
Â  Â  Â  Â  const allPiecesProvided = fileKey && passwordKey && visualKey;
Â  Â  Â  Â  DOMElements.reconstructKeyButton.disabled = !allPiecesProvided;
Â  Â  Â  Â  if (allPiecesProvided) {
Â  Â  Â  Â  Â  Â  Â Utils.updateStatus(DOMElements.keyReconstructionStatus, "âš ï¸ All puzzle pieces provided. Click 'Activate' to unlock your private key.", 'warning');
Â  Â  Â  Â  }
Â  Â  }
Â  Â Â 
Â  Â  return {
Â  Â  Â  Â  async handleGenerateAndExportKeys() {
Â  Â  Â  Â  Â  Â  const password = prompt("Enter a strong password. This will be your 'Password Key' (Piece 2/3).");
Â  Â  Â  Â  Â  Â  if (!password) {
Â  Â  Â  Â  Â  Â  Â  Â  Utils.updateStatus(DOMElements.keyGenStatus, 'âŒ Key generation cancelled. Password is required.', 'error');
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Utils.updateStatus(DOMElements.keyGenStatus, 'â³ Generating new Falcon-1024 key pair...', 'info');
Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  const keyPair = await BankCrypto.generateNewKeyPair();
Â  Â  Â  Â  Â  Â  Â  Â  state.masterPublicKey = keyPair.publicKey;
Â  Â  Â  Â  Â  Â  Â  Â  Utils.log("New Master Key Pair generated.", 'success');
Â  Â  Â  Â  Â  Â  Â  Â  Utils.updateStatus(DOMElements.keyGenStatus, 'â³ Creating puzzle pieces and encrypting private key...', 'info');
Â  Â  Â  Â  Â  Â  Â  Â  const visualKeySecret = crypto.randomUUID();
Â  Â  Â  Â  Â  Â  Â  Â  const { fileKey } = await BankCrypto.encryptMasterKey(keyPair.privateKey, password, visualKeySecret);
Â  Â  Â  Â  Â  Â  Â  Â  const publicKeyB64 = Utils.arrayBufferToBase64(keyPair.publicKey);
Â  Â  Â  Â  Â  Â  Â  Â  Utils.downloadFile(JSON.stringify({ masterPublicKey: publicKeyB64 }, null, 2), 'Sadat-MASTER-PUBLIC-KEY.json', 'application/json');
Â  Â  Â  Â  Â  Â  Â  Â  Utils.downloadFile(JSON.stringify(fileKey, null, 2), 'Sadat-FILE-KEY.json', 'application/json');
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  DOMElements.qrModalTitle.innerText = "Your Visual Key (Piece 3/3)";
Â  Â  Â  Â  Â  Â  Â  Â  DOMElements.qrDisplay.innerHTML = '';
Â  Â  Â  Â  Â  Â  Â  Â  const jabCodeBase64 = jabcode.encode_message(visualKeySecret);
Â  Â  Â  Â  Â  Â  Â  Â  const img = new Image();
Â  Â  Â  Â  Â  Â  Â  Â  img.src = jabCodeBase64;Â 
Â  Â  Â  Â  Â  Â  Â  Â  DOMElements.qrDisplay.appendChild(img);
Â  Â  Â  Â  Â  Â  Â  Â  DOMElements.qrModal.style.display = 'flex';

Â  Â  Â  Â  Â  Â  Â  Â  Utils.updateStatus(DOMElements.keyGenStatus, `âœ… New key pair generated!\n- MASTER-PUBLIC-KEY.json (share this)\n- FILE-KEY.json (keep this on a USB)\n- Password (memorize this)\n- Visual Key JAB Code (print and secure this)\nThe new Public Key is now active for validation.`, 'success');

Â  Â  Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  Â  Â  Utils.log(`Key generation failed: ${e.message}`, 'error');
Â  Â  Â  Â  Â  Â  Â  Â  Utils.updateStatus(DOMElements.keyGenStatus, `âŒ Failed to generate keys: ${e.message}`, 'error');
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  },
Â  Â  Â  Â  handleImportPublicKey: async (event) => { const file = event.target.files[0]; if (!file) return; try { const data = JSON.parse(await file.text()); if (!data.masterPublicKey) throw new Error("Invalid public key file format."); state.masterPublicKey = Utils.base64ToUint8Array(data.masterPublicKey); Utils.updateStatus(DOMElements.keyGenStatus, 'âœ… Public key imported. Ready to validate banknotes.', 'success'); DOMElements.validatorInput.disabled = false; } catch (error) { Utils.updateStatus(DOMElements.keyGenStatus, `âŒ Error importing public key: ${error.message}`, 'error'); } event.target.value = ''; },
Â  Â  Â  Â  handleFileKeyInput: async (event) => { const file = event.target.files[0]; if (!file) return; try { state.puzzlePieces.fileKey = JSON.parse(await file.text()); Utils.log("File Key loaded.", 'success'); } catch(e) { state.puzzlePieces.fileKey = null; Utils.log(`Failed to load File Key: ${e.message}`, 'error'); } updatePuzzleStatus(); event.target.value = ''; },
Â  Â  Â  Â  handlePasswordKeyInput: (event) => { state.puzzlePieces.passwordKey = event.target.value || null; updatePuzzleStatus(); },
Â  Â  Â  Â Â 
Â  Â  Â  Â  handleVisualKeyInput: (event) => {
Â  Â  Â  Â  Â  Â  const file = event.target.files[0];
Â  Â  Â  Â  Â  Â  if (!file) return;

Â  Â  Â  Â  Â  Â  const reader = new FileReader();
Â  Â  Â  Â  Â  Â  reader.onload = async (e) => {
Â  Â  Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const dataUrl = e.target.result;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const decodedText = await jabcode.decode_message(dataUrl);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (decodedText) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  state.puzzlePieces.visualKey = decodedText;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Utils.log("Visual Key loaded from file.", 'success');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â state.puzzlePieces.visualKey = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Utils.log("Failed to find a JAB code in the image.", 'error');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  } catch (error) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  state.puzzlePieces.visualKey = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Utils.log(`Error decoding JAB Code: ${error.message}`, 'error');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.error(error);
Â  Â  Â  Â  Â  Â  Â  Â  } finally {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updatePuzzleStatus();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  reader.onerror = () => {
Â  Â  Â  Â  Â  Â  Â  Â  Â state.puzzlePieces.visualKey = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â Utils.log("Failed to read the image file.", 'error');
Â  Â  Â  Â  Â  Â  Â  Â  Â updatePuzzleStatus();
Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  reader.readAsDataURL(file);
Â  Â  Â  Â  },

Â  Â  Â  Â  handleReconstructKey: async () => {Â 
Â  Â  Â  Â  Â  Â  const { fileKey, passwordKey, visualKey } = state.puzzlePieces;
Â  Â  Â  Â  Â  Â  if (!fileKey || !passwordKey || !visualKey) { Utils.updateStatus(DOMElements.keyReconstructionStatus, "âŒ All three puzzle pieces are required.", 'error'); return; }
Â  Â  Â  Â  Â  Â  Utils.updateStatus(DOMElements.keyReconstructionStatus, "â³ Reconstructing Master Private Key...", 'info');
Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  state.masterPrivateKey = await BankCrypto.reconstructMasterKey(fileKey, passwordKey, visualKey);
Â  Â  Â  Â  Â  Â  Â  Â  Utils.updateStatus(DOMElements.keyReconstructionStatus, "âœ… Master Private Key ACTIVE. You can now create banknotes.", 'success');
Â  Â  Â  Â  Â  Â  Â  Â  DOMElements.createNoteButton.disabled = false; DOMElements.downloadBatchButton.disabled = false;
Â  Â  Â  Â  Â  Â  } catch (error) {
Â  Â  Â  Â  Â  Â  Â  Â  console.error(error); Utils.updateStatus(DOMElements.keyReconstructionStatus, "âŒ Failed to reconstruct key. Check puzzle pieces and password.", 'error');
Â  Â  Â  Â  Â  Â  Â  Â  state.masterPrivateKey = null; DOMElements.createNoteButton.disabled = true; DOMElements.downloadBatchButton.disabled = true;
Â  Â  Â  Â  Â  Â  }Â 
Â  Â  Â  Â  },
Â  Â  };
})();

// ===================================================================================
// BANKNOTE LOGICÂ 
// ===================================================================================
const BanknoteLogic = (() => {

Â  Â  const getStandardizedDataForSigning = (noteData) => JSON.stringify({
Â  Â  Â  Â  amount: noteData.amount,
Â  Â  Â  Â  timestamp: noteData.timestamp,
Â  Â  Â  Â  serial: noteData.serial,
Â  Â  }, ['amount', 'timestamp', 'serial']);
Â  Â Â 
Â  Â  const getStandardizedDataForMasterSig = (noteData) => {
Â  Â  Â  Â  const tempNoteData = {
Â  Â  Â  Â  Â  Â  ephemeralPublicKey: Utils.arrayBufferToBase64(noteData.ephemeralPublicKey),
Â  Â  Â  Â  Â  Â  signatureOne: Utils.arrayBufferToBase64(noteData.signatureOne)
Â  Â  Â  Â  };
Â  Â  Â  Â  return JSON.stringify(tempNoteData, Object.keys(tempNoteData).sort());
Â  Â  };
Â  Â Â 
Â  Â  const createNoteData = async (amount) => {
Â  Â  Â  Â  if (!state.masterPrivateKey) throw new Error("Master Private Key is not active.");
Â  Â  Â  Â  const ephemeralKeyPair = await BankCrypto.generateNewKeyPair();
Â  Â  Â  Â Â 
Â  Â  Â  Â  const noteData = {
Â  Â  Â  Â  Â  Â  amount: parseInt(amount) || 0,
Â  Â  Â  Â  Â  Â  serial: Math.random().toString(36).substring(2, 10).toUpperCase(),
Â  Â  Â  Â  Â  Â  timestamp: Math.floor((Date.now() - Constants.EPOCH) / 1000),
Â  Â  Â  Â  Â  Â  verificationKey: Math.random().toString(36).substring(2, 10).toUpperCase(),
Â  Â  Â  Â  Â  Â  ephemeralPublicKey: ephemeralKeyPair.publicKey,
Â  Â  Â  Â  Â  Â  signatureOne: null,
Â  Â  Â  Â  Â  Â  signatureTwo: null
Â  Â  Â  Â  };
Â  Â  Â  Â Â 
Â  Â  Â  Â  const dataForSigOne = getStandardizedDataForSigning(noteData);
Â  Â  Â  Â  noteData.signatureOne = await BankCrypto.signData(dataForSigOne, ephemeralKeyPair.privateKey);
Â  Â  Â  Â Â 
Â  Â  Â  Â  const dataForSigTwo = getStandardizedDataForMasterSig(noteData);
Â  Â  Â  Â  noteData.signatureTwo = await BankCrypto.signData(dataForSigTwo, state.masterPrivateKey);
Â  Â  Â  Â Â 
Â  Â  Â  Â  return noteData;
Â  Â  };
Â  Â Â 
Â  Â  // FIX: JAB payload now contains the ephemeral public key and signatures
Â  Â  const createJabPayload = (noteData) => {
Â  Â  Â  Â  const payload = {
Â  Â  Â  Â  Â  Â  ephemeralPublicKey: Utils.arrayBufferToBase64(noteData.ephemeralPublicKey),
Â  Â  Â  Â  Â  Â  amount: noteData.amount,
Â  Â  Â  Â  Â  Â  timestamp: noteData.timestamp,
Â  Â  Â  Â  Â  Â  serial: noteData.serial
Â  Â  Â  Â  };
Â  Â  Â  Â  return JSON.stringify(payload);
Â  Â  };

Â  Â  // FIX: QR payload now contains only the signatures
Â  Â  const createQrPayload = (noteData) => {
Â  Â  Â  Â  const payload = {
Â  Â  Â  Â  Â  Â  signatureOne: Utils.arrayBufferToBase64(noteData.signatureOne),
Â  Â  Â  Â  Â  Â  signatureTwo: Utils.arrayBufferToBase64(noteData.signatureTwo)
Â  Â  Â  Â  };
Â  Â  Â  Â  return JSON.stringify(payload);
Â  Â  };

Â  Â  // FIX: JAB parser now reads a JSON object
Â  Â  const parseJabPayload = (decodedText) => {
Â  Â  Â  Â  return JSON.parse(decodedText);
Â  Â  };

Â  Â  const handleCreateAndSignNotes = async () => {
Â  Â  Â  Â  if (!state.masterPrivateKey) { alert("Master Private Key is not active. Please activate it in Step 2."); return; }
Â  Â  Â  Â  Utils.updateStatus(DOMElements.banknoteStatus, `â³ Creating and redesigning banknote with dual codes...`, 'info');
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  const noteData = await createNoteData(DOMElements.amountInput.value);
Â  Â  Â  Â  Â  Â  const jabPayload = createJabPayload(noteData);
Â  Â  Â  Â  Â  Â  const qrPayload = createQrPayload(noteData);

Â  Â  Â  Â  Â  Â  await BanknoteDrawer.drawNoteOnCanvas(DOMElements.noteCanvas, noteData, jabPayload, qrPayload, 1350, 750);
Â  Â  Â  Â  Â  Â  Utils.updateStatus(DOMElements.banknoteStatus, `âœ… New banknote designed with dual codes and ready for download.`, 'success');
Â  Â  Â  Â  } catch (error) {
Â  Â  Â  Â  Â  Â  Utils.updateStatus(DOMElements.banknoteStatus, `âŒ Error: ${error.message}`, 'error');
Â  Â  Â  Â  Â  Â  console.error(error);
Â  Â  Â  Â  }
Â  Â  };
Â  Â Â 
Â  Â  const handleDownloadBatch = async () => {
Â  Â  Â  Â  if (!state.masterPrivateKey) { alert("Master Private Key is not active. Please activate it in Step 2."); return; }
Â  Â  Â  Â  const quantity = parseInt(DOMElements.quantityInput.value) || 1;
Â  Â  Â  Â  Utils.updateStatus(DOMElements.banknoteStatus, `â³ Creating and downloading ${quantity} banknote(s)...`, 'info');
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  const offscreenCanvas = document.createElement('canvas');
Â  Â  Â  Â  Â  Â  offscreenCanvas.width = 1350; offscreenCanvas.height = 750;
Â  Â  Â  Â  Â  Â  const notesToDownload = [];
Â  Â  Â  Â  Â  Â  for (let i = 0; i < quantity; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const noteData = await createNoteData(DOMElements.amountInput.value);
Â  Â  Â  Â  Â  Â  Â  Â  const jabPayload = createJabPayload(noteData);
Â  Â  Â  Â  Â  Â  Â  Â  const qrPayload = createQrPayload(noteData);
Â  Â  Â  Â  Â  Â  Â  Â  await BanknoteDrawer.drawNoteOnCanvas(offscreenCanvas, noteData, jabPayload, qrPayload, 1350, 750);
Â  Â  Â  Â  Â  Â  Â  Â  const blob = await new Promise(resolve => offscreenCanvas.toBlob(resolve, 'image/png'));
Â  Â  Â  Â  Â  Â  Â  Â  notesToDownload.push({ blob, filename: `SADAT-NOTE-${noteData.serial}.png` });
Â  Â  Â  Â  Â  Â  Â  Â  if (i === quantity - 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  await BanknoteDrawer.drawNoteOnCanvas(DOMElements.noteCanvas, noteData, jabPayload, qrPayload, 1350, 750);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  if (quantity >= 1 && window.showDirectoryPicker) {
Â  Â  Â  Â  Â  Â  Â  Â  Â const dirHandle = await window.showDirectoryPicker();
Â  Â  Â  Â  Â  Â  Â  Â  Â for (const note of notesToDownload) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const fileHandle = await dirHandle.getFileHandle(note.filename, { create: true });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const writable = await fileHandle.createWritable();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  await writable.write(note.blob); await writable.close();
Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â  Â  Â Utils.updateStatus(DOMElements.banknoteStatus, `âœ… Saved ${quantity} notes to your selected folder.`, 'success');
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  notesToDownload.forEach(note => Utils.downloadFile(note.blob, note.filename, 'image/png'));
Â  Â  Â  Â  Â  Â  Â  Â  Utils.updateStatus(DOMElements.banknoteStatus, `âœ… Saved ${quantity} note(s). Check your downloads folder. Your browser may not support directory selection.`, 'success');
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } catch (error) {
Â  Â  Â  Â  Â  Â  Utils.updateStatus(DOMElements.banknoteStatus, `âŒ Error: ${error.message}`, 'error');
Â  Â  Â  Â  Â  Â  console.error(error);
Â  Â  Â  Â  } finally {
Â  Â  Â  Â  Â  Â  state.masterPrivateKey = null;
Â  Â  Â  Â  Â  Â  DOMElements.createNoteButton.disabled = true;
Â  Â  Â  Â  Â  Â  DOMElements.downloadBatchButton.disabled = true;
Â  Â  Â  Â  Â  Â  UIHandlers.handlePasswordKeyInput({target:{value:null}});
Â  Â  Â  Â  Â  Â  Utils.updateStatus(DOMElements.keyReconstructionStatus, "âš ï¸ Master Private Key is INACTIVE. Solve the puzzle to activate.", 'warning');
Â  Â  Â  Â  Â  Â  Utils.updateStatus(DOMElements.banknoteStatus, `âœ… Batch download complete. For security, the Master Key has been cleared from memory. Please reactivate in Step 2 for more actions.`, 'success');
Â  Â  Â  Â  Â  Â  Utils.log("Key cleared for security after batch operation.", 'warning');
Â  Â  Â  Â  }
Â  Â  };

Â  Â  const handleValidation = async (event) => {
Â  Â  Â  Â  const file = event.target.files[0];
Â  Â  Â  Â  if (!file || !state.masterPublicKey) return;
Â  Â  Â  Â  Utils.updateStatus(DOMElements.validationResult, 'â³ Scanning banknote image for both codes...', 'info');

Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  const dataUrl = await new Promise(resolve => {
Â  Â  Â  Â  Â  Â  Â  Â  const reader = new FileReader();
Â  Â  Â  Â  Â  Â  Â  Â  reader.onload = e => resolve(e.target.result);
Â  Â  Â  Â  Â  Â  Â  Â  reader.readAsDataURL(file);
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  let jabData, qrData;

Â  Â  Â  Â  Â  Â  // Scan JAB code
Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  const decodedText = await jabcode.decode_message(dataUrl);
Â  Â  Â  Â  Â  Â  Â  Â  if (!decodedText) throw new Error('JAB Code not found or unreadable.');
Â  Â  Â  Â  Â  Â  Â  Â  jabData = parseJabPayload(decodedText);
Â  Â  Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  Â  Â  throw new Error(`JAB Code scan failed: ${e.message}`);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // Scan QR code
Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  const img = new Image();
Â  Â  Â  Â  Â  Â  Â  Â  img.src = dataUrl;
Â  Â  Â  Â  Â  Â  	  await new Promise(resolve => { img.onload = resolve; });
Â  Â  Â  Â  Â  Â  Â  Â  const canvas = document.createElement('canvas');
Â  Â  Â  Â  Â  Â  Â  Â  canvas.width = img.width; canvas.height = img.height;
Â  Â  Â  Â  Â  Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â  Â  Â  Â  Â  Â  ctx.drawImage(img, 0, 0, img.width, img.height);
Â  Â  Â  Â  Â  Â  Â  Â  const imageData = ctx.getImageData(0, 0, img.width, img.height);
Â  Â  Â  Â  Â  Â  Â  Â  const code = jsQR(imageData.data, imageData.width, imageData.height);
Â  Â  Â  Â  Â  Â  Â  Â  if (!code) throw new Error('QR Code not found or unreadable.');
Â  Â  Â  Â  Â  Â  Â  Â  qrData = JSON.parse(code.data);
Â  Â  Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  Â  Â  throw new Error(`QR Code scan failed: ${e.message}`);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // Both codes found, proceed to validation
Â  Â  Â  Â  Â  Â  let resultHTML = '<span class="valid">âœ… Both codes scanned. Verifying signatures...</span>\n';
Â  Â  Â  Â  Â  Â  DOMElements.validationResult.innerHTML = resultHTML;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // Reconstruct note data from both codes
Â  Â  Â  Â  Â  Â  const noteDataForVerification = {
Â  Â  Â  Â  Â  Â  Â  Â  ...jabData,
Â  Â  Â  Â  Â  Â  Â  Â  signatureOne: Utils.base64ToUint8Array(qrData.signatureOne),
Â  Â  Â  Â  Â  Â  Â  Â  signatureTwo: Utils.base64ToUint8Array(qrData.signatureTwo)
Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â  const dataForSigOne = getStandardizedDataForSigning(noteDataForVerification);
Â  Â  Â  Â  Â  Â  const isSigOneValid = await BankCrypto.verifySignature(noteDataForVerification.signatureOne, dataForSigOne, Utils.base64ToUint8Array(noteDataForVerification.ephemeralPublicKey));
Â  Â  Â  Â  Â  Â  if (!isSigOneValid) {
Â  Â  Â  Â  Â  Â  Â  Â  resultHTML += '<span class="invalid">âŒ Ephemeral Signature (Sig 1) INVALID.</span>\n<hr><span>âŒ VERDICT: FORGERY</span>';
Â  Â  Â  Â  Â  Â  	  DOMElements.validationResult.innerHTML = resultHTML;
Â  Â  Â  Â  Â  Â  	  return;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  resultHTML += '<span class="valid">âœ… Ephemeral Signature (Sig 1) OK.</span>\n';

Â  Â  Â  Â  Â  Â  const dataForSigTwo = getStandardizedDataForMasterSig(noteDataForVerification);
Â  Â  Â  Â  Â  Â  const isSigTwoValid = await BankCrypto.verifySignature(noteDataForVerification.signatureTwo, dataForSigTwo, state.masterPublicKey);
Â  Â  Â  Â  Â  Â  if (!isSigTwoValid) {
Â  Â  Â  Â  Â  Â  	  resultHTML += '<span class="invalid">âŒ Master Signature (Sig 2) INVALID.</span>\n<hr><span>âŒ VERDICT: FORGERY</span>';
Â  Â  Â  Â  Â  Â  	  DOMElements.validationResult.innerHTML = resultHTML;
Â  Â  Â  Â  Â  Â  	  return;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  resultHTML += '<span class="valid">âœ… Master Signature (Sig 2) OK.</span>\n<hr><span style="font-size:14px;font-weight:600;">âœ… VERDICT: BANKNOTE IS AUTHENTIC</span>';
Â  Â  Â  Â  Â  Â  resultHTML += `\n<span style="font-size:14px;font-weight:600;">Amount: ${noteDataForVerification.amount} SAD</span>`;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  DOMElements.validationResult.innerHTML = resultHTML;

Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  Utils.updateStatus(DOMElements.validationResult, `âŒ Validation Error: ${e.message}`, 'error');
Â  Â  Â  Â  Â  Â  console.error(e);
Â  Â  Â  Â  } finally {
Â  Â  Â  Â  Â  Â  event.target.value = '';
Â  Â  Â  Â  }
Â  Â  };


Â  Â  return {
Â  Â  Â  Â  handleCreateAndSignNotes,
Â  Â  Â  Â  handleDownloadBatch,
Â  Â  Â  Â  handleValidation,
Â  Â  };
})();


// ===================================================================================
// BANKNOTE DRAWER -- PROFESSIONAL APPEARANCE MODULE
// ===================================================================================
const BanknoteDrawer = (() => {
Â  Â  const H = (text, index, min, max) => min + (parseInt(text.substring(index, index + 2), 16) % (max - min + 1));
Â  Â Â 
Â  Â  return {
Â  Â  Â  Â  drawNoteOnCanvas: async (targetCanvas, noteData, jabPayload, qrPayload, width, height) => {
Â  Â  Â  Â  Â  Â  return new Promise((resolve, reject) => {
Â  Â  Â  Â  Â  Â  Â  Â  const ctx = targetCanvas.getContext("2d");
Â  Â  Â  Â  Â  Â  Â  Â  const { amount, serial, verificationKey, signatureTwo } = noteData;
Â  Â  Â  Â  Â  Â  Â  Â  const scale = width / 1350;
Â  Â  Â  Â  Â  Â  Â  Â  const visualHash = shake256(signatureTwo, 256);

Â  Â  Â  Â  Â  Â  Â  Â  const bgGradient = ctx.createLinearGradient(0, 0, 0, height);
Â  Â  Â  Â  Â  Â  	  const baseHue = H(visualHash, 0, 0, 360);
Â  Â  Â  Â  Â  Â  	  bgGradient.addColorStop(0, `hsl(${baseHue}, 50%, 6%)`);
Â  Â  Â  Â  Â  Â  	  bgGradient.addColorStop(1, `hsl(${baseHue}, 40%, 4%)`);
Â  Â  Â  Â  Â  Â  	  ctx.fillStyle = bgGradient; ctx.fillRect(0, 0, width, height);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  	  ctx.shadowColor = "rgba(0,0,0,0.7)"; ctx.shadowBlur = 8 * scale;
Â  Â  Â  Â  Â  Â  	  ctx.shadowOffsetX = 2 * scale; ctx.shadowOffsetY = 2 * scale;
Â  Â  Â  Â  Â  Â  	  ctx.fillStyle = "#EAEAEA"; ctx.textAlign = 'left';
Â  Â  Â  Â  Â  Â  	  ctx.font = `bold ${80 * scale}px 'Roboto Mono'`;
Â  Â  Â  Â  Â  Â  	  ctx.fillText(serial, 150 * scale, 160 * scale);
Â  Â  Â  Â  Â  Â  	  ctx.fillText(verificationKey, 150 * scale, 280 * scale);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  	  ctx.font = `bold ${150 * scale}px 'Roboto Mono'`; ctx.textAlign = "right";
Â  Â  Â  Â  Â  Â  	  ctx.shadowBlur = 12 * scale; ctx.shadowOffsetX = 4 * scale; ctx.shadowOffsetY = 4 * scale;
Â  Â  Â  Â  Â  Â  	  ctx.fillText(amount.toString(), width - (120 * scale), 190 * scale);
Â  Â  Â  Â  Â  Â  	  ctx.shadowColor = "transparent";

Â  Â  Â  Â  Â  Â  	  let jabCodePromise, qrCodePromise;

Â  Â  Â  Â  Â  Â  	  try {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const jabCodeBase64 = jabcode.encode_message(jabPayload);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const jabImg = new Image();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  jabCodePromise = new Promise((resolve, reject) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  jabImg.onload = () => resolve(jabImg);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  jabImg.onerror = reject;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  	  jabImg.src = jabCodeBase64;
Â  Â  Â  Â  Â  Â  Â  Â  	  });
Â  Â  Â  Â  Â  Â  	  } catch (err) {
Â  Â  Â  Â  Â  Â  		  console.error("JAB Code Generation Error:", err);
Â  Â  Â  Â  Â  Â  		  reject(err);
Â  Â  Â  Â  Â  Â  		  return;
Â  Â  Â  Â  Â  Â  	  }

Â  Â  Â  Â  Â  Â  	  try {
Â  Â  Â  Â  Â  Â  		  const qrCanvas = document.createElement('canvas');
Â  Â  Â  Â  Â  Â  		  QRCode.toCanvas(qrCanvas, qrPayload, { errorCorrectionLevel: 'L', width: 380, margin: 4 }, function (error) {
Â  Â  Â  Â  Â  Â  			  if (error) reject(error);
Â  Â  Â  Â  Â  Â  		  });
Â  Â  Â  Â  Â  Â  		  qrCodePromise = new Promise(resolve => {
Â  Â  Â  Â  Â  Â  			  const qrImg = new Image();
Â  Â  Â  Â  Â  Â  			  qrImg.onload = () => resolve(qrImg);
Â  Â  Â  Â  Â  Â  			  qrImg.src = qrCanvas.toDataURL('image/png');
Â  Â  Â  Â  Â  Â  		  });
Â  Â  Â  Â  Â  Â  	  } catch (err) {
Â  Â  Â  Â  Â  Â  		  console.error("QR Code Generation Error:", err);
Â  Â  Â  Â  Â  Â  		  reject(err);
Â  Â  Â  Â  Â  Â  		  return;
Â  Â  Â  Â  Â  	  }

Â  Â  Â  Â  Â  	  Promise.all([jabCodePromise, qrCodePromise]).then(([jabImg, qrImg]) => {
Â  Â  Â  Â  Â  		  const jabX = width - (150 * scale) - (380 * scale);
Â  Â  Â  Â  Â  		  const jabY = height - (520 * scale);
Â  Â  Â  Â  Â  		  ctx.fillStyle = 'white';
Â  Â  Â  Â  Â  		  ctx.fillRect(jabX - (20 * scale), jabY - (20 * scale), (380 * scale) + (40 * scale), (380 * scale) + (40 * scale));
Â  Â  Â  Â  Â  		  ctx.drawImage(jabImg, jabX, jabY, 380 * scale, 380 * scale);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  		  const qrX = 150 * scale;
Â  Â  Â  Â  Â  		  const qrY = height - (520 * scale);
Â  Â  Â  Â  Â  		  ctx.fillStyle = 'white';
Â  Â  Â  Â  Â  		  ctx.fillRect(qrX - (20 * scale), qrY - (20 * scale), (380 * scale) + (40 * scale), (380 * scale) + (40 * scale));
Â  Â  Â  Â  Â  		  ctx.drawImage(qrImg, qrX, qrY, 380 * scale, 380 * scale);

Â  Â  Â  Â  Â  		  ctx.font = `${30 * scale}px 'Roboto Mono'`; ctx.fillStyle = "rgba(255,255,255,0.4)"; ctx.textAlign = "center";
Â  Â  Â  Â  Â  		  ctx.fillText("Dual-Signed by Sadat Guardian Authority (Falcon-1024)", width / 2, height - 60 * scale);
Â  Â  Â  Â  Â  		  resolve();

Â  Â  Â  Â  	  }).catch(err => {
Â  Â  Â  Â  		  console.error("Code Drawing Error:", err);
Â  Â  Â  Â  		  reject(err);
Â  Â  Â  Â  	  });
Â  Â  Â  Â    });
Â  Â  Â  Â  }
Â  Â  };
})();

// ===================================================================================
// APPLICATION INITIALIZATION
// ===================================================================================
async function main() {
Â  Â  Utils.updateStatus(DOMElements.keyGenStatus, 'â³ Loading Falcon-1024 Crypto Module...', 'info');
Â  Â  try {
Â  Â  Â  Â  state.falconApi = await pqcSignFalcon1024();
Â  Â  Â  Â  Utils.updateStatus(DOMElements.keyGenStatus, 'âœ… Modules loaded. Please generate or import keys to begin.', 'success');
Â  Â  Â  Â  Utils.log("All cryptographic modules initialized successfully.", 'success');
Â  Â  } catch (e) {
Â  Â  Â  Â  Utils.log(`Critical Error: Could not load required modules: ${e.message}`, 'error');
Â  Â  Â  Â  Utils.updateStatus(DOMElements.keyGenStatus, `âŒ Critical Error: Could not load modules. See console for details.`, 'error');
Â  Â  Â  Â  alert("Error: Failed to load a required cryptographic module. The application cannot run.");
Â  Â  Â  Â  return;
Â  Â  }
Â  Â Â 
Â  Â  DOMElements.generateKeysButton.addEventListener('click', UIHandlers.handleGenerateAndExportKeys);
Â  Â  DOMElements.importPublicKey.addEventListener('change', UIHandlers.handleImportPublicKey);
Â  Â  DOMElements.fileKeyInput.addEventListener('change', UIHandlers.handleFileKeyInput);
Â  Â  DOMElements.passwordKeyInput.addEventListener('input', UIHandlers.handlePasswordKeyInput);
Â  Â  DOMElements.visualKeyInput.addEventListener('change', UIHandlers.handleVisualKeyInput);
Â  Â  DOMElements.reconstructKeyButton.addEventListener('click', UIHandlers.handleReconstructKey);
Â  Â  DOMElements.createNoteButton.addEventListener('click', BanknoteLogic.handleCreateAndSignNotes);
Â  Â  DOMElements.downloadBatchButton.addEventListener('click', BanknoteLogic.handleDownloadBatch);
Â  Â  DOMElements.validatorInput.addEventListener('change', BanknoteLogic.handleValidation);
Â  Â Â 
Â  Â  DOMElements.downloadQrButton.addEventListener('click', () => {
Â  Â  Â  Â  const img = DOMElements.qrDisplay.querySelector('img');
Â  Â  Â  Â  if (img && img.src) {
Â  Â  Â  Â  Â  Â  const a = document.createElement('a');
Â  Â  Â  Â  Â  Â  a.href = img.src; a.download = 'Sadat-VISUAL-KEY.png';
Â  Â  Â  Â  Â  Â  document.body.appendChild(a); a.click(); document.body.removeChild(a);
Â  Â  Â  Â  }
Â  Â  });
}

main();
</script>
</body>
</html>
